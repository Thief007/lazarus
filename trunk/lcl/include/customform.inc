{%MainUnit ../forms.pp}

{******************************************************************************
                                     TCustomForm
 ******************************************************************************

 *****************************************************************************
 *                                                                           *
 *  This file is part of the Lazarus Component Library (LCL)                 *
 *                                                                           *
 *  See the file COPYING.LCL, included in this distribution,                 *
 *  for details about the copyright.                                         *
 *                                                                           *
 *  This program is distributed in the hope that it will be useful,          *
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of           *
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                     *
 *                                                                           *
 *****************************************************************************
}

{ $DEFINE CHECK_POSITION}

{------------------------------------------------------------------------------}
{       TCustomForm ClientWndProc                                              }
{------------------------------------------------------------------------------}
Procedure TCustomForm.ClientWndProc(var Message: TLMessage);

  procedure Default;
    begin
      {
      with Message do
      Result := CallWindowProc(FDefClientProc, ClientHandle, Msg, wParam, lParam);
     }
    end;

begin
  with Message do
    case Msg of
      LM_NCHITTEST:
        begin
          Default;
          if Result = HTCLIENT then Result := HTTRANSPARENT;
        end;
      LM_ERASEBKGND:
        begin
          // Not sure if this will work real good.
          //Canvas.FillRect(ClientRect);
          Result := 1;
        end;
    else
      Default;
    end;
end;

{------------------------------------------------------------------------------
  procedure TCustomForm.CloseModal;
 ------------------------------------------------------------------------------}
procedure TCustomForm.CloseModal;
var
  CloseAction: TCloseAction;
begin
  try
    CloseAction := caNone;
    if CloseQuery then
    begin
      CloseAction := caHide;
      DoClose(CloseAction);
    end;
    case CloseAction of
      caNone: ModalResult := 0;
      //caFree: Release;
    end;
  except
    ModalResult := 0;
    Application.HandleException(Self);
  end;
end;

{------------------------------------------------------------------------------
  Method: TCustomForm.BeforeDestruction
  Params:  None
  Returns: Nothing

  Gets called before the destruction of the object
 ------------------------------------------------------------------------------}
procedure TCustomForm.BeforeDestruction;
begin
  //GlobalNameSpace.BeginWrite;
  Destroying;
  Screen.FSaveFocusedList.Remove(Self);
  RemoveFixupReferences(Self, '');
  //if FOleForm <> nil then FOleForm.OnDestroy;
  if FormStyle <> fsMDIChild then Hide;
  DoDestroy;
  inherited BeforeDestruction;
end;

{------------------------------------------------------------------------------
  Method: TCustomForm.Destroy
  Params:  None
  Returns: Nothing

  Destructor for the class.
 ------------------------------------------------------------------------------}
destructor TCustomForm.Destroy;
begin
  //writeln('[TCustomForm.Destroy] A ',Name,':',ClassName);
  if not (csDestroying in ComponentState) then ;//GlobalNameSpace.BeginWrite;
  try
    // ------
    // Temp hack to get Beforedestruction called
    // FPC1.0.x doesn't call itself before destruction
    {$IFDEF VER1_0}BeforeDestruction;{$ENDIF}
    // ------
    FreeThenNil(FMenu);
    FreeThenNil(FIcon);
    Screen.RemoveForm(Self);
    FreeThenNil(FActionLists);
    //writeln('[TCustomForm.Destroy] B ',Name,':',ClassName);
    inherited Destroy;
    //writeln('[TCustomForm.Destroy] END ',Name,':',ClassName);
  finally
    //GlobalNameSpace.EndWrite;
  end;
end;

{------------------------------------------------------------------------------
  Method: TCustomForm.FocusControl
  Params:  None
  Returns: Nothing
 ------------------------------------------------------------------------------}
Procedure TCustomForm.FocusControl(WinControl : TWinControl);
var
  WasActive: Boolean;
begin
  WasActive := FActive;
  SetActiveControl(WinControl);
  if not WasActive then SetFocus;
End;

{------------------------------------------------------------------------------
  Method: TCustomForm.Notification
 ------------------------------------------------------------------------------}
Procedure TCustomForm.Notification(AComponent: TComponent;
  Operation: TOperation);
Begin
  inherited Notification(AComponent,Operation);

  case Operation of

  opInsert:
    begin
      if AComponent is TCustomActionList then begin
        if FActionLists=nil then FActionLists:=TList.Create;
        FActionLists.Add(AComponent);
      end
      else if not (csLoading in ComponentState) and (Menu = nil)
      and (AComponent.Owner=Self) and (AComponent is TMainMenu) then
        Menu:=TMainMenu(AComponent);
    end;

  opRemove:
    begin
      if (FActionLists<>nil) and (AComponent is TCustomActionList) then
        FActionLists.Remove(AComponent)
      else
      begin
        if Menu = AComponent then Menu := nil;
        //if WindowMenu = AComponent then WindowMenu := nil;
        //if ObjectMenuItem = AComponent then ObjectMenuItem := nil;
      end;
      if FActiveControl=AComponent then FActiveControl:=nil;
    end;
  end;
  if FDesigner<>nil then FDesigner.Notification(AComponent,Operation);
End;

{------------------------------------------------------------------------------
  Method: TCustomForm.IconChanged
 ------------------------------------------------------------------------------}
procedure TCustomForm.IconChanged(Sender: TObject);
begin
  if HandleAllocated {and (BorderStyle<>bsDialog)} then
    CNSendMessage(LM_SETFORMICON,Self,Pointer(GetIconHandle));
end;

{------------------------------------------------------------------------------
  function TCustomForm.IsKeyPreviewStored: boolean;
 ------------------------------------------------------------------------------}
function TCustomForm.IsKeyPreviewStored: boolean;
begin
  Result:=FKeyPreview=true;
end;

{------------------------------------------------------------------------------
  Method: TCustomForm.SetIcon
  Params: the new icon
 ------------------------------------------------------------------------------}
procedure TCustomForm.SetIcon(AValue: TIcon);
begin
  if FIcon=nil then begin
    FIcon:=TIcon.Create;
    FIcon.OnChange := @IconChanged;
  end;
  FIcon.Assign(AValue);
end;

{------------------------------------------------------------------------------
  procedure TCustomForm.SetModalResult(const AValue: TModalResult);
 ------------------------------------------------------------------------------}
procedure TCustomForm.SetModalResult(const AValue: TModalResult);
begin
  if FModalResult=AValue then exit;
  FModalResult:=AValue;
end;

{------------------------------------------------------------------------------
  Method: TCustomForm.IsIconStored
  Returns: if form icon should be stored in the stream
 ------------------------------------------------------------------------------}
function TCustomForm.IsIconStored: Boolean;
begin
  Result := IsForm and (Icon<>nil);
end;

{------------------------------------------------------------------------------
  Method: TCustomForm.GetIconHandle
  Returns: handle of form icon
 ------------------------------------------------------------------------------}
function TCustomForm.GetIconHandle: HICON;
begin
//writeln('[TCustomForm.GetIconHandle] ',ClassName,' ',FIcon<>nil);
  if (FIcon<>nil) and not Icon.Empty then
    Result := FIcon.Handle
  else
    Result := Application.GetIconHandle;
end;

{------------------------------------------------------------------------------
  Method: TCustomForm.SetFocus
 ------------------------------------------------------------------------------}
Procedure TCustomForm.SetFocus;

  procedure RaiseCannotFocus;
  var
    s: String;
  begin
    s:='[TCustomForm.SetFocus] '+Name+':'+ClassName+' '+rsCanNotFocus;
    {$IFDEF VerboseFocus}
    RaiseGDBException(s);
    {$ELSE}
    raise EInvalidOperation.Create(s);
    {$ENDIF}
  end;

Begin
  {$IFDEF VerboseFocus}
  writeln('TCustomForm.SetFocus ',Name,':',ClassName);
  {$ENDIF}
  if not FActive then
  begin
    if not (Visible and Enabled) then
      RaiseCannotFocus;
    SetWindowFocus;
  end;
end;

{------------------------------------------------------------------------------
       TCustomForm SetVisible
------------------------------------------------------------------------------}
Procedure TCustomForm.SetVisible(Value : boolean);
Begin
  if (Value=(fsVisible in FFormState)) and (Visible=Value) then exit;
  //writeln('[TCustomForm.SetVisible] START ',Name,':',ClassName,' Old=',Visible,' New=',Value,' ',(fsCreating in FFormState),' ',FormUpdating);
  if Value then
    Include(FFormState, fsVisible)
  else
    Exclude(FFormState, fsVisible);
  //writeln('TCustomForm.SetVisible ',Name,':',ClassName,' FormUpdating=',FormUpdating,' fsCreating=',fsCreating in FFormState);
  if (fsCreating in FFormState) {or FormUpdating} then
    // will be done when finished loading
  else
  begin
    inherited Visible:=Value;
  end;
  //writeln('[TCustomForm.SetVisible] END ',Name,':',ClassName,' ',Value,' ',(fsCreating in FFormState),' ',FormUpdating,' ',Visible);
end;

{------------------------------------------------------------------------------
  procedure TCustomForm.SetWindowFocus;
 ------------------------------------------------------------------------------}
procedure TCustomForm.SetWindowFocus;
var
  NewFocusControl: TWinControl;
begin
  if (FActiveControl <> nil) and (FDesigner = nil) then
    NewFocusControl := FActiveControl
  else
    NewFocusControl := Self;
  {$IFDEF VerboseFocus}
  writeln('TCustomForm.SetWindowFocus ',Name,':',Classname ,
    ' NewFocusControl=',NewFocusControl.Name,':',NewFocusControl.ClassName,
    ' HndAlloc=',NewFocusControl.HandleAllocated);
  {$ENDIF}
  if (not NewFocusControl.HandleAllocated)
  or (not NewFocusControl.Visible)
  or (not NewFocusControl.Enabled) then
    exit;
  LCLIntf.SetFocus(NewFocusControl.Handle);
  if GetFocus = NewFocusControl.Handle then
    NewFocusControl.Perform(CM_UIACTIVATE, 0, 0);
end;

{------------------------------------------------------------------------------
  Method: TCustomForm.WMShowWindow
  Params:   Msg: The showwindow message
  Returns:  nothing

  ShowWindow event handler.
 ------------------------------------------------------------------------------}
procedure TCustomForm.WMShowWindow(var message: TLMShowWindow);
begin
  {$IFDEF VerboseFocus}
  write('TCustomForm.WMShowWindow A ',Name,':',ClassName,' fsShowing=',fsShowing in FFormState,' Msg.Show=',Message.Show);
  if FActiveControl<>nil then begin
    write(' FActiveControl=',FActiveControl.Name,':',FActiveControl.ClassName,' HandleAllocated=',FActiveControl.HandleAllocated);
  end else begin
    write(' FActiveControl=nil');
  end;
  writeln('');
  {$ENDIF}
  if (fsShowing in FFormState) then exit;
  Include(FFormState, fsShowing);
  try
    if Message.Show then begin
      if (FActiveControl<>nil) and FActiveControl.HandleAllocated
      and (FActiveControl.Visible) and (FActiveControl.Enabled) then begin
        {$IFDEF VerboseFocus}
        writeln('TCustomForm.WMShowWindow B ',FActiveControl.Name,':',FActiveControl.ClassName);
        {$ENDIF}
        LCLIntf.SetFocus(FActiveControl.Handle);
      end;
      DoShow;
    end else begin
      DoHide;
    end;
  finally
    Exclude(FFormState, fsShowing);
  end;
end;

{------------------------------------------------------------------------------
  Method: TCustomForm.WMActivate
  Params:   Msg: When the form is Activated
  Returns:  nothing

  Activate event handler.
 ------------------------------------------------------------------------------}
procedure TCustomForm.WMActivate(var Message : TLMActivate);
begin
  {$IFDEF VerboseFocus}
  writeln('TCustomForm.WMActivate A ',Name,':',ClassName,' Msg.Active=',Message.Active);
  {$ENDIF}
  if (FormStyle <> fsMDIForm) or (csDesigning in ComponentState) then
    SetActive(Message.Active {<> WA_INACTIVE});
  FActive:=true;
  Activate;
end;

{------------------------------------------------------------------------------
  Method: TCustomForm.WMDeactivate
  Params: Msg: When the form is deactivated (loses focus within application)
  Returns: nothing

  Form deactivation (losing focus within application)  event handler.
 ------------------------------------------------------------------------------}
procedure TCustomForm.WMDeactivate(var Message : TLMActivate);
begin
  FActive:=false;
  Deactivate;
end;

{------------------------------------------------------------------------------
  Method: TCustomForm.Activate
  Params: none
  Returns:  nothing

  Activation form methode event handler.
 ------------------------------------------------------------------------------}
procedure TCustomForm.Activate;
begin
  if Assigned(FOnActivate) then FOnActivate(Self);
end;

{------------------------------------------------------------------------------
  procedure TCustomForm.ActiveChanged;
 ------------------------------------------------------------------------------}
procedure TCustomForm.ActiveChanged;
begin

end;

{------------------------------------------------------------------------------
  Method: TCustomForm.Deactivate
  Params: none
  Returns: nothing

  Form deactivation (losing focus within application)  event handler.
 ------------------------------------------------------------------------------}
procedure TCustomForm.Deactivate;
begin
  if Assigned(FOnDeactivate) then FOnDeactivate(Self);
end;

{------------------------------------------------------------------------------
  Method: TCustomForm.WMPaint
  Params:   Msg: The paint message
  Returns:  nothing

  Paint event handler.
 ------------------------------------------------------------------------------}
procedure TCustomForm.WMPaint(var Message: TLMPaint);
begin
//writeln('[TCustomForm.WMPaint] ',Name,':',ClassName);
  inherited WMPaint(Message);
//writeln('[TCustomForm.WMPaint] END ',Name,':',ClassName);
end;


{------------------------------------------------------------------------------
  Method: TCustomForm.WMSize
  Params:   Msg: The Size message
  Returns:  nothing

  Resize event handler.
 ------------------------------------------------------------------------------}
procedure TCustomForm.WMSize(var Message: TLMSize);
var
  OldState: TWindowState;
begin
  {$IFDEF CHECK_POSITION}
  Writeln('[TCustomForm.WMSize] Name=',Name,' Class=',ClassName,' Message.Width=',Message.Width,' Message.Height=',Message.Height);
  {$ENDIF}
  Assert(False, 'Trace:WMSIZE in TCustomForm');
  if not (csDesigning in ComponentState) then begin
    OldState:=FWindowState;
    Case Message.SizeType of
      SIZENORMAL : FWindowState := wsNormal;
      SIZEICONIC : FWindowState := wsMinimized;
      SIZEFULLSCREEN : FWindowState := wsMaximized;
    end;
    if OldState<>FWindowState then begin
      //if Assigned(OnWindowStateChanged) then OnWindowStateChanged(Self);
    end;
  end;

  inherited WMSize(Message);
End;

{------------------------------------------------------------------------------
  Method: TCustomForm.DefocusControl
  Params:   Control: the control which is to be defocused
            Removing: is it to be defocused because it is being removed?
  Returns:  nothing

  Updates ActiveControl if it is to be defocused
 ------------------------------------------------------------------------------}
procedure TCustomForm.DefocusControl(Control: TWinControl; Removing: Boolean);
begin
  if Control.ContainsControl(FActiveControl) then
    ActiveControl := nil;
end;

{------------------------------------------------------------------------------
  Method: TCustomForm.DoCreate
  Params:   none
  Returns:  nothing

  Calls user handler
 ------------------------------------------------------------------------------}
procedure TCustomForm.DoCreate;
begin
  BeginUpdateBounds;
  if Assigned(FOnCreate) then FOnCreate(Self);
  EndUpdateBounds;
end;

{------------------------------------------------------------------------------
  Method: TCustomForm.DoClose
  Params:   none
  Returns:  nothing

  Calls user handler
 ------------------------------------------------------------------------------}
procedure TCustomForm.DoClose(var CloseAction: TCloseAction);
begin
  if Assigned(FOnClose) then FOnClose(Self, CloseAction);
end;

{------------------------------------------------------------------------------
  Method: TCustomForm.DoDestroy
  Params:   none
  Returns:  nothing

  Calls user handler
 ------------------------------------------------------------------------------}
procedure TCustomForm.DoDestroy;
begin
  if Assigned(FOnDestroy) then FOnDestroy(Self);
end;

{------------------------------------------------------------------------------
  procedure TCustomForm.SetActive(AValue: Boolean);
 ------------------------------------------------------------------------------}
procedure TCustomForm.SetActive(AValue: Boolean);
begin
  FActive := AValue;
  //if FActiveOleControl <> nil then
  //  FActiveOleControl.Perform(CM_DOCWINDOWACTIVATE, WParam(Ord(Value)), 0);
  if FActive then
  begin
    if (ActiveControl = nil) and not (csDesigning in ComponentState) then
      ActiveControl := FindNextControl(nil, True, True, False);
    //MergeMenu(True);
    SetWindowFocus;
  end;
end;

{------------------------------------------------------------------------------
  Method: TCustomForm.DoHide
  Params:   none
  Returns:  nothing

  Calls user handler
 ------------------------------------------------------------------------------}
procedure TCustomForm.DoHide;
begin
  if Assigned(FOnHide) then FOnHide(Self);
end;

{------------------------------------------------------------------------------
  Method: TCustomForm.DoShow
  Params:   none
  Returns:  nothing

  Calls user handler
 ------------------------------------------------------------------------------}
procedure TCustomForm.DoShow;
begin
  if Assigned(FOnShow) then FOnShow(Self);
end;

{------------------------------------------------------------------------------
  procedure TCustomForm.EndFormUpdate;
 ------------------------------------------------------------------------------}
procedure TCustomForm.EndFormUpdate;
begin
  dec(FFormUpdateCount);
  if FFormUpdateCount=0 then begin
    Visible:=(fsVisible in FFormState);
  end;
end;

{------------------------------------------------------------------------------
  function TCustomForm.FormUpdating: boolean;
 ------------------------------------------------------------------------------}
function TCustomForm.FormUpdating: boolean;
begin
  Result:=FFormUpdateCount>0;
end;

{------------------------------------------------------------------------------
  Method: TCustomForm.GetChildren
  Params:   Proc - see fcl/inc/writer.inc
            Root
  Returns:  nothing

  Adds component to children list which have no parent.
    (TWinControl only lists components with parents)
 ------------------------------------------------------------------------------}
procedure TCustomForm.GetChildren(Proc: TGetChildProc; Root: TComponent);
var
  I: Integer;
  OwnedComponent: TComponent;
begin
  inherited GetChildren(Proc, Root);
  if Root = Self then
    for I := 0 to ComponentCount - 1 do begin
      OwnedComponent := Components[I];
      if OwnedComponent.HasParent = False
        then Proc(OwnedComponent);
    end;
end;

{------------------------------------------------------------------------------
  Method: TCustomForm.PaintWindow
  Params:   none
  Returns:  nothing

  Calls user handler
 ------------------------------------------------------------------------------}
Procedure TCustomForm.PaintWindow(DC : Hdc);
begin
//  FCanvas.Lock;
  try
    FCanvas.Handle := DC;
//writeln('[TCustomForm.PaintWindow] ',ClassName,' DC=',HexStr(DC,8),'  ',HexStr(FCanvas.Handle,8));
    try
      if FDesigner <> nil then FDesigner.PaintGrid else Paint;
    finally
      FCanvas.Handle := 0;
    end;
  finally
//    FCanvas.Unlock;
  end;
end;


{------------------------------------------------------------------------------
  Method: TCustomForm.RequestAlign
  Params:   none
  Returns:  nothing

  Calls user handler
 ------------------------------------------------------------------------------}
Procedure TCustomForm.RequestAlign;
Begin
  if Parent = nil then begin
    //Screen.AlignForm(Self);
  end
  else
  inherited RequestAlign;
end;

{------------------------------------------------------------------------------
       TCustomForm SetDesigner
------------------------------------------------------------------------------}
Procedure TCustomForm.SetDesigner(Value : TIDesigner);
Begin
  FDesigner := Value;
end;

{------------------------------------------------------------------------------
       TCustomForm ValidateRename
  if AComponent is nil, then the name of Self is changed
------------------------------------------------------------------------------}
procedure TCustomForm.ValidateRename(AComponent: TComponent;
  const CurName, NewName: String);
begin
  inherited ValidateRename(AComponent, CurName, NewName);
  if FDesigner <> nil then
    FDesigner.ValidateRename(AComponent, CurName, NewName);
end;

{------------------------------------------------------------------------------
  procedure TCustomForm.SetZOrder(Topmost: Boolean);
------------------------------------------------------------------------------}
procedure TCustomForm.SetZOrder(Topmost: Boolean);
begin
  if Parent=nil then begin
    if TopMost and HandleAllocated then begin
      BringWindowToTop(Handle);
    end;
    exit;
  end;
  inherited SetZOrder(Topmost);
end;

{------------------------------------------------------------------------------
  procedure TCustomForm.VisibleChanging;
------------------------------------------------------------------------------}
procedure TCustomForm.VisibleChanging;
begin
  //if (FormStyle = fsMDIChild) and Visible then
  //  raise EInvalidOperation.Create(SMDIChildNotVisible);
end;

{------------------------------------------------------------------------------
       TCustomForm WndProc
------------------------------------------------------------------------------}
procedure TCustomForm.WndProc(Var TheMessage : TLMessage);
var
  FocusHandle : HWND;
//  SaveIndex : Integer;
  MenuItem : TMenuItem;
//  Canvas2 : TCanvas;
//  DC: HDC;

begin
// Assert(False, 'Trace:-----------------IN TCUSTOMFORM WNDPROC-------------------');
  with TheMessage do
  case Msg of
    LM_ACTIVATE, LM_SETFOCUS, LM_KILLFOCUS:
      begin
        if not FocusMessages then Exit;
        if (Msg = LM_SetFocus) and not (csDesigning in ComponentState)
        then begin
          FocusHandle := 0;
          if FormStyle = fsMDIFORM
          then begin
            // ToDo
          end
          else begin
            if (FActiveControl <> nil) and (FActiveControl <> Self)
            and (FActiveControl.Visible) and (FActiveControl.Enabled)
            then FocusHandle := FActiveControl.Handle;
          end;
          TheMessage.Result:=0;
          if FocusHandle <> 0
          then begin
            {$IFDEF VerboseFocus}
            writeln('[TCustomForm.WndProc] ',Name,':',ClassName);
            {$ENDIF}
            LCLIntf.SetFocus(FocusHandle);
            Exit;
          end;
        end;
      end;
    CM_EXIT:
      begin
        //TODO: deal with docking                if HostDockSite <> nil then DeActivate;
      end;
    CM_ENTER:
      begin
        //TODO: Deal with docking                if HostDockSite <> nil then Activate;
      end;
    LM_WINDOWPOSCHANGING:
      if ([csLoading, csDesigning] * ComponentState = [csLoading])
      then begin
        if  (Position in [poDefault, poDefaultPosOnly])
        and (WindowState <> wsMaximized)
        then
          with PWindowPos(TheMessage.lParam)^ do
            flags := flags or SWP_NOMOVE;

        if  (Position in [poDefault, poDefaultSizeOnly])
        and (BorderStyle in [bsSizeable, bsSizeToolWin])
        then
          with PWindowPos(TheMessage.lParam)^ do
            flags := flags or SWP_NOSIZE;
      end;
    LM_DRAWITEM:
      with PDrawItemStruct(TheMessage.LParam)^ do
      begin
        if (CtlType = ODT_MENU) and Assigned(Menu)
        then begin
          MenuItem := Menu.FindItem(itemID, fkCommand);
          if MenuItem <> nil
          then begin
            {Canvas2 := TControlCanvas.Create;
            with Canvas2 do
            try
              SaveIndex := SaveDC(hDC);
              try
                Handle := hDC;
                Font := Screen.MenuFont;
                Menus.DrawMenuItem(MenuItem, Canvas2, rcItem,
                  TOwnerDrawState(LongRec(itemState).Lo));
              finally
                Handle := 0;
riteln('[TCustomForm.WndPRoc] 1');
                RestoreDC(hDC, SaveIndex)
              end;
            finally
              Free;
            end;
            }
            Exit;
          end;
        end;
      end;
{
    LM_MEASUREITEM:
      with PMeasureItemStruct(Message.LParam)^ do
      begin
        if (CtlType = ODT_MENU) and Assigned(Menu)
        then begin
          MenuItem := Menu.FindItem(itemID, fkCommand);
          if MenuItem <> nil
          then begin
            DC := GetWindowDC(Handle);
            try
              Canvas2 := TControlCanvas.Create;
              with Canvas2 do
              try
                SaveIndex := SaveDC(DC);
                try
                  Handle := DC;
                  Font := Screen.MenuFont;
                  TMenuItemAccess(MenuItem).MeasureItem(Canvas2,
                    Integer(itemWidth), Integer(itemHeight));
                finally
                  Handle := 0;
                  RestoreDC(DC, SaveIndex);
                end;
              finally
                Canvas2.Free;
              end;
            finally
              ReleaseDC(Handle, DC);
            end;

            Exit;
          end;
        end;
      end;
}
    LM_SHOWWINDOW:
      begin
        Assert(False, 'Trace:LM_SHOWWINDOW RECEIVED!!!!!!!!!!!');
      end;
    end;
  inherited WndProc(TheMessage);
end;

function TCustomForm.VisibleIsStored: boolean;
begin
  Result:=Visible;
end;

function TCustomForm.ColorIsStored: boolean;
begin
  Result:=(Color<>clBtnFace);
end;

procedure TCustomForm.CMActionExecute(var Message: TLMessage);
begin
  if DoExecuteAction(TBasicAction(Message.LParam)) then
    Message.Result := 1;
end;

procedure TCustomForm.CMActionUpdate(var Message: TLMessage);
begin
  if DoUpdateAction(TBasicAction(Message.LParam)) then
    Message.Result := 1;
end;

function TCustomForm.DoExecuteAction(ExeAction: TBasicAction): boolean;

  function ProcessExecute(Control: TControl): Boolean;
  begin
    Result := (Control <> nil) and
      Control.ExecuteAction(ExeAction);
  end;

  function TraverseClients(Container: TWinControl): Boolean;
  var
    I: Integer;
    Control: TControl;
  begin
    if Container.Showing then
      for I := 0 to Container.ControlCount - 1 do
      begin
        Control := Container.Controls[I];
        if Control.Visible and ProcessExecute(Control)
        or (Control is TWinControl) and TraverseClients(TWinControl(Control))
        then begin
          Result := True;
          exit;
        end;
      end;
    Result := False;
  end;

begin
  Result := false;
  if (csDesigning in ComponentState) or (not Showing) then exit;
  if ProcessExecute(ActiveControl) or ProcessExecute(Self)
  or TraverseClients(Self) then
    Result := true;
end;

function TCustomForm.DoUpdateAction(TheAction: TBasicAction): boolean;

  function ProcessUpdate(Control: TControl): Boolean;
  begin
    Result := (Control <> nil) and
      Control.UpdateAction(TheAction);
  end;

  function TraverseClients(Container: TWinControl): Boolean;
  var
    I: Integer;
    Control: TControl;
  begin
    if Container.Showing then
      for I := 0 to Container.ControlCount - 1 do
      begin
        Control := Container.Controls[I];
        if Control.Visible and ProcessUpdate(Control)
        or (Control is TWinControl) and TraverseClients(TWinControl(Control))
        then begin
          Result := True;
          exit;
        end;
      end;
    Result := False;
  end;

begin
  Result:=false;
  if (csDesigning in ComponentState) or not Showing then exit;
  { Find a target for given Command (Message.LParam). }
  if ProcessUpdate(ActiveControl) or ProcessUpdate(Self)
  or TraverseClients(Self) then
    Result:=true;
end;

procedure TCustomForm.UpdateActions;

  procedure RecursiveInitiate(Container: TWinControl);
  var
    i: Integer;
    CurControl: TControl;
  begin
    if not Container.Showing then exit;
    for i := 0 to Container.ControlCount - 1 do begin
      CurControl := Container.Controls[i];
      if (csActionClient in CurControl.ControlStyle)
      and CurControl.Visible then
        CurControl.InitiateAction;
      if CurControl is TWinControl then
        RecursiveInitiate(TWinControl(CurControl));
    end;
  end;

var
  I: Integer;
begin
  if (csDesigning in ComponentState) or (not Showing) then exit;
  // update this form
  InitiateAction;
  // update main menu's top-most items
  if Menu <> nil then
    for I := 0 to Menu.Items.Count - 1 do
      with Menu.Items[I] do
        if Visible then InitiateAction;
  // update all controls
  RecursiveInitiate(Self);
end;

{------------------------------------------------------------------------------}
{       TCustomForm SetMenu                                                      }
{------------------------------------------------------------------------------}
Procedure TCustomForm.SetMenu(Value : TMainMenu);
var
  I: Integer;
begin
  //TODO: Finish SETMenu
  if FMenu=Value then exit;
  if Value <> nil then
    for I := 0 to Screen.FormCount - 1 do
      if (Screen.Forms[I].Menu = Value) and (Screen.Forms[I] <> Self) then
        raise EInvalidOperation.CreateFmt(sDuplicateMenus, [Value.Name]);

  if FMenu<>nil then FMenu.Parent:=nil;

  if (csDestroying in ComponentState) or
    ((Value <> nil) and (csDestroying in Value.ComponentState))
  then
    Value := nil;

  FMenu := Value;
  if FMenu<>nil then begin
    FMenu.Parent:=Self;
    if HandleAllocated then
    begin
      FMenu.HandleNeeded;
      InterfaceObject.AttachMenuToWindow(FMenu);
    end;
  end;
end;

{------------------------------------------------------------------------------}
{       TCustomForm SetBorderStyle                                                      }
{------------------------------------------------------------------------------}
Procedure TCustomForm.SetBorderStyle(Value : TFormBorderStyle);
Begin
  if FBorderStyle = Value then exit;
  //TODO: Finish SETBORDERSTYLE
  FBorderStyle := Value;
  Include(FFormState,fsBorderStyleChanged);
end;

{------------------------------------------------------------------------------}
{       TCustomForm UpdateWindowState                                                      }
{------------------------------------------------------------------------------}
Procedure TCustomForm.UpdateWindowState;
Begin
//TODO: Finish UpdateWindowState
  Assert(False, 'Trace:TODO: [TCustomForm.UpdateWindowState]');
end;

{------------------------------------------------------------------------------}
{       TCustomForm SetWindowState                                                      }
{------------------------------------------------------------------------------}
Procedure TCustomForm.SetWindowState(Value : TWindowState);
const
  ShowCommands: array[TWindowState] of Integer =
    (SW_SHOWNORMAL, SW_MINIMIZE, SW_SHOWMAXIMIZED);
begin
  if FWindowState <> Value then
  begin
    FWindowState := Value;
    if not (csDesigning in ComponentState) and Showing then
      ShowWindow(Handle, ShowCommands[Value]);
  end;
end;

{------------------------------------------------------------------------------}
{       TCustomForm SetActiveControl                                                      }
{------------------------------------------------------------------------------}
Procedure TCustomForm.SetActiveControl(AWinControl: TWinControl);
Begin
  if FActiveControl <> AWinControl then
  begin
    if not
      ((AWinControl = nil)
      or (AWinControl <> Self) and (GetParentForm(AWinControl) = Self)
        and ((csLoading in ComponentState) or AWinControl.CanFocus))
    then
      RaiseGDBException(SCannotFocus);
      // EInvalidOperation.Create(SCannotFocus);
    {$IFDEF VerboseFocus}
    write('TCustomForm.SetActiveControl ',Name,':',ClassName,' FActive=',FActive);
    if FActiveControl<>nil then
      writeln(' OldActiveControl=',FActiveControl.Name,':',FActiveControl.ClassName)
    else
      writeln(' OldActiveControl=nil');
    if AWinControl<>nil then
      writeln(' NewActiveControl=',AWinControl.Name,':',AWinControl.ClassName)
    else
      writeln(' NewActiveControl=nil');
    {$ENDIF}
    FActiveControl := AWinControl;
    if not (csLoading in ComponentState) then
    begin
      if FActive then SetWindowFocus;
      ActiveChanged;
    end;
  end;
end;

{------------------------------------------------------------------------------}
{       TCustomForm SetFormStyle                                                      }
{------------------------------------------------------------------------------}
Procedure TCustomForm.SetFormStyle(Value : TFormStyle);
Begin
  if FFormStyle = Value then exit;
  //TODO: Finish SETFORMSTYLE
  FFormStyle := Value;
  Include(FFormState,fsFormStyleChanged);
end;

{------------------------------------------------------------------------------}
{       TCustomForm SetPosition                                                      }
{------------------------------------------------------------------------------}
procedure TCustomForm.SetPosition(Value : TPosition);
begin
  if Value <> FPosition then begin
    FPosition := Value;
    UpdateControlState;
  end;
end;

{------------------------------------------------------------------------------
       TCustomForm Constructor
------------------------------------------------------------------------------}
constructor TCustomForm.Create(AOwner : TComponent);
begin
  //writeln('[TCustomForm.Create] A Class=',Classname);
  try
    BeginFormUpdate;
    CreateNew(AOwner, 1);
    //writeln('[TCustomForm.Create] B Class=',Classname);
    if (ClassType <> TForm) and not (csDesigning in ComponentState) then
    begin
      Include(FFormState, fsCreating);
      try
        //writeln('[TCustomForm.Create] C Class=',Classname);
        if not InitResourceComponent(Self, TForm) then begin
          //writeln('[TCustomForm.Create] Resource '''+ClassName+''' not found');
          //Writeln('This is for information purposes only.   This is not critical at this time.');
          // MG:  Ignoring is best at the moment. (Delphi raises an exception.)
        end;
        //writeln('[TCustomForm.Create] D Class=',Classname);
        DoCreate;
        //writeln('[TCustomForm.Create] E Class=',Classname);
      finally
        Exclude(FFormState, fsCreating);
      end;
    end;
    EndFormUpdate;
  finally
  end;
  //writeln('[TCustomForm.Create] END Class=',Classname);
end;

{------------------------------------------------------------------------------
  constructor TCustomForm.CreateNew(AOwner: TComponent; Num : Integer);
------------------------------------------------------------------------------}
constructor TCustomForm.CreateNew(AOwner: TComponent; Num : Integer);
Begin
  //writeln('[TCustomForm.CreateNew] Class=',Classname);
  BeginFormUpdate;
  // set border style before handle is allocated
  if not (fsBorderStyleChanged in FFormState) then
    FBorderStyle:= bsSizeable;
  // set form style before handle is allocated
  if not (fsFormStyleChanged in FFormState) then
    FFormStyle:= fsNormal;

  inherited Create(AOwner);
  Visible := False;
  fCompStyle:= csForm;

  FMenu	:= nil;

  ControlStyle := ControlStyle + [csAcceptsControls, csCaptureMouse,
                                  csClickEvents, csSetCaption, csDoubleClicks];
  SetInitialBounds(0,0,320,240);
  ParentColor := False;
  ParentFont := False;
  Ctl3D := True;
  //  FBorderIcons := [biSystemMenu, biMinimize, biMaximize];
  FWindowState := wsNormal;
  //  FDefaultMonitor := dmActiveForm;
  FIcon := TIcon.Create;
  //  FInCMParentBiDiModeChanged := False;
  {apply a drawing surface}
  FKeyPreview :=  False;
  Color := clBtnFace;
  //  FPixelsPerInch := Screen.PixelsPerInch;
  //  FPrintScale := poProportional;
  //  FloatingDockSiteClass := TWinControlClass(ClassType);
  Screen.AddForm(Self);
  EndFormUpdate;
End;

{------------------------------------------------------------------------------
  TCustomForm CreateParams
------------------------------------------------------------------------------}
procedure TCustomForm.CreateParams(var Params : TCreateParams);
begin
  inherited CreateParams(Params);
  with Params do
  begin
    if (Parent = nil) {and (ParentWindow = 0)} then
    begin
//    WndParent := Application.Handle;
      { TODO : No application handle }
      Style := Style and not Cardinal(WS_CHILD or WS_GROUP or WS_TABSTOP);
    end;
  end;
end;


{------------------------------------------------------------------------------}
{       TCustomForm Method Close                                               }
{------------------------------------------------------------------------------}
Procedure TCustomForm.Close;
var
  CloseAction: TCloseAction;
begin
  if fsModal in FFormState then
    ModalResult := mrCancel
  else begin
    if CloseQuery then
    begin
      if FormStyle = fsMDIChild then begin
        //if biMinimize in BorderIcons then
        //  CloseAction := caMinimize
        //else
          CloseAction := caNone;
      end else begin
        CloseAction := caHide;
      end;
      DoClose(CloseAction);
      if CloseAction <> caNone then
        if Application.MainForm = Self then Application.Terminate
        else if CloseAction = caHide then Hide
        else if CloseAction = caMinimize then WindowState := wsMinimized
        else Release;
    end;
  end;
end;

{------------------------------------------------------------------------------
  procedure TCustomForm.Release;
------------------------------------------------------------------------------}
procedure TCustomForm.Release;
begin
  Free;
end;

{------------------------------------------------------------------------------
       TCustomForm Method CloseQuery
------------------------------------------------------------------------------}
function TCustomForm.CloseQuery: boolean;
//var i : integer;
begin
  { Query children forms whether we can close }
  if FormStyle = fsMDIForm then begin
  {  for i:= 0 to MDIChildCount - 1 do begin
      if not MDIChildren[i].CloseQuery then begin
        Result:= false;
	Exit;
       end;
    end;}
  end;
  Result := true;
  if Assigned(FOnCloseQuery) then FOnCloseQuery(Self, Result);
end;

{------------------------------------------------------------------------------}
{       TCustomForm Method WMCloseQuery                                        }
{------------------------------------------------------------------------------}
procedure TCustomForm.WMCloseQuery(var Message: TLMessage);
begin
  Close;
  { Always return 0, because we destroy the window ourselves }
  Message.Result:= 0;
end;

{------------------------------------------------------------------------------}
{       TCustomForm Method Hide                                                }
{------------------------------------------------------------------------------}
procedure TCustomForm.Hide;
begin
  If (fsModal in FormState) and (ModalResult=0) then
    ModalResult := mrCancel;
  Visible := False;
end;

{------------------------------------------------------------------------------
  procedure TCustomForm.Show;
------------------------------------------------------------------------------}
procedure TCustomForm.Show;
begin
  Visible:=true;
end;

{------------------------------------------------------------------------------
  procedure TCustomForm.ShowOnTop;
------------------------------------------------------------------------------}
procedure TCustomForm.ShowOnTop;
begin
  Show;
  BringToFront;
  //writeln('TCustomForm.ShowOnTop ',Name,':',ClassName,' ',Visible,' ',HandleAllocated,' ',csDesigning in ComponentState);
  LCLIntf.ShowWindow(Handle,SW_SHOWNORMAL);
end;

{------------------------------------------------------------------------------
       TCustomForm Method IsForm
------------------------------------------------------------------------------}
function TCustomForm.IsForm: Boolean;
begin
  //TODO:
  Result := True;
end;

{------------------------------------------------------------------------------
  function TCustomForm.IsHelpFileStored: boolean;
------------------------------------------------------------------------------}
function TCustomForm.IsHelpFileStored: boolean;
begin
  Result:=FHelpFile<>'';
end;

{------------------------------------------------------------------------------
  TCustomForm Method SetFocusedControl
------------------------------------------------------------------------------}
function TCustomForm.SetFocusedControl(Control: TWinControl): Boolean;
begin
  Result := False;
  
  if (csDestroying in Control.ComponentState) then exit;

  // update FActiveControl
  if FDesigner = nil then
    if Control <> Self then
      FActiveControl := Control
    else
      FActiveControl := nil;

  // update Screen object
  Screen.FActiveControl := Control;
  Screen.FActiveCustomForm := Self;
  Screen.MoveFormToFocusFront(Self);
  if Self is TForm then
    Screen.FActiveForm := TForm(Self)
  else
    Screen.FActiveForm := nil;

  {$IFDEF VerboseFocus}
  write('TCustomForm.SetFocusedControl Self=',Name,':',ClassName,' ');
  write(' Control=',Control.Name,':',Control.ClassName,' Control.HandleAllocated=',Control.HandleAllocated);
  writeln();
  {$ENDIF}

  Result:=true;

  if not (csFocusing in Control.ControlState) then begin
    // prevent looping
    Control.ControlState := Control.ControlState + [csFocusing];
    try
      // change focus
      
    finally
      Control.ControlState := Control.ControlState - [csFocusing];
    end;
  end;
  
  {
  Inc(FocusCount);

  // prevent looping
  if (csFocusing in Control.ControlState) then exit;
  Control.ControlState := Control.ControlState + [csFocusing];
  try

    if Screen.FFocusedForm <> Self then
    begin
      if Screen.FFocusedForm <> nil then
      begin
        FocusHandle := Screen.FFocusedForm.Handle;
        Screen.FFocusedForm := nil;
        if not SendFocusMessage(FocusHandle, CM_DEACTIVATE) then Exit;
      end;
      Screen.FFocusedForm := Self;
      if not SendFocusMessage(Handle, CM_ACTIVATE) then Exit;
    end;
    if FFocusedWinControl = nil then FFocusedWinControl := Self;
    if FFocusedWinControl <> Control then
    begin
      while (FFocusedWinControl <> nil) and not
        FFocusedWinControl.ContainsControl(Control) do
      begin
        FocusHandle := FFocusedWinControl.Handle;
        FFocusedWinControl := FFocusedWinControl.Parent;
        if not SendFocusMessage(FocusHandle, CM_EXIT) then Exit;
      end;
      while FFocusedControl <> Control do
      begin
        TempControl := Control;
        while TempControl.Parent <> FFocusedControl do
          TempControl := TempControl.Parent;
        FFocusedControl := TempControl;
        if not SendFocusMessage(TempControl.Handle, CM_ENTER) then Exit;
      end;
      TempControl := Control.Parent;
      while TempControl <> nil do
      begin
        if TempControl is TScrollingWinControl then
          TScrollingWinControl(TempControl).AutoScrollInView(Control);
        TempControl := TempControl.Parent;
      end;
      Perform(CM_FOCUSCHANGED, 0, LParam(Control));
      if (FActiveOleControl <> nil) and (FActiveOleControl <> Control) then
        FActiveOleControl.Perform(CM_UIDEACTIVATE, 0, 0);
    end;
  finally
    Control.ControlState := Control.ControlState - [csFocusing];
  end;
  Screen.UpdateLastActive;
  Result := True;
  }
end;

{------------------------------------------------------------------------------}
{       TCustomForm Method WantChildKey            }
{------------------------------------------------------------------------------}
function TCustomForm.WantChildKey(Child : TControl;
  var Message : TLMessage):Boolean;
begin
  Result := False;
end;

{------------------------------------------------------------------------------
  Method:  TCustomForm.CreateWnd
  Params:  None
  Returns: Nothing

  Creates the interface object.
 ------------------------------------------------------------------------------}
procedure TCustomForm.CreateWnd;
var
  DC: HDC;
begin
  //writeln('TCustomForm.CreateWnd START ',ClassName);
  FFormState:=FFormState-[fsBorderStyleChanged,fsFormStyleChanged];
  inherited CreateWnd;
  CNSendMessage(LM_SETFORMICON, Self, Pointer(GetIconHandle));
  DC:=GetDC(Handle);
  FPixelsPerInch:=GetDeviceCaps(DC,LOGPIXELSX);
  ReleaseDC(Handle,DC);

  Assert(False, 'Trace:[TCustomForm.CreateWnd] FMenu.HandleNeeded');
  if FMenu <> nil then
  begin
    FMenu.HandleNeeded;
    InterfaceObject.AttachMenuToWindow(FMenu);
  end;

  // activate focus if visible
  if Visible then begin
    if (FActiveControl<>nil) and FActiveControl.HandleAllocated
    and FActiveControl.Visible and FActiveControl.Enabled then begin
      {$IFDEF VerboseFocus}
      writeln('TCustomForm.CreateWnd A ',FActiveControl.Name,':',FActiveControl.ClassName);
      {$ENDIF}
      LCLIntf.SetFocus(FActiveControl.Handle);
    end;
  end;
  //writeln('TCustomForm.CreateWnd END ',ClassName);
end;

procedure TCustomForm.Loaded;
var
  Control: TWinControl;
begin
  inherited Loaded;
  if FMenu<>nil then
    FMenu.HandleNeeded;
  if ActiveControl <> nil then
  begin
    Control := ActiveControl;
    FActiveControl := nil;
    if Control.CanFocus then SetActiveControl(Control);
  end;
  //writeln('TCustomForm.Loaded ',Name,':',ClassName,' ',FormUpdating,' ',fsCreating in FFormState,' ',Visible,' ',fsVisible in FormState);
  if fsVisible in FormState then
    Visible:=true;
end;

procedure TCustomForm.InitializeWnd;
begin
  inherited InitializeWnd;
  if Parent<>nil then
    ParentFormInitializeWnd;
end;

{------------------------------------------------------------------------------
  procedure TCustomForm.BeginFormUpdate;
 ------------------------------------------------------------------------------}
procedure TCustomForm.BeginFormUpdate;
begin
  inc(FFormUpdateCount);
end;

{------------------------------------------------------------------------------
  Method:  TCustomForm.UpdateShowing
  Params:  None
  Returns: Nothing

  Here the initial form left and top are determined.
 ------------------------------------------------------------------------------}
procedure TCustomForm.UpdateShowing;
var
  X, Y : integer;
begin
  {$IFDEF CHECK_POSITION}
  writeln('[TCustomForm.UpdateShowing] A  Class=',Name,':',Classname,' Pos=',Left,',',Top,' Visible=',Visible);
  {$ENDIF}
  { If the the form is about to show, calculate its metrics }
  if Visible then begin
    // first make sure X and Y are assigned
    X := Left;
    Y := Top;

    if  (Position = poMainFormCenter)
    and (FormStyle = fsMDIChild)
    and (Self <> Application.Mainform)
    then begin
      X:= (Application.Mainform.ClientWidth - Width) div 2;
      Y:= (Application.Mainform.ClientHeight - Height) div 2;
    end
    else begin
      case Position of
      //TODO:poDefault, poDefaultPosOnly, poDefaultSizeOnly
      poScreenCenter, poDesktopCenter :
        begin
          X:= (Screen.Width - Width) div 2;
          Y:= (Screen.Height - Height) div 2;
        end;
      poMainFormCenter :
        if (Self <> Application.MainForm) then begin
          X:= ((Application.MainForm.Width - Width) div 2) + Application.MainForm.Left;
          Y:= ((Application.MainForm.Height - Height) div 2) + Application.MainForm.Top;
        end;
      poOwnerFormCenter :
        if (Owner is TCustomForm) then begin
          X:= ((TCustomForm(Owner).Width - Width) div 2) + TCustomForm(Owner).Left;
          Y:= ((TCustomForm(Owner).Height - Height) div 2) + TCustomForm(Owner).Top;
        end;
      end;
    end;
    if X < 0 then X := 0;
    if Y < 0 then Y := 0;
    SetBounds(X, Y, Width, Height);
  end;
  {$IFDEF CHECK_POSITION}
  writeln('[TCustomForm.UpdateShowing] B  ',Name,':',Classname,' Pos=',Left,',',Top);
  {$ENDIF}
  inherited UpdateShowing;
  {$IFDEF CHECK_POSITION}
  writeln('[TCustomForm.UpdateShowing] END  ',Name,':',Classname,' Pos=',Left,',',Top);
  {$ENDIF}
end;

{------------------------------------------------------------------------------}
{  TCustomForm ShowModal                                                       }
{------------------------------------------------------------------------------}
Function TCustomForm.ShowModal: Integer;

  procedure RaiseShowModalImpossible;
  begin
    writeln('TCustomForm.ShowModal Visible=',Visible,' Enabled=',Enabled,
      ' fsModal=',fsModal in FFormState,' MDIChild=',FormStyle = fsMDIChild);
    raise EInvalidOperation.Create('TCustomForm.ShowModal impossible ');
  end;

var
  //WindowList: Pointer;
  SaveFocusCount: Integer;
  //SaveCursor: TCursor;
  //SaveCount: Integer;
  ActiveWindow: HWnd;
begin
  if Self=nil then raise
    EInvalidOperation.Create('TCustomForm.ShowModal Self=nil');
  if Application.Terminated then
    ModalResult:=0;
  // cancel drags
  CancelDrag;
  // close popupmenus
  if ActivePopupMenu<>nil then ActivePopupMenu.Close;
  //writeln('[TCustomForm.ShowModal] START ',Classname);
  if Visible or not Enabled or (fsModal in FFormState)
  or (FormStyle = fsMDIChild) then
    RaiseShowModalImpossible;
  // Kill capture when opening another dialog
  if GetCapture <> 0 then SendMessage(GetCapture,LM_CANCELMODE,0,0);
  ReleaseCapture;

  Include(FFormState, fsModal);
  ActiveWindow := GetActiveWindow;
  SaveFocusCount := FocusCount;
  Screen.FSaveFocusedList.Insert(0, Screen.FFocusedForm);
  Screen.FFocusedForm := Self;
  //SaveCursor := Screen.Cursor;
  //Screen.Cursor := crDefault;
  //SaveCount := Screen.FCursorCount;
  //WindowList := DisableTaskWindows(0);
  ModalResult := 0;

  try
    Show;
    try
      CNSendMessage(LM_SHOWMODAL, Self, nil);
      repeat
        { Delphi calls Application.HandleMessage
          But HandleMessage processes all pending events and then calls idle,
          which will wait for new messages. Under Win32 there is always a next
          message, so it works there. The LCL is OS independent, and so it uses
          a better way: }
        InterfaceObject.HandleEvents; // process all events
        if Application.Terminated then
          ModalResult := mrCancel;
        if ModalResult <> 0 then begin
          CloseModal;
          if ModalResult<>0 then break;
        end;
        Application.Idle;
      until false;

      Result := ModalResult;
      if HandleAllocated and (GetActiveWindow <> Handle) then
        ActiveWindow := 0;
    finally
      Hide;
    end;
  finally
    {if Screen.FCursorCount = SaveCount then
      Screen.Cursor := SaveCursor
    else
      Screen.Cursor := crDefault;
    EnableTaskWindows(WindowList);}
    if Screen.FSaveFocusedList.Count > 0 then
    begin
      Screen.FFocusedForm := TCustomForm(Screen.FSaveFocusedList.First);
      Screen.FSaveFocusedList.Remove(Screen.FFocusedForm);
    end else
      Screen.FFocusedForm := nil;
    if ActiveWindow <> 0 then SetActiveWindow(ActiveWindow);
    FocusCount := SaveFocusCount;
    Exclude(FFormState, fsModal);
  end;
end;

{ =============================================================================

  $Log$
  Revision 1.134  2004/04/23 11:18:28  mattias
  fixed unsetting csFocusing

  Revision 1.133  2004/04/10 17:58:57  mattias
  implemented mainunit hints for include files

  Revision 1.132  2004/03/30 19:08:29  mattias
  test for destroying controls, so they do not get focus

  Revision 1.131  2004/03/08 22:36:01  mattias
  added TWinControl.ParentFormInitializeWnd

  Revision 1.130  2004/03/06 14:39:50  micha
  although loading, attach menu to form if handle already created, if this is not wanted, then prevent creation of handle somehow
  fixes bug #197

  Revision 1.129  2004/02/28 00:34:35  mattias
  fixed CreateComponent for buttons, implemented basic Drag And Drop

  Revision 1.128  2004/02/23 08:19:04  micha
  revert intf split

  Revision 1.126  2004/02/10 02:00:13  mattias
  activated Idle actions

  Revision 1.125  2004/02/02 17:39:10  mattias
  added TActionList - actions need testing

  Revision 1.124  2004/02/02 16:59:28  mattias
  more Actions  TAction, TBasicAction, ...

  Revision 1.123  2003/12/29 14:22:22  micha
  fix a lot of range check errors win32

  Revision 1.122  2003/12/23 16:50:45  micha
  fix defocus control when destroying it

  Revision 1.121  2003/12/18 08:50:13  micha
  attachmenutowindow cleanup

  Revision 1.120  2003/12/18 08:15:25  micha
  setmenu fix, now correctly (sigh)

  Revision 1.119  2003/12/18 08:00:37  micha
  setmenu fix, notify interface (from darek)

  Revision 1.118  2003/11/23 00:28:51  mattias
  fixed closing IDE while debugging

  Revision 1.117  2003/11/17 23:09:39  mattias
  started PixelsPerInch

  Revision 1.116  2003/10/07 14:54:59  mattias
  moved some lazarus resource code to LResources.pp

  Revision 1.115  2003/09/18 09:21:03  mattias
  renamed LCLLinux to LCLIntf

  Revision 1.114  2003/09/13 10:04:35  mattias
  fixed ColorIsStored

  Revision 1.113  2003/09/06 18:38:06  mattias
  fixed recreating handle after showmodal

  Revision 1.112  2003/08/31 17:30:49  mattias
  fixed TControl painting for win32

  Revision 1.111  2003/08/28 12:08:30  mattias
  fixed register color prop edit

  Revision 1.110  2003/08/27 09:20:44  mattias
  added TFrame definition, no implementation

  Revision 1.109  2003/08/12 21:35:11  mattias
  TApplication now descends from TCustomApplication

  Revision 1.108  2003/07/01 13:49:36  mattias
  clean up

  Revision 1.107  2003/06/30 07:00:18  mattias
  activated EraseBckGrd messages in doublebuffer WMPaint section

  Revision 1.106  2003/06/23 09:42:09  mattias
  fixes for debugging lazarus

  Revision 1.105  2003/06/16 23:12:59  mattias
  fixed TCustomForm.ShowModal when Self=nil

  Revision 1.104  2003/06/16 22:47:19  mattias
  fixed keeping TForm.Visible=false

  Revision 1.103  2003/06/13 14:38:01  mattias
  fixed using streamed clientwith/height for child anchors

  Revision 1.102  2003/06/13 06:05:49  mattias
  started context diff

  Revision 1.101  2003/06/10 00:46:16  mattias
  fixed aligning controls

  Revision 1.100  2003/06/01 21:09:09  mattias
  implemented datamodules

  Revision 1.99  2003/05/24 08:51:41  mattias
  implemented designer close query

  Revision 1.98  2003/05/12 13:40:50  mattias
  fixed clsing popupmenu on showmodal

  Revision 1.97  2003/04/20 16:32:58  mattias
  published keypreview

  Revision 1.96  2003/04/16 22:11:35  mattias
  fixed codetools Makefile, fixed default prop not found error

  Revision 1.95  2003/04/16 17:20:24  mattias
  implemented package check broken dependency on compile

  Revision 1.94  2003/04/11 21:21:34  mattias
  implemented closing unneeded package

  Revision 1.93  2003/04/11 09:32:20  mattias
  added some help stuff

  Revision 1.92  2003/03/25 10:45:40  mattias
  reduced focus handling and improved focus setting

  Revision 1.91  2003/03/18 13:04:25  mattias
  improved focus debugging output

  Revision 1.90  2003/03/17 13:54:34  mattias
  fixed setting activecontrol after createwnd

  Revision 1.89  2003/03/13 10:11:41  mattias
  fixed TControl.Show in design mode

  Revision 1.88  2003/03/11 22:56:41  mattias
  added visiblechanging

  Revision 1.87  2003/03/11 07:46:43  mattias
  more localization for gtk- and win32-interface and lcl

  Revision 1.86  2003/02/28 19:54:05  mattias
  added ShowWindow

  Revision 1.85  2003/02/04 11:44:13  mattias
  fixed modified and loading xpms for button glyphs

  Revision 1.84  2003/01/06 12:00:16  mattias
  implemented fsStayOnTop+bsNone for forms under gtk (useful for splash)

  Revision 1.83  2003/01/04 12:06:53  mattias
  fixed TCustomform.BringToFront

  Revision 1.82  2002/12/29 11:10:45  mattias
  fixed form FActive, cleanups

  Revision 1.81  2002/12/28 21:06:37  mattias
  fixed TCustomForm.WMCloseQuery

  Revision 1.80  2002/12/28 12:42:38  mattias
  focus fixes, reduced lpi size

  Revision 1.79  2002/12/28 11:29:47  mattias
  xmlcfg deletion, focus fixes

  Revision 1.78  2002/12/25 14:21:28  mattias
  fixed setting activecontrol to nil when removing component

  Revision 1.77  2002/12/25 11:53:47  mattias
  Button.Default now sets focus

  Revision 1.76  2002/12/25 10:21:05  mattias
  made Form.Close more Delphish, added some windows compatibility functions

  Revision 1.75  2002/12/03 17:40:37  mattias
  fixed deleting lookup form when form is deleted

  Revision 1.74  2002/11/30 11:24:05  mattias
  removed unused TCustomForm.WMDestroy

  Revision 1.73  2002/11/30 08:35:42  mattias
  TCustomForm.WMDestroy does not Free anymore

  Revision 1.72  2002/11/29 15:14:47  mattias
  replaced many invalidates by invalidaterect

  Revision 1.71  2002/11/12 16:18:46  lazarus
  MG fixed hidden component page

  Revision 1.70  2002/11/09 18:13:33  lazarus
  MG: fixed gdkwindow checks

  Revision 1.69  2002/11/06 17:46:36  lazarus
  MG: reduced showing forms during creation

  Revision 1.68  2002/10/28 18:17:02  lazarus
  MG: impoved focussing, unfocussing on destroy and fixed unit search

  Revision 1.67  2002/10/27 15:46:58  lazarus
  MWE:
    * Moved call to BeforeDestruction to CustomForm
    - Removed form.inc

  Revision 1.66  2002/10/27 11:51:35  lazarus
  MG: fixed memleaks

  Revision 1.65  2002/10/24 09:37:39  lazarus
  MG: broke menus.pp <-> controls.pp circle

  Revision 1.64  2002/10/23 20:47:26  lazarus
  AJ: Started Form Scrolling
      Started StaticText FocusControl
      Fixed Misc Dialog Problems
      Added TApplication.Title

  Revision 1.63  2002/10/22 18:54:56  lazarus
  MG: fixed menu streaming

  Revision 1.62  2002/10/22 13:01:20  lazarus
  MG: fixed setting modalresult on hide

  Revision 1.61  2002/10/06 17:55:45  lazarus
  MG: JITForms now sets csDesigning before creation

  Revision 1.60  2002/09/29 15:08:38  lazarus
  MWE: Applied patch from "Andrew Johnson" <aj_genius@hotmail.com>
    Patch includes:
      -fixes Problems with hiding modal forms
      -temporarily fixes TCustomForm.BorderStyle in bsNone
      -temporarily fixes problems with improper tabbing in TSynEdit

  Revision 1.59  2002/09/16 16:18:50  lazarus
  MG: fixed mem leak in TPixmap

  Revision 1.58  2002/09/09 14:01:05  lazarus
  MG: improved TScreen and ShowModal

  Revision 1.57  2002/09/09 06:27:06  lazarus

  Form deactivation fixes.

  Revision 1.56  2002/09/03 20:02:01  lazarus
  Intermediate UI patch to show a bug.

  Revision 1.55  2002/09/03 11:32:49  lazarus

  Added shortcut keys to labels
  Support for alphabetically sorting the properties
  Standardize message and add shortcuts ala Kylix
  Published BorderStyle, unpublished BorderWidth
  ShowAccelChar and FocusControl
  ShowAccelChar and FocusControl for TLabel, escaped ampersands now work.

  Revision 1.54  2002/09/03 08:07:19  lazarus
  MG: image support, TScrollBox, and many other things from Andrew

  Revision 1.53  2002/08/31 11:37:09  lazarus
  MG: fixed destroying combobox

  Revision 1.52  2002/08/30 12:32:20  lazarus
  MG: MoveWindowOrgEx, Splitted FWinControls/FControls, TControl drawing, Better DesignerDrawing, ...

  Revision 1.51  2002/08/24 12:54:59  lazarus
  MG: fixed mouse capturing, OI edit focus

  Revision 1.50  2002/08/17 15:45:32  lazarus
  MG: removed ClientRectBugfix defines

  Revision 1.49  2002/07/05 09:09:20  lazarus
  MG: fixed TCustomForm.ShowModal reacting to ModalResult

  Revision 1.48  2002/06/19 19:46:09  lazarus
  MG: Form Editing: snapping, guidelines, modified on move/resize, creating components in csDesigning, ...

  Revision 1.47  2002/05/30 21:17:27  lazarus
  lcl/controls.pp

  Revision 1.46  2002/05/15 05:58:17  lazarus
  MG: added TMainMenu.Parent

  Revision 1.45  2002/05/13 15:26:13  lazarus
  MG: fixed form positioning when show, hide, show

  Revision 1.44  2002/05/10 06:05:51  lazarus
  MG: changed license to LGPL

  Revision 1.43  2002/05/09 12:41:28  lazarus
  MG: further clientrect bugfixes

  Revision 1.42  2002/04/27 18:56:50  lazarus
  MG: started component renaming

  Revision 1.41  2002/04/27 15:35:50  lazarus
  MG: fixed window shrinking

  Revision 1.40  2002/04/26 15:31:06  lazarus
  MG: made ShowModal more dlephi compatible

  Revision 1.39  2002/04/26 12:26:50  lazarus
  MG: improved clean up

  Revision 1.38  2002/03/25 17:59:20  lazarus
  GTK Cleanup
  Shane

  Revision 1.37  2002/03/18 11:44:41  lazarus
  MG: TForm.Position will now considered before creating form on 0,0

  Revision 1.36  2002/03/16 21:40:55  lazarus
  MG: reduced size+move messages between lcl and interface

  Revision 1.35  2002/03/13 22:48:16  lazarus
  Constraints implementation (first cut) and sizig - moving system rework to
  better match Delphi/Kylix way of doing things (the existing implementation
  worked by acident IMHO :-)

  Revision 1.34  2002/01/01 15:50:14  lazarus
  MG: fixed initial component aligning

  Revision 1.33  2001/12/28 15:12:02  lazarus
  MG: LM_SIZE and LM_MOVE messages are now send directly, not queued

  Revision 1.32  2001/12/20 14:41:20  lazarus
  Fixed setfocus for TComboBox and TMemo
  Shane

  Revision 1.31  2001/12/19 10:59:12  lazarus
  MG: changes for fpc 1.1

  Revision 1.30  2001/11/10 10:48:00  lazarus
  MG: fixed set formicon on invisible forms

  Revision 1.29  2001/10/16 20:01:28  lazarus
  MG: removed splashform fix, because of the unpredictable side effects

  Revision 1.28  2001/10/10 17:55:04  lazarus
  MG: fixed caret lost, gtk cleanup, bracket lvls, bookmark saving

  Revision 1.27  2001/10/07 07:28:33  lazarus
  MG: fixed setpixel and TCustomForm.OnResize event

  Revision 1.26  2001/10/03 17:34:26  lazarus
  MG: activated TCustomForm.OnCreate event

  Revision 1.24  2001/07/10 13:25:49  lazarus
  MG: repaints reduced

  Revision 1.22  2001/06/28 18:15:03  lazarus
  MG: bugfixes for destroying controls

  Revision 1.21  2001/06/26 00:08:35  lazarus
  MG: added code for form icons from Rene E. Beszon

  Revision 1.20  2001/06/14 14:57:58  lazarus
  MG: small bugfixes and less notes

  Revision 1.19  2001/05/31 13:57:28  lazarus
  MG: added environment option OpenLastProjectAtStart

  Revision 1.18  2001/03/31 13:35:23  lazarus
  MG: added non-visual-component code to IDE and LCL

  Revision 1.17  2001/03/26 14:58:31  lazarus
  MG: setwindowpos + bugfixes

  Revision 1.15  2001/03/19 14:41:56  lazarus
  MG: fixed many unreleased DC and GDIObj bugs

  Revision 1.13  2001/02/28 13:17:33  lazarus
  Added some debug code for the top,left reporting problem.
  Shane

  Revision 1.12  2001/02/06 20:59:17  lazarus
  Trying to get the last control of the last form focused when a dialog closes.
  Still working on it.
  Shane

  Revision 1.11  2001/02/02 20:13:39  lazarus
  Codecompletion changes.
  Added code to Uniteditor for code completion.

  Also, added code to gtkobject.inc so forms now get keypress events.
  Shane

  Revision 1.10  2001/02/01 16:45:20  lazarus
  Started the code completion.
  Shane

  Revision 1.9  2001/01/12 18:46:50  lazarus
  Named the speedbuttons in MAINIDE and took out some writelns.
  Shane

  Revision 1.8  2001/01/03 18:44:54  lazarus
  The Speedbutton now has a numglyphs setting.
  I started the TStringPropertyEditor

  Revision 1.7  2000/12/19 18:43:13  lazarus
  Removed IDEEDITOR.  This causes the PROJECT class to not function.
  Saving projects no longer works.

  I added TSourceNotebook and TSourceEditor.  They do all the work for saving/closing/opening units.  Somethings work but they are in early development.
  Shane

  Revision 1.6  2000/11/30 21:43:38  lazarus
  Changed TDesigner.  It's now notified when a control is added to it's CustomForm.
  It's created in main.pp when New Form is selected.

  Shane

  Revision 1.5  2000/11/21 17:33:37  lazarus
  Added TCustomForm.Notification so the TDesigner is notified of actions.

  Added more code for getting info via RTTI
  Shane

  Revision 1.4  2000/08/14 12:31:12  lazarus
  Minor modifications for SynEdit .
  Shane

  Revision 1.3  2000/08/09 14:15:04  lazarus
  Changed the TCUstomForm create function.  I am getting it ready to read the resources to auto-create the controls...

  Anslo changes TScreen.AddForm and TScreen.RemoveForm.  They were being passed TFOrm's instead of TCustomForms.
  Shane

  Revision 1.2  2000/07/23 19:01:33  lazarus
  menus will be destroyed now, stoppok

  Revision 1.1  2000/07/13 10:28:25  michael
  + Initial import

}
