<?xml version="1.0"?>
<fpdoc-descriptions>
  <package name="LCL">
    <!--
  ====================================================================
    Controls
  ====================================================================
-->
    <module name="Controls">
      <short>This unit contains basic classes for visual controls.</short>
      <descr/>
      <!-- unresolved type reference Visibility: default -->
      <element name="Classes">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="SysUtils">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="TypInfo">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="LCLStrConsts">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="LCLType">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="LCLProc">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="GraphType">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="Graphics">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="LMessages">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="LCLIntf">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="InterfaceBase">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="ImgList">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="PropertyStorage">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="Menus">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="ActnList">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="LCLClasses">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="mrNone">
        <short>Modal dialog left with None button.</short>
      </element>
      <!-- constant Visibility: default -->
      <element name="mrOK">
        <short>Modal dialog left with OK button.</short>
      </element>
      <!-- constant Visibility: default -->
      <element name="mrCancel">
        <short>Modal dialog left with Cancel button.</short>
      </element>
      <!-- constant Visibility: default -->
      <element name="mrAbort">
        <short>Modal dialog aborted.</short>
      </element>
      <!-- constant Visibility: default -->
      <element name="mrRetry">
        <short>Modal dialog left with Retry button.</short>
      </element>
      <!-- constant Visibility: default -->
      <element name="mrIgnore">
        <short>Modal dialog left with Ignore button.</short>
      </element>
      <!-- constant Visibility: default -->
      <element name="mrYes">
        <short>Modal dialog left with Yes button.</short>
      </element>
      <!-- constant Visibility: default -->
      <element name="mrNo">
        <short>Modal dialog left with No button.</short>
      </element>
      <!-- constant Visibility: default -->
      <element name="mrAll">
        <short>Modal dialog left with All button.</short>
      </element>
      <!-- constant Visibility: default -->
      <element name="mrNoToAll">
        <short>Modal dialog left with NoToAll button.</short>
      </element>
      <!-- constant Visibility: default -->
      <element name="mrYesToAll">
        <short>Modal dialog left with YesToAll button.</short>
      </element>
      <!-- constant Visibility: default -->
      <element name="mrClose">
        <short>Modal dialog left with Close button.</short>
      </element>
      <!-- constant Visibility: default -->
      <element name="mrLast">
        <short>Last (highest) value of modal results.</short>
      </element>
      <!-- "class of" type Visibility: default -->
      <element name="TWinControlClass">
        <short>
          <var>TWinControlClass</var> - class of <var>TWinControl</var>
        </short>
        <descr/>
        <seealso/>
      </element>
      <!-- "class of" type Visibility: default -->
      <element name="TControlClass">
        <short>
          <var>TControlClass</var> - class of <var>TControl</var>
        </short>
        <descr/>
        <seealso/>
      </element>
      <!-- "type" alias type Visibility: default -->
      <element name="TDate">
        <short>Date expressed in the encoded <link id="TDateTime"/> type.</short>
        <descr>Variables of this type contain both date and time, but only one of these should be used.
        </descr>
      </element>
      <!-- "type" alias type Visibility: default -->
      <element name="TTime" link="TDate">
        <short>Time of day expressed in the encoded encoded <link id="TDateTime"/> type</short>
      </element>
      <!-- record type Visibility: default -->
      <element name="TCMMouseWheel">
        <short>Parameters of a CMMouseWheel message.</short>
        <descr>
          <pre>Details held include:
          the Message associated with the wheel;
          the shift state (ie whether Shift, Alt, Control etc keys have been pressed);
          wheel data which can either be 
	  a position (X, Y coordinates) or 
	  a position plus an integer result.</pre>
        </descr>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMMouseWheel.MSg">
        <short>The exact Message ID.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMMouseWheel.ShiftState">
        <short>State of modifier keys and mouse buttons.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMMouseWheel.Unused">
        <short>inserted for alignment only.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCMMouseWheel.Pos">
        <short>Mouse[?] position.</short>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMMouseWheel.WheelData">
        <short>How many notches the wheel has turned.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- alias type Visibility: default -->
      <element name="TCMHitTest" link="TLMNCHitTest"/>
      <element name="TCMDesignHitTest" link="TLMMouse"/>
      <!-- record type Visibility: default -->
      <element name="TCMControlChange">
        <short>[?]</short>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMControlChange.Msg">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMControlChange.Control">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMControlChange.Inserting">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMControlChange.Result">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- record type Visibility: default -->
      <element name="TCMControlListChange">
      <short></short>
      <descr>
      </descr>
      <seealso>
      </seealso>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMControlListChange.Msg">
      <short></short>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMControlListChange.Control">
      <short></short>
      <descr>
      </descr>
      <seealso>
      </seealso>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMControlListChange.Inserting">
      <short></short>
      <descr>
      </descr>
      <seealso>
      </seealso>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMControlListChange.Result">
      <short></short>
      <descr>
      </descr>
      <seealso>
      </seealso>
      </element>
      <!-- alias type Visibility: default -->
      <element name="TCMDialogChar" link="TLMKey">
        <short>[?]</short>
      </element>
      <!-- alias type Visibility: default -->
      <element name="TCMDialogKey" link="TLMKey">
        <short>[?]</short>
      </element>
      <!-- alias type Visibility: default -->
      <element name="TCMEnter" link="TLMEnter">
        <short>[?]</short>
      </element>
      <!-- alias type Visibility: default -->
      <element name="TCMExit" link="TLMExit">
        <short>[?]</short>
      </element>
      <!-- record type Visibility: default -->
      <element name="TCMCancelMode">
        <short>[?]</short>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMCancelMode.Msg">
      <short></short>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMCancelMode.Unused">
        <short></short>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMCancelMode.Sender">
        <short></short>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMCancelMode.Result">
        <short></short>
      </element>
      <!-- record type Visibility: default -->
      <element name="TCMChildKey">
        <short>[?]</short>
        <descr>
        </descr>
        <seealso>
        </seealso>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMChildKey.Msg">
        <short></short>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMChildKey.Unused">
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMChildKey.CharCode">
        <short>VK_XXX constants for TLMKeyDown/Up, ASCII for TLMChar.</short>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMChildKey.Sender">
        <short></short>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMChildKey.Result">
        <short></short>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TAlign">
        <short>Alignment options for a control, within its Parent control.</short>
        <descr>
          <p>A control can be aligned as:</p>
          <dl>
            <dt>alNone</dt>
            <dd>fixed position and extent</dd>
            <dt>alTop</dt>
            <dd>stacked at top, full width</dd>
            <dt>alBottom</dt>
            <dd>stacked at bottom, full width</dd>
            <dt>alLeft</dt>
            <dd>stacked at left, full height</dd>
            <dt>alRight</dt>
            <dd>stacked at right, full height</dd>
            <dt>alClient</dt>
            <dd>filling entire remaining client area</dd>
            <dt>alCustom</dt>
            <dd>other alignment, in drag-dock: notebook</dd>
          </dl>
          <p>At most one control can have alClient alignment.</p>
          <p>The order of multiple controls of the same (stackable) alignment is determined by their Left or Top coordinate.</p>
          <p>The precedence of conflicting alignment requests (e.g. one at top, one at right) is resolved [how???]</p>
          <p>[which provisions exist for alCustom implementation?]</p>
        </descr>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TAlign.alNone">
        <short>Control has fixed size and position</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TAlign.alTop">
        <short>Control stacked at top, full width.</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TAlign.alBottom">
        <short>Control stacked at bottom, full width.</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TAlign.alLeft">
        <short>Control stacked at left, full height.</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TAlign.alRight">
        <short>Control stacked at right, full height.</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TAlign.alClient">
        <short>Control fills remaining client area.</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TAlign.alCustom">
        <short>Control has special alignment.</short>
        <descr>[aligned how?]</descr>
      </element>
      <!-- set type Visibility: default -->
      <element name="TAlignSet" link="TAlign">
        <short>Set of alignment options.</short>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TAnchorKind">
        <short>The control side to be anchored.</short>
        <descr>With asrCenter the sides mean horizontal or vertical alignment, of the control's center.
        </descr>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TAnchorKind.akTop">
        <short>Top side (or center vertically).</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TAnchorKind.akLeft">
        <short>Left side (or center horizonally).</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TAnchorKind.akRight">
        <short>Right side (or center horizontally).</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TAnchorKind.akBottom">
        <short>Bottom side (or center vertically).</short>
      </element>
      <!-- set type Visibility: default -->
      <element name="TAnchors">
        <short>Set of possible anchor positions</short>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TAnchorSideReference">
        <short>The side of another control, to which this control's side is anchored.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TAnchorSideReference.asrTop">
        <short>Anchor to the top side.</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TAnchorSideReference.asrBottom">
        <short>Anchor to the bottom side.</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TAnchorSideReference.asrCenter">
        <short>Anchor to the center of the other control.</short>
      </element>
      <!-- constant Visibility: default -->
      <element name="asrLeft">
        <short>Anchor to the left side.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="asrRight">
        <short>Anchor to the right side.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- "type" alias type Visibility: default -->
      <element name="TTranslateString">
        <short>[?]</short>
        <descr/>
        <seealso/>
      </element>
      <!-- alias type Visibility: default -->
      <element name="TCaption">
        <short>A string type for the caption of a control: may be translated</short>
      </element>
      <!-- range type Visibility: default -->
      <element name="TCursor">
        <short>
          <var>TCursor</var> - integer type defining range of values for cursor</short>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TFormStyle">
        <short>Defines special form behaviour.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TFormStyle.fsNormal">
        <short>An ordinary (overlapping) form.</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TFormStyle.fsMDIChild">
        <short>The form is an MDI child.</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TFormStyle.fsMDIForm">
        <short>The form is an MDI parent form, containing MDI child forms.</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TFormStyle.fsStayOnTop">
        <short>The form is in the foreground, on top of all other application forms.</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TFormStyle.fsSplash">
        <short>A splash form [meaning what?].</short>
      </element>
      <element name="TFormStyle.fsSystemStayOnTop">
        <short>The form stays system-wide on top[?].</short>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TFormBorderStyle">
        <short>Style of a form's border.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TFormBorderStyle.bsNone">
        <short>No border at all.</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TFormBorderStyle.bsSingle">
        <short>Single line border, the form cannot be resized.</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TFormBorderStyle.bsSizeable">
        <short>The form can be resized (standard).</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TFormBorderStyle.bsDialog">
        <short>[legacy?] The form is a dialog, cannot be resized.</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TFormBorderStyle.bsToolWindow">
        <short>Single line border, small caption, not resizeable.</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TFormBorderStyle.bsSizeToolWin">
        <short>Small caption, form can be resized.</short>
      </element>
      <!-- range type Visibility: default -->
      <element name="TBorderStyle">
        <short>Possible types of borders (with or without border).</short>
        <seealso>[used where?]</seealso>
      </element>
      <!-- alias type Visibility: default -->
      <element name="TControlBorderStyle">
        <short>Possible types of control borders (with or without border).</short>
        <descr>A subset of TFormBorderStyle, listing only the styles available to a control that is not a form.</descr>
        <seealso>[used where?]</seealso>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TControlRoleForForm">
        <short>Possible default actions on special keys.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlRoleForForm.crffDefault">
        <short>This control is notified when user presses Return.</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlRoleForForm.crffCancel">
        <short>This control is notified when user presses Escape.</short>
      </element>
      <!-- set type Visibility: default -->
      <element name="TControlRolesForForm" link="TControlRoleForForm"/>
      <!-- alias type Visibility: default -->
      <element name="TBevelCut" link="TGraphicsBevelCut"/>
      <!-- enumeration type Visibility: default -->
      <element name="TMouseButton">
        <short>Enumeration of recognized mouse buttons.</short>
        <descr>
          <p>These are <b>logical</b> buttons, left and right physical buttons can be swapped for left handed users.</p>
          <p>[Nowadays mice with more buttons are available - how are these handled?]</p>
        </descr>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TMouseButton.mbLeft">
        <short>Left button (can be physical right button for left handed).</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TMouseButton.mbRight">
        <short>Right button (can be physical left button for left handed).</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TMouseButton.mbMiddle">
        <short>Middle button.</short>
      </element>
      <element name="TMouseButton.mbExtra1">
        <short>First extra button.</short>
      </element>
      <element name="TMouseButton.mbExtra2">
        <short>Second extra button.</short>
      </element>
      <!-- constant Visibility: default -->
      <element name="fsAllStayOnTop">
        <short>Set of form styles, which make a form stay on top.</short>
        <descr/>
        <seealso><link id="TFormStyle"/></seealso>
      </element>
      <!-- constant Visibility: default -->
      <element name="fsAllNonSystemStayOnTop">
        <short>Set of form styles, which make a form stay on top system-wide[?].</short>
        <seealso><link id="TFormStyle"/></seealso>
      </element>
      <!-- constant Visibility: default -->
      <element name="crHigh">
        <short>Highest defined cursor constant (0).</short>
      </element>
      <!-- constant Visibility: default -->
      <element name="crDefault">
        <short>Default (parent) cursor constant (0)</short>
      </element>
      <!-- constant Visibility: default -->
      <element name="crNone">
        <short>Invisible cursor constant: no cursor (-1)</short>
      </element>
      <!-- constant Visibility: default -->
      <element name="crArrow">
        <short>Arrow cursor constant (-2)</short>
      </element>
      <!-- constant Visibility: default -->
      <element name="crCross">
        <short>Cross cursor constant (-3)</short>
      </element>
      <!-- constant Visibility: default -->
      <element name="crIBeam">
        <short>I-Beam cursor constant, often used in text editors (-4)</short>
      </element>
      <!-- constant Visibility: default -->
      <element name="crSize">
        <short>Sizing cursor constant (-22), alias for crSizeAll.</short>
      </element>
      <!-- constant Visibility: default -->
      <element name="crSizeNESW">
        <short>crSizeNESW - cursor constant: runs diagonally from NorthEast to SouthWest (-6)</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="crSizeNS">
        <short>crSizeNS - cursor constant: cursor runs from North to South (-7)</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="crSizeNWSE">
        <short>crNWSE - cursor constant: cursor runs from NorthWest to SouthEast</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="crSizeWE">
        <short>Horizontal Size cursor constant (-9)</short>
      </element>
      <!-- constant Visibility: default -->
      <element name="crSizeNW">
        <short>NorthWest sizing cursor.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="crSizeN">
        <short>crSizeN - cursor constant: cursor North (-24)</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="crSizeNE">
        <short>crSizeNW - cursor constant: NorthWest (-23)</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="crSizeW">
        <short>West (left) sizing cursor.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="crSizeE">
        <short>East (right) sizing cursor.</short>
      </element>
      <!-- constant Visibility: default -->
      <element name="crSizeSW">
        <short>SouthWest sizing cursor.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="crSizeS">
        <short>South (bottom) sizing cursor.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="crSizeSE">
        <short>SouthEast sizing cursor.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="crUpArrow">
        <short>Up Arrow cursor constant (-10)</short>
      </element>
      <!-- constant Visibility: default -->
      <element name="crHourGlass">
        <short>Busy cursor constant (wait while action proceeds) (-11)</short>
      </element>
      <!-- constant Visibility: default -->
      <element name="crDrag">
        <short>Dragging cursor constant (-12)</short>
      </element>
      <!-- constant Visibility: default -->
      <element name="crNoDrop">
        <short>No Drop Allowed dragging cursor constant (-13)</short>
      </element>
      <!-- constant Visibility: default -->
      <element name="crHSplit">
        <short>Horizontal Splitter cursor constant (-14)</short>
      </element>
      <!-- constant Visibility: default -->
      <element name="crVSplit">
        <short>Vertical Split cursor constant (-15)</short>
      </element>
      <!-- constant Visibility: default -->
      <element name="crMultiDrag">
        <short>Multiple Object dragging cursor constant (-16)</short>
      </element>
      <!-- constant Visibility: default -->
      <element name="crSQLWait">
        <short>Waiting for SQL cursor constant (-17)</short>
      </element>
      <!-- constant Visibility: default -->
      <element name="crNo">
        <short>"No" cursor constant (-18), see also <link id="crNoDrop"/>.
        </short>
      </element>
      <!-- constant Visibility: default -->
      <element name="crAppStart">
        <short>Application starting[?] cursor.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="crHelp">
        <short>"What's This" Help cursor constant (-20)</short>
      </element>
      <!-- constant Visibility: default -->
      <element name="crHandPoint">
        <short>Pointing hand cursor constant (-21)</short>
      </element>
      <!-- constant Visibility: default -->
      <element name="crSizeAll">
        <short>All Directions sizing cursor constant (-22)</short>
      </element>
      <!-- constant Visibility: default -->
      <element name="crLow">
        <short>Lowest defined cursor constant (-30).</short>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TWndMethod">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TWndMethod.TheMessage">
        <short/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TControlStyleType">
        <short>TControlStyleType - enumerated type describing features of the Control</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStyleType.csAcceptsControls">
        <short>Can have child controls in the designer.</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStyleType.csCaptureMouse">
        <short>[?]</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStyleType.csDesignInteractive">
        <short>wants mouse events in design mode</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStyleType.csClickEvents">
        <short>[?]</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStyleType.csFramed">
        <short>[?]</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStyleType.csSetCaption">
        <short>As long as Name=Text, changing the Name will set the Caption</short>
        <descr>When for example a button's Name and Caption have the value 'Button1' and the Name is changed to 'Button2' then the Caption is changed as well. When Name and Caption differs this flag has no effect. This flag has no effect during loading.</descr>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStyleType.csOpaque">
        <short>[?]</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStyleType.csDoubleClicks">
        <short>control understands mouse double clicks</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStyleType.csTripleClicks">
        <short>control understands mouse triple clicks</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStyleType.csQuadClicks">
        <short>control understands mouse quad clicks</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStyleType.csFixedWidth">
        <short>control cannot change in width</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStyleType.csFixedHeight">
        <short>control cannot change in height (e.g. combobox)</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStyleType.csNoDesignVisible">
        <short>control is invisible in the designer</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStyleType.csReplicatable">
        <short>[?]</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStyleType.csNoStdEvents">
        <short>[?]</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStyleType.csDisplayDragImage">
        <short>display images from dragimagelist during drag operation over control</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStyleType.csReflector">
        <short>[?]</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStyleType.csActionClient">
        <short>[?]</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStyleType.csMenuEvents">
        <short>[?]</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStyleType.csNoFocus">
        <short>[?]</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStyleType.csNeedsBorderPaint">
        <short>[not implemented]</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStyleType.csParentBackground">
        <short>[not implemented]</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStyleType.csDesignNoSmoothResize">
        <short>no WYSIWYG resizing in designer</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStyleType.csDesignFixedBounds">
        <short>control can not be moved nor resized in designer</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStyleType.csHasDefaultAction">
        <short>control implements useful ExecuteDefaultAction</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStyleType.csHasCancelAction">
        <short>control implements useful ExecuteCancelAction</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStyleType.csNoDesignSelectable">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStyleType.csOwnedChildrenNotSelectable">
        <short>child controls owned by this control are NOT selectable in the designer</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStyleType.csAutoSize0x0">
        <short>if the preferred size is 0x0 then control is shrinked ot 0x0</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStyleType.csAutoSizeKeepChildLeft">
        <short>when AutoSize=true do not move children horizontally</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStyleType.csAutoSizeKeepChildTop">
      <short>when AutoSize=true do not move children vertically</short>
      </element>
      <!-- set type Visibility: default -->
      <element name="TControlStyle" link="TControlStyleType">
        <short>Set of control styles.</short>
      </element>
      <!-- constant Visibility: default -->
      <element name="csMultiClicks">
        <short>Set of styles which require/provide multiple clicks on a control.</short>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TControlStateType">
        <short>TControlStateType -  an enumerated type of state flags of Control</short>
        <descr>
          <p>Enumerated type comprising</p>
          <pre>csLButtonDown,
    csClicked,
    csPalette,
    csReadingState,
    csAlignmentNeeded,
    csFocusing,
    csCreating,
    csPaintCopy,
    csCustomPaint,
    csDestroyingHandle,
    csDocking,
    csVisibleSetInLoading
</pre>
        </descr>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStateType.csLButtonDown">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStateType.csClicked">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStateType.csPalette">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStateType.csReadingState">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStateType.csAlignmentNeeded">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStateType.csFocusing">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStateType.csCreating">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStateType.csPaintCopy">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStateType.csCustomPaint">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStateType.csDestroyingHandle">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStateType.csDocking">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStateType.csVisibleSetInLoading">
        <short/>
      </element>
      <!-- set type Visibility: default -->
      <element name="TControlState">
        <short>Set of permissible Control States</short>
      </element>
      <!-- object Visibility: default -->
      <element name="TControlCanvas">
        <short>The base class for the canvas property of several graphic controls, such as TGraphicControl and TCustomControl</short>
        <descr>[provide usable links on the methods]</descr>
        <seealso>
          <link id="#lcl.Controls.TGraphicControl">TGraphicControl</link>
          <link id="#lcl.Controls.TCustomControl">TCustomControl</link>
          <link id="#lcl.Graphics.TCanvas">TCanvas</link>
        </seealso>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControlCanvas.FControl">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControlCanvas.FDeviceContext">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControlCanvas.FWindowHandle">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControlCanvas.SetControl">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControlCanvas.SetControl.AControl">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControlCanvas.CreateFont"/>
      <!-- procedure Visibility: protected -->
      <element name="TControlCanvas.CreateHandle" link="#LCL.Graphics.TCanvas.CreateHandle"/>
      <!-- function Visibility: protected -->
      <element name="TControlCanvas.GetDefaultColor"/>
      <element name="TControlCanvas.GetDefaultColor.Result">
        <short></short>
      </element>
      <element name="TControlCanvas.GetDefaultColor.ADefaultColorType">
        <short></short>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TControlCanvas.Create"/>
      <!-- destructor Visibility: public -->
      <element name="TControlCanvas.Destroy"/>
      <!-- procedure Visibility: public -->
      <element name="TControlCanvas.FreeHandle" link="#LCL.Graphics.TCanvas.FreeHandle"/>
      <!-- function Visibility: public -->
      <element name="TControlCanvas.ControlIsPainting">
        <short>[?]</short>
        <descr>
        </descr>
        <errors>
        </errors>
        <seealso>
        </seealso>
      </element>
      <element name="TControlCanvas.ControlIsPainting.Result">
        <short></short>
      </element>
      <!-- property Visibility: public -->
      <element name="TControlCanvas.Control">
        <short>The Control object for which this is the Canvas.</short>
      </element>
      <!-- object Visibility: default -->
      <element name="TDragImageList">
        <short>
          <var>TDragImageList</var> - a list of Images to be dragged</short>
        <descr>
          <p>A drag image is shown when a DragImageList is supplied at all, 
            <b>and</b> when no accepting target is under the mouse, or the source control style includes csDisplayDragImage, or AlwaysShowDragImage is set in the DragObject.</p>
          <p>In drag-dock operations typically no drag image is shown, since the DockRect frame already gives all required visual feedback.</p>
          <pre>This is a vague idea of the usage of this class:

SetDragImage selects an image from the list, and defines the hotspot within this image.

DragLock specifies a window (handle), to which the image should be attached [what exactly does this mean?]

ShowDragImage shows the image, combined with the mouse cursor. The HotSpot indicates the shift of the image, relative to the current mouse position.

HideDragImage hides the image, shown at its last position.
</pre>
        </descr>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDragImageList.FDragCursor">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDragImageList.FDragging">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDragImageList.FDragHotspot">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDragImageList.FOldCursor">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDragImageList.FImageIndex">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDragImageList.FLastDragPos">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDragImageList.FLockedWindow">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TDragImageList.SetDragCursor">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TDragImageList.SetDragCursor.AValue">
        <short/>
      </element>
      <!-- class procedure Visibility: default -->
      <element name="TDragImageList.WSRegisterClass"/>
      <!-- procedure Visibility: protected -->
      <element name="TDragImageList.Initialize">
        <short>
          <var>Initialize</var> the list of images for dragging</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#LCL.ImgList.TCustomImageList.Initialize">TCustomImageList.Initialize</link>
        </seealso>
      </element>
      <!-- function Visibility: public -->
      <element name="TDragImageList.BeginDrag">
        <short>
          <var>BeginDrag</var> - start the drag process; returns True if successful</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TDragImageList.BeginDrag.Result">
        <short/>
      </element>
      <element name="TDragImageList.BeginDrag.Window">
        <short/>
      </element>
      <element name="TDragImageList.BeginDrag.X">
        <short/>
      </element>
      <element name="TDragImageList.BeginDrag.Y">
        <short/>
      </element>
      <element name="TDragImageList.DragLock">
        <short>
          <var>DragLock</var> - returns True if dragging has been locked for the specifies window at given location</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TDragImageList.DragLock.Result">
        <short/>
      </element>
      <element name="TDragImageList.DragLock.Window">
        <short/>
      </element>
      <element name="TDragImageList.DragLock.XPos">
        <short/>
      </element>
      <element name="TDragImageList.DragLock.YPos">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TDragImageList.DragMove">
        <short>
          <var>DragMove</var> - move dragged images to specified location and return True if successful</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TDragImageList.DragMove.Result">
        <short/>
      </element>
      <element name="TDragImageList.DragMove.X">
        <short/>
      </element>
      <element name="TDragImageList.DragMove.Y">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TDragImageList.DragUnlock">
        <short>
          <var>DragUnlock</var> - unlock the list of images for dragging</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: public -->
      <element name="TDragImageList.EndDrag">
        <short>
          <var>EndDrag</var> - retuns True if the drag process has ended</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TDragImageList.EndDrag.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TDragImageList.GetHotSpot" link="#LCL.ImgList.TCustomImageList.GetHotSpot"/>
      <element name="TDragImageList.GetHotSpot.Result">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TDragImageList.HideDragImage">
        <short>
          <var>HideDragImage</var> - method for making dragged image invisible</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: public -->
      <element name="TDragImageList.SetDragImage">
        <short>Determines the image to be shown</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TDragImageList.SetDragImage.Result">
        <short/>
      </element>
      <element name="TDragImageList.SetDragImage.Index">
        <short/>
      </element>
      <element name="TDragImageList.SetDragImage.HotSpotX">
        <short/>
      </element>
      <element name="TDragImageList.SetDragImage.HotSpotY">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TDragImageList.ShowDragImage">
        <short>
          <var>ShowDragImage</var> - display the dragged image</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragImageList.DragCursor">
        <short>
          <var>DragCursor</var> - the cursor for use during the dragging process</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragImageList.DragHotspot">
        <short>
          <var>DragHotspot</var> - the position of the HotSpot (usually the pointer of the cursor)</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragImageList.Dragging">
        <short>
          <var>Dragging</var> - True if dragging is proceeding</short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TKeyEvent">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TKeyEvent.Sender">
        <short/>
      </element>
      <element name="TKeyEvent.Key">
        <short/>
      </element>
      <element name="TKeyEvent.Shift">
        <short/>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TKeyPressEvent">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TKeyPressEvent.Sender">
        <short/>
      </element>
      <element name="TKeyPressEvent.Key">
        <short/>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TUTF8KeyPressEvent"/>
      <element name="TUTF8KeyPressEvent.Sender">
        <short/>
      </element>
      <element name="TUTF8KeyPressEvent.UTF8Key">
        <short/>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TMouseEvent">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TMouseEvent.Sender">
        <short/>
      </element>
      <element name="TMouseEvent.Button">
        <short/>
      </element>
      <element name="TMouseEvent.Shift">
        <short/>
      </element>
      <element name="TMouseEvent.X">
        <short/>
      </element>
      <element name="TMouseEvent.Y">
        <short/>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TMouseMoveEvent">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TMouseMoveEvent.Sender">
        <short/>
      </element>
      <element name="TMouseMoveEvent.Shift">
        <short/>
      </element>
      <element name="TMouseMoveEvent.X">
        <short/>
      </element>
      <element name="TMouseMoveEvent.Y">
        <short/>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TMouseWheelEvent">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TMouseWheelEvent.Sender">
        <short/>
      </element>
      <element name="TMouseWheelEvent.Shift">
        <short/>
      </element>
      <element name="TMouseWheelEvent.WheelDelta">
        <short/>
      </element>
      <element name="TMouseWheelEvent.MousePos">
        <short/>
      </element>
      <element name="TMouseWheelEvent.Handled">
        <short/>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TMouseWheelUpDownEvent">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TMouseWheelUpDownEvent.Sender">
        <short/>
      </element>
      <element name="TMouseWheelUpDownEvent.Shift">
        <short/>
      </element>
      <element name="TMouseWheelUpDownEvent.MousePos">
        <short/>
      </element>
      <element name="TMouseWheelUpDownEvent.Handled">
        <short/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TDragState">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TDragState.dsDragEnter">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TDragState.dsDragLeave">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TDragState.dsDragMove"/>
      <!-- enumeration type Visibility: default -->
      <element name="TDragMode">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TDragMode.dmManual">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TDragMode.dmAutomatic">
        <short/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TDragKind">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TDragKind.dkDrag">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TDragKind.dkDock">
        <short/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TDragOperation">
        <short>[Delphi compatible - dropped!]</short>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TDragOperation.dopNone">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TDragOperation.dopDrag">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TDragOperation.dopDock">
        <short/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TDragMessage">
        <short>DragManager message types.</short>
        <descr>
          <p>All messages are sent to the target control, except dmDragDrop and dmDragCancel is sent to the source control.</p>
          <pre>dmDragEnter: mouse enters control
dmDragLeave: mouse leaves control
dmDragMove: mouse moves over control (after dmDragEnter)
dmDragDrop: control dropped
dmDragCancel: dragging aborted
dmFindTarget: find child control under the mouse
</pre>
        </descr>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TDragMessage.dmDragEnter">
        <short>mouse enters control</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TDragMessage.dmDragLeave">
        <short>mouse leaves control</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TDragMessage.dmDragMove">
        <short>mouse moves over control (after dmDragEnter)</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TDragMessage.dmDragDrop">
        <short>control dropped</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TDragMessage.dmDragCancel">
        <short>dragging aborted</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TDragMessage.dmFindTarget">
        <short>find possible target control under the mouse</short>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TDragOverEvent">
        <short>The type of an OnDragOver handler.</short>
        <descr>
          <p>An OnDragOver event is sent by a control, when an object is dragged over it.
            The handler can specify whether a drop will be accepted or rejected.</p>
          <remark><var>Source</var> is polymorphic, can be either the DragObject or the dragged control!
            This depends on DragObject.AutoCreated, for no sane reason :-(
          </remark>
        </descr>
        <seealso><link id="TDockOverEvent"/></seealso>
      </element>
      <element name="TDragOverEvent.Sender">
        <short>The possible drop target (control).</short>
      </element>
      <element name="TDragOverEvent.Source">
        <short>The object (TDragObject or TControl) being dragged.</short>
      </element>
      <element name="TDragOverEvent.X">
        <short>X coordinate of the mouse on screen.</short>
      </element>
      <element name="TDragOverEvent.Y">
        <short>Y coordinate of the mouse on screen.</short>
      </element>
      <element name="TDragOverEvent.State">
        <short>The current DragState (entering, leaving or moving over the target).</short>
      </element>
      <element name="TDragOverEvent.Accept">
        <short>Set Accept to False to reject an drop (default is True).</short>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TDragDropEvent">
        <short>The type of an OnDragDrop (notification) handler.</short>
        <descr>An OnDragDrop event is sent by the drop target (control) on the drop of a dragged object.
        </descr>
        <seealso>
          <link id="TDockDropEvent"/>
          <link id="TEndDragEvent"/>
        </seealso>
      </element>
      <element name="TDragDropEvent.Sender" link="TDragOverEvent.Sender"/>
      <element name="TDragDropEvent.Source" link="TDragOverEvent.Source">
        <short/>
      </element>
      <element name="TDragDropEvent.X" link="TDragOverEvent.X">
        <short/>
      </element>
      <element name="TDragDropEvent.Y" link="TDragOverEvent.Y">
        <short/>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TStartDragEvent">
        <short>The type of an OnStartDrag handler.</short>
        <descr>An OnStartDrag event is sent by a control when it shall be dragged and its DragKind is dkDrag.
          The handler can provide a specific DragDrop object, else a standard TDragDropObjectEx is automatically created by the DragManager.
        </descr>
        <seealso><link id="TStartDragEvent"/></seealso>
      </element>
      <element name="TStartDragEvent.Sender">
        <short>The control to be dragged.</short>
      </element>
      <element name="TStartDragEvent.DragObject">
        <short>Supply your own DragObject, or leave it Nil for automatic creation.</short>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TEndDragEvent">
        <short>The type of an OnEndDrag handler.</short>
        <descr>
          <p>An OnEndDrag event is sent by a dragged control, when dragging is finished.
            This happens regardless of whether the operation was drag-drop or drag-dock,
            and whether the operation ended with a drop or was cancel'd.
          </p>
          <p>Check Target=Nil to distinguish between a drop and a cancel'd operation (Nil).</p>
        </descr>
        <seealso>
          <link id="TDragDropEvent"/>
          <link id="TDockDropEvent"/>
        </seealso>
      </element>
      <element name="TEndDragEvent.Sender">
        <short>The dragged control.</short>
      </element>
      <element name="TEndDragEvent.Target">
        <short>The drop target (control), or Nil if cancel'd.</short>
      </element>
      <element name="TEndDragEvent.X" link="TDragOverEvent.X">
        <short/>
      </element>
      <element name="TEndDragEvent.Y" link="TDragOverEvent.Y">
        <short/>
      </element>
      <!-- pointer type Visibility: default -->
      <element name="PDragRec" link="TDragRec">
        <short>[dropped!] A pointer to TDragRec drag message parameter record.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- record type Visibility: default -->
      <element name="TDragRec">
        <short>[dropped!] Drag message parameters.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TDragRec.Pos">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TDragRec.Source">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TDragRec.Target">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TDragRec.Docking">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- object Visibility: default -->
      <element name="TDragObject">
        <short>Base class for managing drag operations and user feedback.</short>
        <descr>
          <p>Every dragging operation has an associated DragObject, holding references to the source and target controls, and other parameters for the customization of the visual user feedback.</p>
          <p>A default DragObject is created automatically when a dragging operation starts, and is destroyed when the operation has ended, so that you must not take special care on it.
            But an application can provide a customized DragObject in the <link id="TControl.OnStartDrag"/> or <link id="TControl.OnStartDock"/> handlers of the source control (being dragged).</p>
          <remark>AutoCreated DragObjects imply different behaviour in the DragOver and DragDrop events, where the Source becomes the dragged control, while else the DragObject itself is passed as Source.
          </remark>
          <p>TDragObject is the ancestor of an whole tree of dragging objects, with the main branches supporting either drag-drop or drag-dock operations.
            The type of the operation is determined from the <link id="TControl.DragKind"/> property of the source control.</p>
          <remark>
            In contrast to the Delphi implementation, Lazarus has moved a couple of methods into the drag performers, so that these are no more available for customization.</remark>
          <p>A Lazarus DragObject mainly supplies the cursor and images, used in visual user feedback.
            Drag-drop operations typically signal acceptance of an possible drop by variations of the mouse cursor, and optionally can attach to it shapes of the dragged object(s).
            Drag-dock operations instead show a docking rectangle, that snaps to possible target locations when the mouse moves over docksites.</p>
          <p>[entire review DoDi 2011-09-10]</p>
        </descr>
        <seealso>
          <link id="TDragControlObject"/>
          <link id="TDragDockObject"/>
        </seealso>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDragObject.FDragPos"/>
      <!-- variable Visibility: private -->
      <element name="TDragObject.FDragTarget"/>
      <!-- variable Visibility: private -->
      <element name="TDragObject.FDragTargetPos"/>
      <!-- variable Visibility: private -->
      <element name="TDragObject.FAutoFree"/>
      <!-- variable Visibility: private -->
      <element name="TDragObject.FAutoCreated"/>
      <!-- variable Visibility: private -->
      <element name="TDragObject.FDropped"/>
      <!-- variable Visibility: private -->
      <element name="TDragObject.MouseDeltaX">
        <short>[Delphi compatible - dropped!]</short>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDragObject.MouseDeltaY">
        <short>[Delphi compatible - dropped!]</short>
      </element>
      <!-- function Visibility: private -->
      <element name="TDragObject.Capture">
        <short>[Delphi compatible - dropped!]</short>
      </element>
      <element name="TDragObject.Capture.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDragObject.Finished">
        <short>[Delphi compatible - dropped!]</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TDragObject.Finished.Target">
        <short/>
      </element>
      <element name="TDragObject.Finished.X">
        <short/>
      </element>
      <element name="TDragObject.Finished.Y">
        <short/>
      </element>
      <element name="TDragObject.Finished.Accepted">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TDragObject.GetDragCursor">
        <short>Returns the dragging cursor type.</short>
        <descr>In drag-drop operations the cursor signals acceptance or rejection of an drop, depending on Accepted.</descr>
        <errors/>
        <seealso/>
      </element>
      <element name="TDragObject.GetDragCursor.Result">
        <short>The cursor to show.</short>
      </element>
      <element name="TDragObject.GetDragCursor.Accepted">
        <short>Which cursor to return (rejected:crNoDrop or accepted:crDrag).</short>
      </element>
      <element name="TDragObject.GetDragCursor.X">
        <short/>
      </element>
      <element name="TDragObject.GetDragCursor.Y">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TDragObject.GetDragImages">
        <short>Returns a list of images for dragging.</short>
        <descr>The returned <link id="TDragImageList"/> provides methods for the selection and display of an image, shown while dragging.
          This implementation returns Nil, must be overridden (e.g. in TDragControlObject).
        </descr>
        <errors/>
        <seealso>
          <link id="TDragControlObject"/>
        </seealso>
      </element>
      <element name="TDragObject.GetDragImages.Result">
        <short>The ImageList to use, is Nil by default!</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDragObject.MouseMove">
        <short>[dropped!]</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TDragObject.MouseMove.Shift">
        <short/>
      </element>
      <element name="TDragObject.MouseMove.X">
        <short/>
      </element>
      <element name="TDragObject.MouseMove.Y">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDragObject.MouseDown">
        <short>[dropped!]</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TDragObject.MouseDown.Button">
        <short/>
      </element>
      <element name="TDragObject.MouseDown.Shift">
        <short/>
      </element>
      <element name="TDragObject.MouseDown.X">
        <short/>
      </element>
      <element name="TDragObject.MouseDown.Y">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDragObject.MouseUp">
        <short>[dropped!]</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TDragObject.MouseUp.Button">
        <short/>
      </element>
      <element name="TDragObject.MouseUp.Shift">
        <short/>
      </element>
      <element name="TDragObject.MouseUp.X">
        <short/>
      </element>
      <element name="TDragObject.MouseUp.Y">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDragObject.CaptureChanged">
        <short>[dropped!]</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TDragObject.CaptureChanged.OldCaptureControl">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDragObject.KeyDown">
        <short>[dropped!]</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TDragObject.KeyDown.Key">
        <short/>
      </element>
      <element name="TDragObject.KeyDown.Shift">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDragObject.KeyUp">
        <short>[dropped!]</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TDragObject.KeyUp.Key">
        <short/>
      </element>
      <element name="TDragObject.KeyUp.Shift">
        <short/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDragObject.FAlwaysShowDragImages">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDragObject.FControl">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TDragObject.Create">
        <short>Remembers the dragged control.</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#rtl.System.TObject.Create">TObject.Create</link>
        </seealso>
      </element>
      <element name="TDragObject.Create.AControl">
        <short>The control being dragged.</short>
      </element>
      <element name="TDragObject.AutoCreate">
        <short>Special constructor, enforcing the destruction of the object at the end of the dragging operation.</short>
        <descr>This constructor sets the AutoCreated and AutoFree flags. AutoFree is tested by the DragManager at the end of the dragging operation.</descr>
      </element>
      <element name="TDragObject.AutoCreate.AControl">
        <short>The control being dragged.</short>
      </element>
      <element name="TDragObject.AutoFree">
        <short>Indicates whether the object shall be destroyed at the end of the dragging operation.</short>
        <descr>This is a Lazarus specific property, introduced to get rid of the special Delphi TDrag...Ex classes.</descr>
      </element>
      <!-- destructor Visibility: public -->
      <element name="TDragObject.Destroy">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragObject.AlwaysShowDragImages">
        <short>Should the image of dragged objects always be shown?</short>
        <descr>This is another chance for enforcing the display of a drag image, even if a drop is acceptable.
[where to describe the various conditions?]</descr>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragObject.Control">
        <short>The control that is dragged (source).</short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TDragObject.Assign">
        <short>[dropped!] Copy information from another drag object.</short>
        <descr>Use <var>Assign</var> to initialize the drag object with your own default values.</descr>
      </element>
      <element name="TDragObject.Assign.Source"/>
      <!-- function Visibility: public -->
      <element name="TDragObject.GetName">
        <short>[dropped!] Returns the Name of the drag object.</short>
        <descr>This implementation returns the ClassName of the object.
          Override as appropriate for your drag management, this method is not called by LCL code.
        </descr>
      </element>
      <element name="TDragObject.GetName.Result">
        <short>The object's name.</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TDragObject.Instance">
        <short>[dropped!]</short>
      </element>
      <element name="TDragObject.Instance.Result">
        <short>Zero by default.</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TDragObject.HideDragImage">
        <short>Asks the image list to hide the drag image.</short>
        <seealso>
          <link id="#lcl.Controls.TDragObject.ShowDragImage">ShowDragImage</link>
        </seealso>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TDragObject.ShowDragImage">
        <short>Asks the image list to show the drag image.</short>
        <descr/>
        <seealso>
          <link id="#lcl.Controls.TDragObject.HideDragImage">HideDragImage</link>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragObject.Cancelling">
        <short>[dropped!] Is this drag being cancelled?</short>
        <descr>Set while this drag is cancelled. Used to prevent endless loops in further processing.</descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragObject.DragHandle">
        <short>[dropped!] The Handle of the dragged object.</short>
        <descr/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragObject.DragPos">
        <short>Current mouse position in screen coordinates.</short>
        <seealso>
          <link id="TDragObject.DragTargetPos"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragObject.DragTargetPos">
        <short>Mouse position in client coordinates of the DragTarget.</short>
        <seealso>
          <link id="TDragObject.DragPos"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragObject.DragTarget">
        <short>The control over which the object currently is dragged (target).</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragObject.Dropped">
        <short>Indicates whether the drag object has been dropped yet.</short>
        <descr>False while dragging is in progress, or when dragging has been aborted.</descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragObject.MouseDeltaX">
        <short>[dropped!] The x offset of the DragImage or DockRect hotspot.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragObject.MouseDeltaY">
        <short>[dropped!] The y offset of the DragImage or DockRect hotspot.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDragObject.AutoCreated">
        <short>Was the drag object created automatically?</short>
        <descr>This property is of little use, more important is the AutoFree property.</descr>
      </element>
      <element name="TDragObject.EndDrag">
        <short>Called when a dragging operation ends.</short>
        <descr>The default implementation calls Control.DoEndDrag, which in turn invokes an OnEndDrag handler.</descr>
      </element>
      <element name="TDragObject.EndDrag.Target">
        <short></short>
      </element>
      <element name="TDragObject.EndDrag.X">
        <short></short>
      </element>
      <element name="TDragObject.EndDrag.Y">
      <short></short>
      </element>
      <!-- "class of" type Visibility: default -->
      <element name="TDragObjectClass">
        <short>A <link id="TDragObject"/> class type.</short>
      </element>
      <element name="TDragObjectEx" link="#LCL.Controls.TDragObject">
        <short>A drag object that is automatically destroyed after use.</short>
      </element>
      <element name="TDragObjectEx.Create">
        <short>Creates a drag object that is automatically destroyed after use.</short>
      </element>
      <element name="TDragObjectEx.Create.AControl">
        <short></short>
      </element>
      <!-- object Visibility: default -->
      <element name="TDragControlObject">
        <short>A drag object for dragging a control.</short>
        <descr>
          While a TDragObject is usually used for dragging controls, this class <b>knows</b> that it drags a control, and asks it for an DragCursor and DragImages.
        </descr>
        <errors/>
        <seealso>
          <link id="TDragObject"/>
        </seealso>
      </element>
      <!-- function Visibility: protected -->
      <element name="TDragControlObject.GetDragCursor">
        <short>Asks the Control to provide an cursor.</short>
      </element>
      <element name="TDragControlObject.GetDragCursor.Result">
        <short></short>
      </element>
      <element name="TDragControlObject.GetDragCursor.Accepted">
        <short></short>
      </element>
      <element name="TDragControlObject.GetDragCursor.X">
        <short></short>
      </element>
      <element name="TDragControlObject.GetDragCursor.Y">
        <short></short>
      </element>
      <!-- function Visibility: protected -->
      <element name="TDragControlObject.GetDragImages">
        <short>Asks the Control to provide an ImageList.</short>
      </element>
      <element name="TDragControlObject.GetDragImages.Result">
        <short>The Image list to be used in dragging this control.</short>
      </element>
      <element name="TDragControlObjectEx" link="#LCL.Controls.TDragControlObject"/>
      <element name="TDragControlObjectEx.Create">
        <short>Creates an object to be destroyed after use.</short>
      </element>
      <element name="TDragControlObjectEx.Create.AControl">
        <short>The control to drag.</short>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TDockOrientation">
        <short>Orientation of DockZones and docked controls, similar to <link id="TAlign"/>.</short>
        <descr>
          <p>
          This is a Delphi relict, bound to TDockTree and not very useful in application code.<br/>
          All DockZones in an DockTree have a unique orientation, horizontal or vertical, indicating how controls are arranged in this zone.
          When a control is docked into a zone, it obtains the orientation of that zone.
          </p>
          <remark>The control's orientation can be stored as the opposite of the zone, depending on the used DockManager.
          </remark>
        </descr>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TDockOrientation.doNoOrient">
        <short>no orientation applies (like alNone)</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TDockOrientation.doHorizontal">
        <short>siblings are arranged horizontally, children top-to-bottom</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TDockOrientation.doVertical">
        <short>siblings are arranged vertically, children left-to-right</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TDockOrientation.doPages">
        <short>children are pages in a tabbed control</short>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TDockDropEvent">
        <short>The type of an OnDockDrop handler.</short>
        <descr>An OnDockDrop event is sent by the drop target (dock site) on the drop of a dragged object.
        </descr>
        <seealso><link id="TDragDropEvent"/></seealso>
      </element>
      <element name="TDockDropEvent.Sender">
        <short>The drop target (docksite control).</short>
      </element>
      <element name="TDockDropEvent.Source">
        <short>The DragDock object, containing information about the dragged object.</short>
      </element>
      <element name="TDockDropEvent.X" link="TDragOverEvent.X">
        <short/>
      </element>
      <element name="TDockDropEvent.Y" link="TDragOverEvent.Y">
        <short/>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TDockOverEvent">
        <short>The type of an OnDockOver handler.</short>
        <descr>An OnDockOver event is sent by a dock site, when an object is dragged over it.
          The handler can specify whether a drop will be accepted or rejected.
        </descr>
        <seealso><link id="TDragOverEvent"/></seealso>
      </element>
      <element name="TDockOverEvent.Sender">
        <short>The possible drop target.</short>
      </element>
      <element name="TDockOverEvent.Source" link="TDockDropEvent.Source">
        <short/>
      </element>
      <element name="TDockOverEvent.X" link="TDragOverEvent.X">
        <short/>
      </element>
      <element name="TDockOverEvent.Y" link="TDragOverEvent.Y">
        <short/>
      </element>
      <element name="TDockOverEvent.State" link="TDragOverEvent.State">
        <short/>
      </element>
      <element name="TDockOverEvent.Accept" link="TDragOverEvent.Accept">
        <short/>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TUnDockEvent">
        <short>The type of an OnUnDock handler.</short>
        <descr>An UnDock event is sent by a dock site, before a control is undocked from it.
          The handler can reject undocking, by setting Allow to False.
        </descr>
        <seealso/>
      </element>
      <element name="TUnDockEvent.Sender">
        <short>The docksite from which the object is undocked.</short>
      </element>
      <element name="TUnDockEvent.Client">
        <short>The control to be undocked.</short>
      </element>
      <element name="TUnDockEvent.NewTarget">
        <short>The new docksite for Client, Nil when undocked into floating state.</short>
      </element>
      <element name="TUnDockEvent.Allow">
        <short>Set Allow to False to reject undocking.</short>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TStartDockEvent">
        <short>The type of an OnStartDock handler.</short>
        <descr>An OnStartDock event is sent by a control when it shall be dragged and its DragKind is dkDock.
          The handler can provide a specific DragDock object, else a standard TDragDockObjectEx is automatically created by the DragManager.
        </descr>
        <seealso><link id="TStartDragEvent"/></seealso>
      </element>
      <element name="TStartDockEvent.Sender">
        <short>The control being dragged.</short>
      </element>
      <element name="TStartDockEvent.DragObject">
        <short>Supply your own TDragDockObject, or leave it Nil to request automatic creation.</short>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TGetSiteInfoEvent">
        <short>An OnGetSiteInfo handler returns information about a docksite.</short>
        <descr>An OnGetSiteInfo event is sent by the DragManager to the nearest docksite.
          The handler can adjust the snapping rectangle (InfluenceRect), and can reject an drop.
        </descr>
        <seealso/>
      </element>
      <element name="TGetSiteInfoEvent.Sender">
        <short>The dock site near the mouse pointer.</short>
      </element>
      <element name="TGetSiteInfoEvent.DockClient">
        <short>The dragged control.</short>
      </element>
      <element name="TGetSiteInfoEvent.InfluenceRect">
        <short>The screen rectangle within which a drop or mouse move will be directed to this docksite.</short>
      </element>
      <element name="TGetSiteInfoEvent.MousePos">
        <short>The current position of the mouse.</short>
      </element>
      <element name="TGetSiteInfoEvent.CanDock">
        <short>Set CanDock to False to reject docking.</short>
      </element>
      <!-- object Visibility: default -->
      <element name="TDragDockObject">
        <short>A drag object for drag-dock.</short>
        <descr>
          <p>This object type serves two main purposes: it allows to distinguish between drag-drop and drag-dock operations, and it implements docking specific information and behaviour.</p>
          <p>The primary use is for tree docking, as assumed in the TControl and TWinControl methods.</p>
          <p>[entire review DoDi 2011-09-10]</p>
        </descr>
        <errors/>
        <seealso>
          <link id="TDragObject"/>
        </seealso>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDragDockObject.FBrush">
        <short>[dropped!]</short>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDragDockObject.FDockOffset" link="TDragDockObject.DockOffset"/>
      <element name="TDragDockObject.FDockRect" link="TDragDockObject.DockRect"/>
      <element name="TDragDockObject.FDropAlign" link="TDragDockObject.DropAlign"/>
      <element name="TDragDockObject.FDropOnControl" link="TDragDockObject.DropOnControl"/>
      <element name="TDragDockObject.FFloating" link="TDragDockObject.Floating"/>
      <!-- procedure Visibility: private -->
      <element name="TDragDockObject.SetBrush">
        <short>[Delphi compatible - dropped!]</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TDragDockObject.SetBrush.Value">
        <short/>
      </element>
      <element name="TDragDockObject.DockOffset">
        <short>The hotspot offset of the dragged DockRect.</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDragDockObject.AdjustDockRect">
        <short>Adjust the DockRect relative to the dragging hotspot (DockOffset).</short>
        <descr>
          <remark>The parameter type is bad, should be <b>var</b>. Ignore it please.
          </remark>
          <p>The default implementation adjusts the stored FDockRect, by DockOffset.
            This adjustment will make the DockRect appear right over the control, when dragging starts, regardless of where the user clicked onto the control.
          </p>
          <p>You'll rarely have to override this method, since the DockRect is adjusted by every target site's DockManager later.
          </p>
        </descr>
        <errors/>
        <seealso/>
      </element>
      <element name="TDragDockObject.AdjustDockRect.ARect">
        <short>useless, ignore!</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDragDockObject.DrawDragDockImage">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDragDockObject.EndDrag">
        <short>Finish docking.</short>
        <descr>Invokes Control.DoEndDock.</descr>
        <errors/>
        <seealso>
          <link id="TControl.DoEndDock"/>
        </seealso>
      </element>
      <element name="TDragDockObject.EndDrag.Target">
        <short>The target docksite, or Nil to make the Control float.</short>
      </element>
      <element name="TDragDockObject.EndDrag.X">
        <short/>
      </element>
      <element name="TDragDockObject.EndDrag.Y">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDragDockObject.EraseDragDockImage">
        <short>[Delphi compatible - dropped!]</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TDragDockObject.GetDragCursor" link="#LCL.Controls.TDragObject.GetDragCursor"/>
      <element name="TDragDockObject.GetDragCursor.Result">
        <short/>
      </element>
      <element name="TDragDockObject.GetDragCursor.Accepted">
        <short/>
      </element>
      <element name="TDragDockObject.GetDragCursor.X">
        <short/>
      </element>
      <element name="TDragDockObject.GetDragCursor.Y">
        <short/>
      </element>
      <element name="TDragDockObject.MoveDockImage">
        <short>Moves an already visible DockRect.</short>
        <descr>
          <p>Checks the DockRect for changes against EraseDockRect, to prevent flicker.</p>
          <p>Remembers the drawn frame coordinates in EraseDockRect.</p>
        </descr>
      </element>
      <element name="TDragDockObject.InitDock">
        <short>Initializes the dragging coordinates.</short>
        <descr>
          <p>Determines the hotspot offset for adjusting the floating DockRect.</p>
          <p>Since the undocked extent of the control doesn't change while dragging, we fix the hotspot offset here.</p>
          <p>Usage: OffsetRect(DockRect, FDockOffset);</p>
        </descr>
      </element>
      <element name="TDragDockObject.InitDock.APosition">
        <short></short>
      </element>
      <element name="TDragDockObject.ShowDockImage">
        <short>Shows the DockRect, remembers the coordinates in EraseDockRect</short>
      </element>
      <element name="TDragDockObject.HideDockImage">
        <short>Hides the DockRect, invalidates EraseDockRect to prevent further erases.</short>
      </element>
      <!-- function Visibility: protected -->
      <element name="TDragDockObject.GetFrameWidth">
        <short>[Delphi compatible - dropped!]</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TDragDockObject.GetFrameWidth.Result">
        <short/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TDragDockObject.Create"/>
      <element name="TDragDockObject.Create.AControl">
        <short/>
      </element>
      <!-- destructor Visibility: public -->
      <element name="TDragDockObject.Destroy">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TDragDockObject.Assign">
        <short>[Delphi compatible - dropped!]</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TDragDockObject.Assign.Source">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragDockObject.Brush">
        <short>[Delphi compatible - dropped!]</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragDockObject.DockRect">
        <short>Screen coordinates of a possible drop location.</short>
        <descr>The DockRect gives feedback to the user, where the dragged control may be dropped.
          When no docksite signals acceptance, the DockRect reflects the floating state of the dragged control.
          When a drop will dock the control, the DockRect signifies the approximate position of the docked control.
        </descr>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragDockObject.DropAlign">
        <short>How the dragged control will be docked, relative to the target control.</short>
        <descr>When the target is a DockTree, DropAlign indicates the placement of the control relative to DropOnControl.
          Other docking methods require a specialized (derived) DragDockObject.
        </descr>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragDockObject.DropOnControl">
        <short>The already docked control, relative to which the dragged control will be docked. Nil for an empty docksite.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragDockObject.Floating">
        <short>The final state of the dragged control (after drop).</short>
        <descr>True when the dragged control becomes or stays floating.</descr>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragDockObject.FrameWidth">
        <short>[Delphi compatible - dropped!]</short>
        <descr/>
        <seealso/>
      </element>
      <!-- object Visibility: default -->
      <element name="TDragDockObjectEx">
        <short>A drag object for docking, that is automatically destroyed after use.</short>
      </element>
      <element name="TDragDockObjectEx.Create">
        <short>Creates an object to be destroyed after use.</short>
      </element>
      <element name="TDragDockObjectEx.Create.AControl">
        <short></short>
      </element>
      <!-- object Visibility: default -->
      <element name="TDockManager">
        <short>The layout manager for a docksite.</short>
        <descr>Every docksite can have an DockManager, which handles dropping and arranges the docked controls.
        </descr>
        <seealso>
          <link id="TDockTree"/>
        </seealso>
      </element>
      <element name="TDockManager.Create">
        <short>Creates an DockManager for ADockSite</short>
      </element>
      <element name="TDockManager.Create.ADockSite">
        <short>This is the TWinControl acting as the docksite.</short>
      </element>
      <element name="TDockManager.MessageHandler">
        <short>Handles the messages sent to a docksite.</short>
        <descr>
          <p>This handler must handle all mouse messages, related to the client area of the docksite that is not covered by docked controls (dock headers...).</p>
          <p>Handling mouse messages while dragging is not required. Painting of the docksite has to be implemented in PaintSite.</p>
        </descr>
        <seealso>
          <link id="TDockManager.PaintSite"/>
        </seealso>
      </element>
      <element name="TDockManager.MessageHandler.Sender">
        <short></short>
      </element>
      <element name="TDockManager.MessageHandler.Message">
        <short>The message to be processed.</short>
      </element>
      <!-- procedure Visibility: default -->
      <element name="TDockManager.BeginUpdate">
        <short>Start updating the DockSite layout.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: default -->
      <element name="TDockManager.EndUpdate">
        <short>Finish updating the DockSite layout.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TDockManager.MouseMessage">
        <short>[dropped!] The mouse message handler.</short>
      </element>
      <element name="TDockManager.AutoFreeByControl">
        <short>Returns True if the DockManager should be destroyed together with the docksite.</short>
        <descr>
          <p>This is a Lazarus specific extension of the Delphi TDockManager. It allows multiple docksites to share the same DockManager instance.</p>
        </descr>
      </element>
      <element name="TDockManager.AutoFreeByControl.Result">
        <short>True if the DockManager should be destroyed together with the docksite.</short>
      </element>
      <!-- procedure Visibility: default -->
      <element name="TDockManager.GetControlBounds">
        <short>Returns the zone bounds of a docked control.</short>
        <descr>
          <p>The TDockTree manager returns the bounds of the dockzone, including the dock header.</p>
          <p>When the Control is not docked, an empty Rect(0,0,0,0) is returned.</p>
        </descr>
        <errors/>
        <seealso/>
      </element>
      <element name="TDockManager.GetControlBounds.Control">
        <short>The docked control.</short>
      </element>
      <element name="TDockManager.GetControlBounds.AControlBounds">
        <short>The enclosing rectangle, in client coordinates of the docksite.</short>
      </element>
      <element name="TDockManager.GetDockEdge">
        <short>Determine the DropAlign.</short>
        <descr>
          <p>ADockObject contains valid DragTarget, DragPos and DragTargetPos relative dock site. DockRect is undetermined.</p>
          <p>DropOnControl may be Nil if nothing has been docked yet, or no target control exists at the mouse coordinates.</p>
          <p>Returns True if ADockObject.DropAlign has been determined. If False, the DropAlign has to be determined by default procedures.</p>
        </descr>
      </element>
      <element name="TDockManager.GetDockEdge.Result">
        <short>True if the DropAlign was determined.</short>
      </element>
      <element name="TDockManager.GetDockEdge.ADockObject">
        <short>The DragDockObject holding all information about the drag-dock operation.</short>
      </element>
      <!-- procedure Visibility: default -->
      <element name="TDockManager.InsertControl">
        <short>Position <var>DropCtl</var> relative <var>Control</var>, using the alignment specified by <var>InsertAt</var>.</short>
        <descr>
          <p>InsertControl determines the placement of the just docked control, forcing a repaint of the container control if necessary.</p>
          <remark>When SetReplacingControl has been called with a non-Nil Control before, the dropped control only should replace that control.</remark>
          <p>An overloaded version passes the DragDockObject to the dockmanager, allowing to pass more information about the drop. It allows to implement other than tree-style docksites.</p>
        </descr>
        <errors/>
        <seealso>
          <link id="TDockManager.RemoveControl"/>
        </seealso>
      </element>
      <element name="TDockManager.InsertControl.Control">
        <short>The control relative to which insert.</short>
      </element>
      <element name="TDockManager.InsertControl.InsertAt">
        <short>How to insert relative to Control.</short>
      </element>
      <element name="TDockManager.InsertControl.DropCtl">
        <short>The control to insert.</short>
      </element>
      <element name="TDockManager.InsertControl.ADockObject">
        <short>The DragDockObject holding all information about the drag-dock operation.</short>
      </element>
      <!-- procedure Visibility: default -->
      <element name="TDockManager.LoadFromStream">
        <short>Restores the layout of the docksite from Stream.</short>
        <descr>The controls to be docked can be retrieved by ReloadDockedControl from the docksite; this method returns only existing controls of the given name, owned by the owner of the docksite, by default.</descr>
        <errors/>
        <seealso>
          <link id="TWinControl.ReloadDockedControl"/>
          <link id="TDockManager.SaveToStream"/>
        </seealso>
      </element>
      <element name="TDockManager.LoadFromStream.Stream">
        <short>The stream with the layout information.</short>
      </element>
      <!-- procedure Visibility: default -->
      <element name="TDockManager.PaintSite">
        <short>Handles special painting of the docksite.</short>
        <descr>While the docked controls paint themselves, eventual dockheaders and other decoration have to be painted by the DockManager.</descr>
        <errors/>
        <seealso/>
      </element>
      <element name="TDockManager.PaintSite.DC">
        <short>The device context, used to paint.</short>
      </element>
      <!-- procedure Visibility: default -->
      <element name="TDockManager.PositionDockRect">
        <short>Determines the DockRect while dragging a control over the docksite.</short>
        <descr>
          <p>This method updates DockRect for the visual feedback, when a control is dragged over the docksite.</p>
          <p>The initial DragDockObject.DockRect spans the entire DockSite.</p>
          <p>The Delphi compatible version only can use the parameters determined by the default processing in the docksite.</p>
          <p>The Lazarus specific version can update the DockObject with better suited parameters.
            A DockManager here can implement any algorithm for the placement of a dropped control.
            The default implementation calls the Delphi compatible version.<br/>
            When you override the Lazarus version, you may have to determine the dock sibling and DropAlign again, when the default determination (in TControl and TWinControl) is inappropriate.
          </p>
        </descr>
        <errors/>
        <seealso>
          <link id="TDragDockObject"/>
        </seealso>
      </element>
      <element name="TDockManager.PositionDockRect.Client">
        <short>The dropped control.</short>
      </element>
      <element name="TDockManager.PositionDockRect.DropCtl">
        <short>The control relative to which Client shall be docked. Nil for docking into the docksite.</short>
      </element>
      <element name="TDockManager.PositionDockRect.DropAlign">
        <short>How to dock, relative to DropCtl.</short>
      </element>
      <element name="TDockManager.PositionDockRect.DockRect">
        <short>The screen rectangle of the docksite, to be adjusted by this method.</short>
      </element>
      <element name="TDockManager.PositionDockRect.ADockObject">
        <short>The DragDockObject holding all information about the drag-dock operation.</short>
      </element>
      <!-- procedure Visibility: default -->
      <element name="TDockManager.RemoveControl">
        <short>Removes the undocked control from the docksite layout.</short>
        <descr>When SetReplacingControl has been called with a non-Nil argument before, the layout of the docksite should not be changed. Instead the next inserted control should take the place and role of this control.</descr>
        <errors/>
        <seealso/>
      </element>
      <element name="TDockManager.RemoveControl.Control">
        <short>Control to remove.</short>
      </element>
      <!-- procedure Visibility: default -->
      <element name="TDockManager.ResetBounds">
        <short>
          <var>ResetBounds</var> refreshes the layout of the docksite</short>
        <descr>
          <p>This method typically notifies the DockManager of a Resize of the docksite.</p>
          <p>When the extent of the docksite really has changed, the DockManager should reposition and resize all docked controls accordingly.</p>
          <p>The layout always should be refreshed when <var>Force</var> is True. This is required when e.g. the visibility of docked controls has changed, but not the size of the docksite.</p>
        </descr>
        <errors/>
        <seealso/>
      </element>
      <element name="TDockManager.ResetBounds.Force">
        <short>When True, always update the layout.</short>
      </element>
      <!-- procedure Visibility: default -->
      <element name="TDockManager.SaveToStream">
        <short>Saves the docksite layout to <var>Stream</var>.</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="TDockManager.LoadFromStream"/>
        </seealso>
      </element>
      <element name="TDockManager.SaveToStream.Stream">
        <short>Write the layout information into this stream.</short>
      </element>
      <!-- procedure Visibility: default -->
      <element name="TDockManager.SetReplacingControl">
        <short>Specifies the control to be replaced subsequently.</short>
        <descr>
          <p>This method is called by ReplaceDockedControl, to announce a pending replacement of <var>Control</var> by another control.
          The next RemoveControl should be ignored, and InsertControl should only exchange the controls, without reorganizing the layout of the docksite.
          When <var>Control</var> is Nil, this call signals the end of the exchange [obsolete].</p>
          <remark>The name "SetReplacingControl" is a misnomer, it should read "SetControlToBeReplaced".</remark>
          <p>The intended purpose of this method is the replacement of a docked control by a Notebook, preserving the DockZone.
            This operation should be handled by an DockManager internally, and calls to this method should be ignored.
          </p>
        </descr>
        <errors/>
        <seealso>
          <link id="TDockManager.InsertControl"/>
          <link id="TDockManager.RemoveControl"/>
        </seealso>
      </element>
      <element name="TDockManager.SetReplacingControl.Control">
        <short>The control to be replaced later.</short>
      </element>
      <element name="TDockManagerClass">
        <short>The DockManager class type, for use when a DockManager is automatically created.</short>
        <seealso>
          <link id="TWinControl.CreateDockManager"/>
          <link id="DefaultDockManagerClass"/>
        </seealso>
      </element>
      <element name="DefaultDockManagerClass">
        <short>The default class used to create an DockManager in <link id="TWinControl.CreateDockManager"/>.</short>
        <seealso>
          <link id="TDockManager"/>
        </seealso>
      </element>
      <!-- range type Visibility: default -->
      <element name="TConstraintSize">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TSizeConstraintsOption">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TSizeConstraintsOption.scoAdviceWidthAsMin">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TSizeConstraintsOption.scoAdviceWidthAsMax">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TSizeConstraintsOption.scoAdviceHeightAsMin">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TSizeConstraintsOption.scoAdviceHeightAsMax">
        <short/>
      </element>
      <!-- set type Visibility: default -->
      <element name="TSizeConstraintsOptions">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- object Visibility: default -->
      <element name="TSizeConstraints">
        <short>Holds maximum and minimum values that can be used in sizing objects.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TSizeConstraints.FControl"/>
      <element name="TSizeConstraints.FMaxHeight"/>
      <element name="TSizeConstraints.FMaxInterfaceHeight"/>
      <element name="TSizeConstraints.FMaxInterfaceWidth"/>
      <element name="TSizeConstraints.FMaxWidth"/>
      <element name="TSizeConstraints.FMinHeight"/>
      <element name="TSizeConstraints.FMinInterfaceHeight"/>
      <element name="TSizeConstraints.FMinInterfaceWidth"/>
      <element name="TSizeConstraints.FMinWidth"/>
      <element name="TSizeConstraints.FOnChange"/>
      <element name="TSizeConstraints.FOptions"/>
      <!-- procedure Visibility: private -->
      <element name="TSizeConstraints.SetOptions"/>
      <element name="TSizeConstraints.SetOptions.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TSizeConstraints.Change">
        <short>Method for achieving a <var>Change</var> in the constraints</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TSizeConstraints.AssignTo" link="#rtl.Classes.TPersistent.AssignTo"/>
      <element name="TSizeConstraints.AssignTo.Dest">
        <short></short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TSizeConstraints.SetMaxHeight" link="TSizeConstraints.MaxHeight"/>
      <element name="TSizeConstraints.SetMaxHeight.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TSizeConstraints.SetMaxWidth" link="TSizeConstraints.MaxWidth"/>
      <element name="TSizeConstraints.SetMaxWidth.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TSizeConstraints.SetMinHeight" link="TSizeConstraints.MinHeight"/>
      <element name="TSizeConstraints.SetMinHeight.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TSizeConstraints.SetMinWidth" link="TSizeConstraints.MinWidth"/>
      <element name="TSizeConstraints.SetMinWidth.Value">
        <short/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TSizeConstraints.Create"/>
      <element name="TSizeConstraints.Create.AControl">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TSizeConstraints.UpdateInterfaceConstraints">
        <short>
          <var>UpdateInterfaceConstraints</var> - updates the constraints on size for the Interface</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TSizeConstraints.SetInterfaceConstraints">
        <short>
          <var>SetInterfaceConstraints</var> - specifies the constraints for the interface</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TSizeConstraints.SetInterfaceConstraints.MinW">
        <short/>
      </element>
      <element name="TSizeConstraints.SetInterfaceConstraints.MinH">
        <short/>
      </element>
      <element name="TSizeConstraints.SetInterfaceConstraints.MaxW">
        <short/>
      </element>
      <element name="TSizeConstraints.SetInterfaceConstraints.MaxH">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TSizeConstraints.EffectiveMinWidth">
        <short>
          <var>EffectiveMinWidth</var> - returns the effective value for minimum width, given the local and interface constraints</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TSizeConstraints.EffectiveMinWidth.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TSizeConstraints.EffectiveMinHeight">
        <short>
          <var>EffectiveMinHeight</var> - returns the effective value for minimum height, given the local and interface constraints</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TSizeConstraints.EffectiveMinHeight.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TSizeConstraints.EffectiveMaxWidth">
        <short>
          <var>EffectiveMaxWidth</var> - returns the effective value for maximum width, given the local and interface constraints</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TSizeConstraints.EffectiveMaxWidth.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TSizeConstraints.EffectiveMaxHeight">
        <short>
          <var>EffectiveMaxHeight</var> - returns the effective value for maximum height, given the local and interface constraints</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TSizeConstraints.EffectiveMaxHeight.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TSizeConstraints.MinMaxWidth">
        <short>
          <var>MinMaxWidth</var> the difference between Minimum and Maximum width</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TSizeConstraints.MinMaxWidth.Result">
        <short/>
      </element>
      <element name="TSizeConstraints.MinMaxWidth.Width">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TSizeConstraints.MinMaxHeight">
        <short>
          <var>MinMaxHeight</var> the difference between Minimum and Maximum height</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TSizeConstraints.MinMaxHeight.Result">
        <short/>
      </element>
      <element name="TSizeConstraints.MinMaxHeight.Height">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TSizeConstraints.MaxInterfaceHeight">
        <short>
          <var>MaxInterfaceHeight</var> - the maximum height allowed by the interace</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TSizeConstraints.MaxInterfaceWidth">
        <short>
          <var>MaxInterfaceWidth</var> - the maximum width allowed by the interace</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TSizeConstraints.MinInterfaceHeight">
        <short>
          <var>MinInterfaceHeight</var> - the minimum height allowed by the interface</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TSizeConstraints.MinInterfaceWidth">
        <short>
          <var>MinInterfaceWidth</var> - the minimum width allowed by the interface</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TSizeConstraints.Control">
        <short>The <var>Control</var> to which these constraints apply</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TSizeConstraints.Options">
        <short>
          <var>Options</var> for determining constraints</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TSizeConstraints.OnChange">
        <short>
          <var>OnChange</var> - event handler for a change in contraints</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TSizeConstraints.MaxHeight">
        <short>
          <var>MaxHeight</var> - the maximum height</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TSizeConstraints.MaxWidth">
        <short>
          <var>MaxWidth</var> - the maximum width</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TSizeConstraints.MinHeight">
        <short>
          <var>MinHeight</var> - the minimum height</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TSizeConstraints.MinWidth">
        <short>
          <var>MinWidth</var> - the minimum width</short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TConstrainedResizeEvent">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TConstrainedResizeEvent.Sender">
        <short/>
      </element>
      <element name="TConstrainedResizeEvent.MinWidth">
        <short/>
      </element>
      <element name="TConstrainedResizeEvent.MinHeight">
        <short/>
      </element>
      <element name="TConstrainedResizeEvent.MaxWidth">
        <short/>
      </element>
      <element name="TConstrainedResizeEvent.MaxHeight">
        <short/>
      </element>
      <!-- range type Visibility: default -->
      <element name="TSpacingSize">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- record type Visibility: default -->
      <element name="TControlBorderSpacingDefault" link="TControlBorderSpacing">
        <short>Defines the default values for TControlBorderSpacing.</short>
        <descr>
        </descr>
        <seealso>
        </seealso>
      </element>
      <!-- variable Visibility: default -->
      <element name="TControlBorderSpacingDefault.Left" link="TControlBorderSpacing.Left"/>
      <element name="TControlBorderSpacingDefault.Top" link="TControlBorderSpacing.Top"/>
      <element name="TControlBorderSpacingDefault.Right" link="TControlBorderSpacing.Right"/>
      <element name="TControlBorderSpacingDefault.Bottom" link="TControlBorderSpacing.Bottom"/>
      <element name="TControlBorderSpacingDefault.Around" link="TControlBorderSpacing.Around"/>
      <!-- pointer type Visibility: default -->
      <element name="PControlBorderSpacingDefault" link="TControlBorderSpacing"/>
      <!-- object Visibility: default -->
      <element name="TControlBorderSpacing">
        <short>
          <var>TControlBorderSpacing </var>- the spacing around a Control</short>
        <descr>
          <code>{ TControlBorderSpacing defines the spacing around a control.

    The spacing around its children and between its children is defined in
    TWinControl.ChildSizing.

    Left, Top, Right, Bottom: integer;
        minimum space left to the autosized control.
        For example: Control A lies left of control B.
        A has borderspacing Right=10 and B has borderspacing Left=5.
        Then A and B will have a minimum space of 10 between.

    Around: integer;
        same as Left, Top, Right and Bottom all at once. This will be added to
        the effective Left, Top, Right and Bottom.
        Example: Left=3 and Around=5 results in a minimum spacing to the left
        of 8.

    InnerBorder: integer;
        This is added to the preferred size.
        For example: A buttons widget returns 75x25 on GetPreferredSize.
        CalculatePreferredSize adds 2 times the InnerBorder to the width and
        height.
        
    CellAlignHorizontal, CellAlignVertical: TControlCellAlign;
        Used for example when the Parents.ChildSizing.Layout defines a table
        layout.

  }</code>
        </descr>
        <errors/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControlBorderSpacing.FAround" link="TControlBorderSpacing.Around"/>
      <element name="TControlBorderSpacing.FBottom" link="TControlBorderSpacing.Bottom"/>
      <element name="TControlBorderSpacing.FCellAlignHorizontal"/>
      <element name="TControlBorderSpacing.FCellAlignVertical"/>
      <element name="TControlBorderSpacing.FControl"/>
      <element name="TControlBorderSpacing.FInnerBorder"/>
      <element name="TControlBorderSpacing.FLeft"/>
      <element name="TControlBorderSpacing.FOnChange"/>
      <element name="TControlBorderSpacing.FRight"/>
      <element name="TControlBorderSpacing.FTop"/>
      <element name="TControlBorderSpacing.FDefault"/>
      <!-- function Visibility: private -->
      <element name="TControlBorderSpacing.IsAroundStored"/>
      <element name="TControlBorderSpacing.IsAroundStored.Result">
        <short></short>
      </element>
      <!-- function Visibility: private -->
      <element name="TControlBorderSpacing.IsBottomStored"/>
      <element name="TControlBorderSpacing.IsBottomStored.Result">
        <short></short>
      </element>
      <!-- function Visibility: private -->
      <element name="TControlBorderSpacing.IsInnerBorderStored"/>
      <element name="TControlBorderSpacing.IsInnerBorderStored.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TControlBorderSpacing.IsLeftStored"/>
      <element name="TControlBorderSpacing.IsLeftStored.Result">
        <short></short>
      </element>
      <!-- function Visibility: private -->
      <element name="TControlBorderSpacing.IsRightStored"/>
      <element name="TControlBorderSpacing.IsRightStored.Result">
        <short></short>
      </element>
      <!-- function Visibility: private -->
      <element name="TControlBorderSpacing.IsTopStored"/>
      <element name="TControlBorderSpacing.IsTopStored.Result">
        <short></short>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControlBorderSpacing.SetCellAlignHorizontal">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControlBorderSpacing.SetCellAlignHorizontal.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControlBorderSpacing.SetCellAlignVertical">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControlBorderSpacing.SetCellAlignVertical.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControlBorderSpacing.SetInnerBorder">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControlBorderSpacing.SetInnerBorder.AValue">
        <short/>
      </element>
      <element name="TControlBorderSpacing.Change.InnerSpaceChanged">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControlBorderSpacing.GetSideSpace">
        <short>
          <var>GetSideSpace</var> - finds th espace requied at the side for the specified anchor kind</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControlBorderSpacing.GetSideSpace.Result">
        <short/>
      </element>
      <element name="TControlBorderSpacing.GetSideSpace.Kind">
        <short/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControlBorderSpacing.InnerBorder">
        <short>Amount of pixel added to the widgetset's preferred size</short>
        <descr>When calculating the preferred size of control, the LCL asks first the widgetset. For controls like TButton the widgetset can return a preferred size. The InnerBorder is added twice to this size. If the widgetset does not return a preferred size, the InnerBorder is not used.</descr>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControlBorderSpacing.CellAlignHorizontal">
        <short>
          <var>CellAlignHorizontal</var>  - the sort of horizontal alignment to use if a cell is being aligned</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControlBorderSpacing.CellAlignVertical">
        <short>
          <var>CellAlignVertical</var>  - the sort of vertical alignment to use if a cell is being aligned</short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControlBorderSpacing.SetAround">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControlBorderSpacing.SetAround.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControlBorderSpacing.SetBottom">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControlBorderSpacing.SetBottom.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControlBorderSpacing.SetLeft">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControlBorderSpacing.SetLeft.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControlBorderSpacing.SetRight">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControlBorderSpacing.SetRight.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControlBorderSpacing.SetSpace">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControlBorderSpacing.SetSpace.Kind">
        <short/>
      </element>
      <element name="TControlBorderSpacing.SetSpace.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControlBorderSpacing.SetTop">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControlBorderSpacing.SetTop.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControlBorderSpacing.Change">
        <short>Invokes the <var>OnChange</var> handler.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TControlBorderSpacing.Create">
        <short/>
        <descr/>
        <errors/>
        <seealso>
          <link id="#rtl.System.TObject.Create">TObject.Create</link>
        </seealso>
      </element>
      <element name="TControlBorderSpacing.Create.OwnerControl">
        <short/>
      </element>
      <element name="TControlBorderSpacing.Create.ADefault">
        <short></short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControlBorderSpacing.Assign" link="#rtl.Classes.TPersistent.Assign"/>
      <element name="TControlBorderSpacing.Assign.Source">
        <short></short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControlBorderSpacing.AssignTo" link="#rtl.Classes.TPersistent.AssignTo"/>
      <element name="TControlBorderSpacing.AssignTo.Dest">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControlBorderSpacing.IsEqual">
        <short>
          <var>IsEqual</var> - returns True if the specified spacing equals the current value</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControlBorderSpacing.IsEqual.Result">
        <short/>
      </element>
      <element name="TControlBorderSpacing.IsEqual.Spacing">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControlBorderSpacing.GetSpaceAround">
        <short>
          <var>GetSpaceAround</var> - finds the space around the edge</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControlBorderSpacing.GetSpaceAround.SpaceAround">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControlBorderSpacing.GetSpace">
        <short>
          <var>GetSpace</var> - finds the space required by the specified Anchor kind</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControlBorderSpacing.GetSpace.Result">
        <short/>
      </element>
      <element name="TControlBorderSpacing.GetSpace.Kind">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControlBorderSpacing.Control">
        <short>The control for which border spacing is defined</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControlBorderSpacing.Space">
        <short>The kind of anchor to used in calculating spacing</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlBorderSpacing.Space.Kind">
        <short/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControlBorderSpacing.OnChange">
        <short>Event handler for a change in border spacing</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControlBorderSpacing.Left">
        <short>The size of the space at the left border</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControlBorderSpacing.Top">
        <short>The size of the space at the top border</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControlBorderSpacing.Right">
        <short>The size of the space at the right border</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControlBorderSpacing.Bottom">
        <short>The size of the space at the bottom border</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControlBorderSpacing.Around">
        <short>The size of the space all around the control</short>
        <descr/>
        <seealso/>
      </element>
      <!-- object Visibility: default -->
      <element name="TAnchorSide">
        <short>
          <var>TAnchorSide</var> - the side on which anchoring is to be performed for the current control</short>
        <descr>
          <pre>TAnchorSide

    Class holding the reference sides of the anchors of a TControl.
    Every TControl has four AnchorSides:
    AnchorSide[akLeft], AnchorSide[akRight], AnchorSide[akTop] and
    AnchorSide[akBottom].
    Normally if Anchors contain akLeft, and the Parent is resized, the LCL
    tries to keep the distance between the left side of the control and the
    right side of its parent client area.
    With AnchorSide[akLeft] you can define a different reference side. The
    kept distance is defined by the BorderSpacing.
    
    Example1:
       +-----+  +-----+
       |  B  |  |  C  |
       |     |  +-----+
       +-----+

      If you want to have the top of B the same as the top of C use
        B.AnchorSide[akTop].Side:=asrTop;
        B.AnchorSide[akTop].Control:=C;
      If you want to keep a distance of 10 pixels between B and C use
        B.BorderSpacing.Right:=10;
        B.AnchorSide[akRight].Side:=asrLeft;
        B.AnchorSide[akRight].Control:=C;

      Do not setup in both directions, because this will create a circle, and
      circles are not allowed.
      
    Example2:
            +-------+
      +---+ |       |
      | A | |   B   |
      +---+ |       |
            +-------+
            
      Centering A relative to B:
        A.AnchorSide[akTop].Side:=arsCenter;
        A.AnchorSide[akTop].Control:=B;
      Or use this. It's equivalent:
        A.AnchorSide[akBottom].Side:=arsCenter;
        A.AnchorSide[akBottom].Control:=B;
</pre>
        </descr>
        <errors/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TAnchorSide.FControl"/>
      <element name="TAnchorSide.FKind"/>
      <element name="TAnchorSide.FOwner"/>
      <element name="TAnchorSide.FSide"/>
      <!-- function Visibility: private -->
      <element name="TAnchorSide.IsSideStored"/>
      <element name="TAnchorSide.IsSideStored.Result">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TAnchorSide.SetControl"/>
      <element name="TAnchorSide.SetControl.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TAnchorSide.SetSide"/>
      <element name="TAnchorSide.SetSide.AValue">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TAnchorSide.GetOwner"/>
      <element name="TAnchorSide.GetOwner.Result">
        <short></short>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TAnchorSide.Create"/>
      <element name="TAnchorSide.Create.TheOwner">
        <short/>
      </element>
      <element name="TAnchorSide.Create.TheKind">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TAnchorSide.GetSidePosition">
        <short>
          <var>GetSidePosition</var> - returns the position of the side used for anchoring[?]</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TAnchorSide.GetSidePosition.ReferenceControl">
        <short/>
      </element>
      <element name="TAnchorSide.GetSidePosition.ReferenceSide">
        <short/>
      </element>
      <element name="TAnchorSide.GetSidePosition.Position">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TAnchorSide.CheckSidePosition">
        <short></short>
        <descr>
        </descr>
        <errors>
        </errors>
        <seealso>
        </seealso>
      </element>
      <element name="TAnchorSide.CheckSidePosition.Result">
        <short></short>
      </element>
      <element name="TAnchorSide.CheckSidePosition.NewControl">
        <short></short>
      </element>
      <element name="TAnchorSide.CheckSidePosition.NewSide">
        <short></short>
      </element>
      <element name="TAnchorSide.CheckSidePosition.ReferenceControl">
        <short></short>
      </element>
      <element name="TAnchorSide.CheckSidePosition.ReferenceSide">
        <short></short>
      </element>
      <element name="TAnchorSide.CheckSidePosition.Position">
        <short></short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TAnchorSide.Assign" link="#rtl.Classes.TPersistent.Assign"/>
      <element name="TAnchorSide.Assign.Source">
        <short></short>
      </element>
      <!-- function Visibility: public -->
      <element name="TAnchorSide.IsAnchoredToParent">
        <short></short>
        <descr>
        </descr>
        <errors>
        </errors>
        <seealso>
        </seealso>
      </element>
      <element name="TAnchorSide.IsAnchoredToParent.Result">
        <short></short>
      </element>
      <element name="TAnchorSide.IsAnchoredToParent.ParentSide">
        <short></short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TAnchorSide.FixCenterAnchoring">
        <short></short>
        <descr>
        </descr>
        <errors>
        </errors>
        <seealso>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TAnchorSide.Owner">
        <short>
          <var>Owner</var> - the Control that owns this AnchorSide</short>
        <descr>TAnchorSide.Owner is the control *to be* anchored. Every control has four AnchorSides. For example AButton1.AnchorSide[akBottom].Owner = AButton1.</descr>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TAnchorSide.Kind">
        <short>The <var>Kind</var> is the control side</short>
        <descr>Every control has four AnchorSide, one for each side. For example AButton1.AnchorSide[akLeft].Kind=akLeft.</descr>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TAnchorSide.Control">
        <short>The target control of the anchor</short>
        <descr>For example if the right side of a Button1 is anchored to the left side of Edit1, then Button1.AnchorSide[akRight].Control=Edit1 and Button1.AnchorSide[akRight].Side=asrLeft.</descr>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TAnchorSide.Side">
        <short>The side on which anchoring is to be performed</short>
        <descr>For example if the right side of a Button1 is anchored to the left side of Edit1, then Button1.AnchorSide[akRight].Control=Edit1 and Button1.AnchorSide[akRight].Side=asrLeft.</descr>
        <seealso/>
      </element>
      <!-- object Visibility: default -->
      <element name="TControlActionLink">
        <short>
          <var>TControlActionLink</var> - links the current control to an action</short>
        <descr>
          <p>
            <var>TControlActionLink</var> - links the current control to an action</p>
          <p>Defines a number of protected methods (inherited from <link id="#lcl.ActnList.TActionLink">TActionLink</link>) for checking which parts of the control are linked to the action</p>
        </descr>
        <errors/>
        <seealso/>
      </element>
      <!-- variable Visibility: protected -->
      <element name="TControlActionLink.FClient">
        <short>Local variable that identifies the client control that is to be linked to the action</short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControlActionLink.AssignClient" link="#rtl.Classes.TBasicActionLink.AssignClient"/>
      <element name="TControlActionLink.AssignClient.AClient">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControlActionLink.IsCaptionLinked" link="#LCL.ActnList.TActionLink.IsCaptionLinked"/>
      <element name="TControlActionLink.IsCaptionLinked.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControlActionLink.IsEnabledLinked" link="#LCL.ActnList.TActionLink.IsEnabledLinked"/>
      <element name="TControlActionLink.IsEnabledLinked.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControlActionLink.IsHelpLinked" link="#LCL.ActnList.TActionLink.IsHelpLinked"/>
      <element name="TControlActionLink.IsHelpLinked.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControlActionLink.IsHintLinked" link="#LCL.ActnList.TActionLink.IsHintLinked"/>
      <element name="TControlActionLink.IsHintLinked.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControlActionLink.IsVisibleLinked" link="#LCL.ActnList.TActionLink.IsVisibleLinked"/>
      <element name="TControlActionLink.IsVisibleLinked.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControlActionLink.IsOnExecuteLinked">
        <short>
          <var>IsOnExecuteLinked</var> - returns True if the OnExecute event is linked</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControlActionLink.IsOnExecuteLinked.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControlActionLink.DoShowHint">
        <short>
          <var>DoShowHint</var> - method to display hint; returns True if successful</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControlActionLink.DoShowHint.Result">
        <short/>
      </element>
      <element name="TControlActionLink.DoShowHint.HintStr">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControlActionLink.SetCaption">
        <short>
          <var>SetCaption</var> - specifies the caption for the control</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#LCL.ActnList.TActionLink.SetCaption">TActionLink.SetCaption</link>
        </seealso>
      </element>
      <element name="TControlActionLink.SetCaption.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControlActionLink.SetEnabled">
        <short>
          <var>SetEnabled</var> - sets the Enabled property.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControlActionLink.SetEnabled.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControlActionLink.SetHint">
        <short>
          <var>SetHint</var> - sets the Hint property.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControlActionLink.SetHint.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControlActionLink.SetHelpContext">
        <short>
          <var>SetHelpContext</var> - specifies the context sensitive help ID</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControlActionLink.SetHelpContext.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControlActionLink.SetHelpKeyword">
        <short>
          <var>SetHelpKeyword</var> - specifies the help keyword</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControlActionLink.SetHelpKeyword.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControlActionLink.SetHelpType">
        <short>
          <var>SetHelpType</var> - specifies the type of help to use</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControlActionLink.SetHelpType.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControlActionLink.SetVisible">
        <short>
          <var>SetVisible</var> - specifies the visiblity</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControlActionLink.SetVisible.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControlActionLink.SetOnExecute">
        <short>
          <var>SetOnExecute</var> - specifies the Execute event handler</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControlActionLink.SetOnExecute.Value">
        <short/>
      </element>
      <!-- "class of" type Visibility: default -->
      <element name="TControlActionLinkClass">
        <short>
          <var>TControlActionLinkClass</var> - class of 
          <var>TControlActionLink</var>
        </short>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TControlAutoSizePhase">
        <short>[?]</short>
        <descr>
        </descr>
        <seealso>
        </seealso>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlAutoSizePhase.caspNone">
        <short></short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlAutoSizePhase.caspChangingProperties">
        <short></short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlAutoSizePhase.caspCreatingHandles">
        <short>create/destroy handles</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlAutoSizePhase.caspComputingBounds">
        <short></short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlAutoSizePhase.caspRealizingBounds">
        <short></short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlAutoSizePhase.caspShowing">
        <short>make handles visible</short>
      </element>
      <!-- set type Visibility: default -->
      <element name="TControlAutoSizePhases" link="TControlAutoSizePhase"/>
      <!-- constant Visibility: default -->
      <element name="AutoSizePhaseNames" link="TControlAutoSizePhase">
        <short>Names for TControlAutoSizePhase.</short>
      </element>
      <!-- range type Visibility: default -->
      <element name="TTabOrder">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TControlShowHintEvent">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlShowHintEvent.Sender">
        <short/>
      </element>
      <element name="TControlShowHintEvent.HintInfo">
        <short/>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TContextPopupEvent">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TContextPopupEvent.Sender">
        <short/>
      </element>
      <element name="TContextPopupEvent.MousePos">
        <short/>
      </element>
      <element name="TContextPopupEvent.Handled">
        <short/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TControlFlag">
        <short>[?]</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlFlag.cfLoading">
        <short>set by TControl.ReadState, unset by TControl.Loaded when all on form finished loading</short>
      </element>
      <element name="TControlFlag.cfAutoSizeNeeded">
        <short/>
      </element>
      <element name="TControlFlag.cfLeftLoaded">
        <short>cfLeftLoaded is set, when 'Left' is set during loading.</short>
      </element>
      <element name="TControlFlag.cfTopLoaded">
        <short/>
      </element>
      <element name="TControlFlag.cfWidthLoaded">
        <short/>
      </element>
      <element name="TControlFlag.cfHeightLoaded">
        <short/>
      </element>
      <element name="TControlFlag.cfClientWidthLoaded">
        <short/>
      </element>
      <element name="TControlFlag.cfClientHeightLoaded">
        <short/>
      </element>
      <element name="TControlFlag.cfBoundsRectForNewParentValid">
        <short/>
      </element>
      <element name="TControlFlag.cfBaseBoundsValid">
        <short/>
      </element>
      <element name="TControlFlag.cfPreferredSizeValid">
        <short/>
      </element>
      <element name="TControlFlag.cfPreferredMinSizeValid">
        <short/>
      </element>
      <element name="TControlFlag.cfOnChangeBoundsNeeded">
        <short/>
      </element>
      <element name="TControlFlag.cfProcessingWMPaint">
        <short></short>
      </element>
      <element name="TControlFlag.cfKillChangeBounds">
        <short></short>
      </element>
      <element name="TControlFlag.cfKillInvalidatePreferredSize">
        <short></short>
      </element>
      <element name="TControlFlag.cfKillAdjustSize">
        <short></short>
      </element>
      <!-- set type Visibility: default -->
      <element name="TControlFlags" link="TControlFlag"/>
      <!-- enumeration type Visibility: default -->
      <element name="TControlHandlerType">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlHandlerType.chtOnResize">
        <short/>
      </element>
      <element name="TControlHandlerType.chtOnChangeBounds">
        <short/>
      </element>
      <element name="TControlHandlerType.chtOnVisibleChanging">
        <short/>
      </element>
      <element name="TControlHandlerType.chtOnVisibleChanged">
        <short/>
      </element>
      <element name="TControlHandlerType.chtOnKeyDown">
        <short></short>
      </element>
      <!-- object Visibility: default -->
      <element name="TControl">
        <short>The base class for visible controls.</short>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FActionLink"/>
      <element name="TControl.FAlign"/>
      <element name="TControl.fAnchoredControls"/>
      <element name="TControl.FAnchors"/>
      <element name="TControl.FAnchorSides"/>
      <element name="TControl.FAutoSize"/>
      <element name="TControl.FAutoSizing"/>
      <element name="TControl.FAutoSizingAll"/>
      <element name="TControl.FAutoSizingLockCount"/>
      <element name="TControl.FAutoSizingSelf"/>
      <element name="TControl.FBaseBounds"/>
      <element name="TControl.FBaseBoundsLock"/>
      <element name="TControl.FBaseParentClientSize"/>
      <element name="TControl.FBiDiMode"/>
      <element name="TControl.FBorderSpacing"/>
      <element name="TControl.FBoundsRectForNewParent"/>
      <element name="TControl.FCaption"/>
      <element name="TControl.FCaptureMouseButtons"/>
      <element name="TControl.FColor"/>
      <element name="TControl.FConstraints"/>
      <element name="TControl.FControlFlags"/>
      <element name="TControl.FControlHandlers"/>
      <element name="TControl.FControlStyle"/>
      <element name="TControl.FCtl3D"/>
      <element name="TControl.FCursor"/>
      <element name="TControl.FDesktopFont"/>
      <element name="TControl.FDockOrientation"/>
      <element name="TControl.FDragCursor"/>
      <element name="TControl.FDragKind"/>
      <element name="TControl.FDragMode"/>
      <element name="TControl.FEnabled"/>
      <element name="TControl.FFloatingDockSiteClass"/>
      <element name="TControl.FFont"/>
      <element name="TControl.FHeight"/>
      <element name="TControl.FHelpContext"/>
      <element name="TControl.FHelpKeyword"/>
      <element name="TControl.FHelpType"/>
      <element name="TControl.FHint"/>
      <element name="TControl.FHostDockSite"/>
      <element name="TControl.FIsControl"/>
      <element name="TControl.fLastAlignedBoundsTried"/>
      <element name="TControl.FLastDoChangeBounds"/>
      <element name="TControl.FLastResizeClientHeight"/>
      <element name="TControl.FLastDoChangeClientSize"/>
      <element name="TControl.FLastResizeClientWidth"/>
      <element name="TControl.FLastResizeHeight"/>
      <element name="TControl.FLastResizeWidth"/>
      <element name="TControl.FLeft"/>
      <element name="TControl.FLoadedClientSize"/>
      <element name="TControl.FLRDockWidth"/>
      <element name="TControl.FMouseEntered"/>
      <element name="TControl.FOnChangeBounds"/>
      <element name="TControl.FOnClick"/>
      <element name="TControl.FOnConstrainedResize"/>
      <element name="TControl.FOnContextPopup"/>
      <element name="TControl.FOnDblClick"/>
      <element name="TControl.FOnDragDrop"/>
      <element name="TControl.FOnDragOver"/>
      <element name="TControl.FOnEditingDone"/>
      <element name="TControl.FOnEndDock"/>
      <element name="TControl.FOnEndDrag"/>
      <element name="TControl.FOnMouseDown"/>
      <element name="TControl.FOnMouseEnter"/>
      <element name="TControl.FOnMouseLeave"/>
      <element name="TControl.FOnMouseMove"/>
      <element name="TControl.FOnMouseUp"/>
      <element name="TControl.FOnMouseWheel"/>
      <element name="TControl.FOnMouseWheelDown"/>
      <element name="TControl.FOnMouseWheelUp"/>
      <element name="TControl.FOnQuadClick"/>
      <element name="TControl.FOnResize"/>
      <element name="TControl.FOnShowHint"/>
      <element name="TControl.FOnStartDock"/>
      <element name="TControl.FOnStartDrag"/>
      <element name="TControl.FOnTripleClick"/>
      <element name="TControl.FParent"/>
      <element name="TControl.FParentBiDiMode"/>
      <element name="TControl.FParentColor"/>
      <element name="TControl.FParentFont"/>
      <element name="TControl.FParentShowHint"/>
      <element name="TControl.FPopupMenu"/>
      <element name="TControl.FPreferredHeight"/>
      <element name="TControl.FPreferredMinHeight"/>
      <element name="TControl.FPreferredMinWidth"/>
      <element name="TControl.FPreferredWidth"/>
      <element name="TControl.FReadBounds"/>
      <element name="TControl.FSessionProperties"/>
      <element name="TControl.FShowHint"/>
      <element name="TControl.FSizeLock"/>
      <element name="TControl.FTBDockHeight"/>
      <element name="TControl.FTop"/>
      <element name="TControl.FUndockHeight"/>
      <element name="TControl.FUndockWidth"/>
      <element name="TControl.FVisible"/>
      <element name="TControl.FWidth"/>
      <element name="TControl.FWindowProc"/>
      <!-- procedure Visibility: private -->
      <element name="TControl.DoActionChange">
        <short>Hander for a changed Action.</short>
        <descr>When the action is assigned to this control, updates related properties using <link id="TControl.ActionChange">ActionChange</link>.</descr>
      </element>
      <element name="TControl.DoActionChange.Sender">
        <short>The changed Action.</short>
      </element>
      <!-- function Visibility: private -->
      <element name="TControl.GetAutoSizingAll" link="TControl.AutoSizingAll"/>
      <element name="TControl.GetAutoSizingAll.Result">
        <short></short>
      </element>
      <!-- function Visibility: private -->
      <element name="TControl.GetAnchoredControls" link="TControl.AnchoredControls"/>
      <element name="TControl.GetAnchoredControls.Result">
        <short/>
      </element>
      <element name="TControl.GetAnchoredControls.Index">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TControl.GetAnchorSide" link="TControl.AnchorSide"/>
      <element name="TControl.GetAnchorSide.Result">
        <short/>
      </element>
      <element name="TControl.GetAnchorSide.Kind">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TControl.GetAnchorSideIndex">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.GetAnchorSideIndex.Result">
        <short/>
      </element>
      <element name="TControl.GetAnchorSideIndex.Index">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TControl.GetBoundsRect" link="TControl.BoundsRect"/>
      <element name="TControl.GetBoundsRect.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TControl.GetClientHeight" link="TControl.ClientHeight"/>
      <element name="TControl.GetClientHeight.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TControl.GetClientWidth" link="TControl.ClientWidth"/>
      <element name="TControl.GetClientWidth.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.GetCursor" link="TControl.Cursor"/>
      <element name="TControl.GetCursor.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TControl.GetLRDockWidth" link="TControl.LRDockWidth"/>
      <element name="TControl.GetLRDockWidth.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TControl.GetMouseCapture">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.GetMouseCapture.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TControl.GetTBDockHeight" link="TControl.TBDockHeight"/>
      <element name="TControl.GetTBDockHeight.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TControl.GetText">
        <short>Returns the Text property.</short>
        <descr>Uses RealGetText instead of GetTextBuf, if possible.</descr>
        <seealso>
          <link id="#lcl.Controls.TControl.GetTextBuf">GetTextBuf</link>
          <link id="#lcl.Controls.TControl.RealGetText"/>
        </seealso>
      </element>
      <element name="TControl.GetText.Result">
        <short>The Text property.</short>
      </element>
      <!-- function Visibility: private -->
      <element name="TControl.GetUndockHeight" link="TControl.UndockHeight"/>
      <element name="TControl.GetUndockHeight.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TControl.GetUndockWidth" link="TControl.UndockWidth"/>
      <element name="TControl.GetUndockWidth.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TControl.IsAnchorsStored" link="TControl.Anchors"/>
      <element name="TControl.IsAnchorsStored.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TControl.IsBiDiModeStored" link="TControl.BiDiMode"/>
      <element name="TControl.IsBiDiModeStored.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.IsBorderSpacingInnerBorderStored">
        <short>Function to find if details of border spacing are stored</short>
      </element>
      <element name="TControl.IsBorderSpacingInnerBorderStored.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TControl.IsCaptionStored" link="TControl.Caption"/>
      <element name="TControl.IsCaptionStored.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TControl.CaptureMouseButtonsIsStored" link="TControl.CaptureMouseBottons"/>
      <element name="TControl.CaptureMouseButtonsIsStored.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.IsClientHeightStored"/>
      <element name="TControl.IsClientHeightStored.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.IsClientWidthStored">
        <short>Is Client Width Stored?</short>
      </element>
      <element name="TControl.IsClientWidthStored.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TControl.IsColorStored" link="TControl.Color"/>
      <element name="TControl.IsColorStored.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TControl.IsEnabledStored" link="TControl.Enabled"/>
      <element name="TControl.IsEnabledStored.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TControl.IsFontStored" link="TControl.Font"/>
      <element name="TControl.IsFontStored.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TControl.IsHintStored" link="TControl.Hint"/>
      <element name="TControl.IsHintStored.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TControl.IsHelpContextStored" link="TControl.HelpContext"/>
      <element name="TControl.IsHelpContextStored.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TControl.IsHelpKeyWordStored" link="TControl.HelpKeyword"/>
      <element name="TControl.IsHelpKeyWordStored.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TControl.IsOnClickStored" link="TControl.OnClick"/>
      <element name="TControl.IsOnClickStored.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TControl.IsShowHintStored" link="TControl.ShowHint"/>
      <element name="TControl.IsShowHintStored.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TControl.IsVisibleStored" link="TControl.Visible"/>
      <element name="TControl.IsVisibleStored.Result">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.SetBiDiMode" link="TControl.BiDiMode"/>
      <element name="TControl.SetBiDiMode.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.SetParentBiDiMode" link="TControl.ParentBiDiMode"/>
      <element name="TControl.SetParentBiDiMode.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.SetParentFont" link="TControl.ParentFont"/>
      <element name="TControl.SetParentFont.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.ParentFontChanged">
        <short>
          <var>ParentFontChanged</var> - method for dealing with a change in the font of the parent</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.BiDiMode">
        <short>
          <var>BiDiMode</var> - enabling bi-directional writing</short>
        <descr>Allows Languages such as Arabic and Hebrew to be used
        </descr>
      </element>
      <element name="TControl.ParentBiDiMode">
        <short><var>ParentBiDiMode</var> - does the control follow the BiDiMode settings of its parent?</short>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.CMBiDiModeChanged">
        <short>Message handler for BiDi mode changed.</short>
      </element>
      <element name="TControl.CMBiDiModeChanged.Message">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.CMParentBiDiModeChanged">
        <short>Message handler for parent control's BiDi mode changed.</short>
      </element>
      <element name="TControl.CMParentBiDiModeChanged.Message">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.UseRightToLeftAlignment">
        <short>
          <var>UseRightToLeftAlignment</var> - as opposed to usual left to right</short>
        <descr>Needs <var>BiDiMode</var> enabled
        </descr>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.UseRightToLeftAlignment.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.UseRightToLeftReading">
        <short>
          <var>UseRightToLeftReading </var>- as opposed to usual left to right</short>
        <descr>Needs <var>BiDiMode</var> enabled</descr>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.UseRightToLeftReading.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.UseRightToLeftScrollBar">
        <short>
          <var>UseRightToLeftScrollBar</var> - as opposed to usual left to right</short>
        <descr>Needs <var>BiDiMode</var> enabled</descr>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.UseRightToLeftScrollBar.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.IsRightToLeft">
        <short>
          <var>IsRightToLeft</var> - as opposed to usual left to right</short>
        <descr>Needs <var>BiDiMode</var> enabled</descr>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.IsRightToLeft.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.BeginAutoSizing">
        <short>Sets AutoSizing=true, used to prevent loops.</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.EndAutoSizing">
        <short>End the autosizing process, reset AutoSizing to False.</short>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.IsAParentAligning">
        <short>Determine if a parent control is involved in the alignment process</short>
      </element>
      <element name="TControl.IsAParentAligning.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TControl.CheckMenuPopup">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.CheckMenuPopup.Result">
        <short/>
      </element>
      <element name="TControl.CheckMenuPopup.P">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.CheckOnChangeBounds">
        <short>Checks for changes and calls <var>DoOnChangeBounds</var>
        </short>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.DoBeforeMouseMessage">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.DoConstrainedResize">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.DoConstrainedResize.NewLeft">
        <short/>
      </element>
      <element name="TControl.DoConstrainedResize.NewTop">
        <short/>
      </element>
      <element name="TControl.DoConstrainedResize.NewWidth">
        <short/>
      </element>
      <element name="TControl.DoConstrainedResize.NewHeight">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.DoMouseDown">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.DoMouseDown.Message">
        <short/>
      </element>
      <element name="TControl.DoMouseDown.Button">
        <short/>
      </element>
      <element name="TControl.DoMouseDown.Shift">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.DoMouseUp">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.DoMouseUp.Message">
        <short/>
      </element>
      <element name="TControl.DoMouseUp.Button">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.SetAnchorSideIndex">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.SetAnchorSideIndex.Index">
        <short/>
      </element>
      <element name="TControl.SetAnchorSideIndex.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.SetBorderSpacing" link="TControl.BorderSpacing"/>
      <element name="TControl.SetBorderSpacing.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.SetBoundsRect" link="TControl.BoundsRect"/>
      <element name="TControl.SetBoundsRect.ARect">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.SetBoundsRectForNewParent" link="TControl.BoundsRectForNewParent"/>
      <element name="TControl.SetBoundsRectForNewParent.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.SetClientHeight" link="TControl.ClientHeight"/>
      <element name="TControl.SetClientHeight.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.SetClientSize" link="TControl.ClientRect"/>
      <element name="TControl.SetClientSize.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.SetClientWidth" link="TControl.ClientWidth"/>
      <element name="TControl.SetClientWidth.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.SetConstraints" link="TControl.Constraints"/>
      <element name="TControl.SetConstraints.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.SetCursor" link="TControl.Cursor"/>
      <element name="TControl.SetCursor.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.SetDesktopFont" link="TControl.DesktopFont"/>
      <element name="TControl.SetDesktopFont.AValue">
        <short></short>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.SetDragCursor" link="TControl.DragCursor"/>
      <element name="TControl.SetDragCursor.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.SetFont" link="TControl.Font"/>
      <element name="TControl.SetFont.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.SetHeight" link="TControl.Height"/>
      <element name="TControl.SetHeight.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.SetHelpContext" link="TControl.HelpContext"/>
      <element name="TControl.SetHelpContext.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.SetHelpKeyword" link="TControl.HelpKeyword"/>
      <element name="TControl.SetHelpKeyword.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.SetHostDockSite" link="TControl.HostDockSite"/>
      <element name="TControl.SetHostDockSite.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.SetLeft" link="TControl.Left"/>
      <element name="TControl.SetLeft.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.SetMouseCapture">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.SetMouseCapture.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.SetParentShowHint" link="TControl.ParentShowHint"/>
      <element name="TControl.SetParentShowHint.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.SetParentColor" link="TControl.ParentColor"/>
      <element name="TControl.SetParentColor.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.SetPopupMenu" link="TControl.PopupMenu"/>
      <element name="TControl.SetPopupMenu.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.SetShowHint" link="TControl.ShowHint"/>
      <element name="TControl.SetShowHint.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.SetText">
        <short>Sets the Text property.</short>
        <descr>Uses RealSetText instead of SetTextBuf, if possible.</descr>
        <seealso>
          <link id="#lcl.Controls.TControl.RealSetText">RealSetText</link>
          <link id="#lcl.Controls.TControl.SetTextBuf">SetTextBuf</link>
        </seealso>
      </element>
      <element name="TControl.SetText.Value">
        <short>The new Text</short>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.SetTop" link="TControl.Top"/>
      <element name="TControl.SetTop.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.SetVisible" link="TControl.Visible"/>
      <element name="TControl.SetVisible.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.SetWidth" link="TControl.Width"/>
      <element name="TControl.SetWidth.Value">
        <short/>
      </element>
      <!-- variable Visibility: protected -->
      <element name="TControl.FControlState">
        <short>Flags representing the state of the control.</short>
        <seealso>
          <link id="#lcl.Controls.TControlState"/>
        </seealso>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.AutoSizing">
        <short>Is autosizing in progress?</short>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.AutoSizingAll">
        <short>set in DoAllAutoSize</short>
        <descr>
        </descr>
        <seealso>
        </seealso>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.AutoSizingLockCount">
        <short></short>
        <descr>
        </descr>
        <seealso>
        </seealso>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DoAutoSize">
        <short>
          <var>DoAutoSize </var>- method for actually performing the AutoSize</short>
        <descr>
          <p>IMPORTANT: Many Delphi controls override this method and many call this method directly after setting some properties.</p>
          <p>During handle creation not all interfaces can create complete Device Contexts which are needed to calculate things like text size.</p>
          <p>That's why you should always call <link id="#lcl.Controls.TControl.AdjustSize">AdjustSize</link> instead of <var>DoAutoSize</var>.</p>
        </descr>
        <seealso>
          <link id="#lcl.Controls.AutoSize">AutoSize topic</link>
          <link id="#lcl.Controls.TControl.AdjustSize">TControl.AdjustSize</link>
        </seealso>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.AutoSizeCanStart">
        <short>
          <var>AutoSizeCanStart</var> - checks whether 
          <var>DoAutoSize</var> is permitted to start</short>
        <descr>
          <pre>Returns true if DoAutoSize can start. That means, it tests the minimum
  requirements to start. Some controls need even more.

  It returns false if
  - AutoSize=false
  - or the control is currently autosizing
  - or the control is in design state (csDesigning) and is not a top level control (form, frame)
  - or the control is not visible
  - or the control is destroying
</pre>
        </descr>
      </element>
      <element name="TControl.AutoSizeCanStart.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.AnchorSideChanged">
        <short>Procedure invoked when the anchor side is changed</short>
      </element>
      <element name="TControl.AnchorSideChanged.TheAnchorSide">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.ForeignAnchorSideChanged">
        <short>Procedure invoked when the anchor side of a different control (not the current) is changed</short>
      </element>
      <element name="TControl.ForeignAnchorSideChanged.TheAnchorSide">
        <short/>
      </element>
      <element name="TControl.ForeignAnchorSideChanged.Operation">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.HeightIsAnchored">
        <short></short>
        <descr>
        </descr>
        <errors>
        </errors>
        <seealso>
        </seealso>
      </element>
      <element name="TControl.HeightIsAnchored.Result">
        <short></short>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.WidthIsAnchored">
        <short></short>
        <descr>
        </descr>
        <errors>
        </errors>
        <seealso>
        </seealso>
      </element>
      <element name="TControl.WidthIsAnchored.Result">
        <short></short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.SetAlign" link="TControl.Align"/>
      <element name="TControl.SetAlign.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.UpdateAlignIndex">
        <short>[?]</short>
        <descr>
        </descr>
        <errors>
        </errors>
        <seealso>
        </seealso>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.SetAnchors" link="TControl.Anchors"/>
      <element name="TControl.SetAnchors.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.SetAutoSize" link="TControl.AutoSize"/>
      <element name="TControl.SetAutoSize.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.BoundsChanged">
        <short>Procedure invoked when the bounds of the control have been changed.</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DoConstraintsChange">
        <short>Procedure to execute a change in the control's constraints</short>
      <element name="TControl.DoConstraintsChange.Sender">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DoBorderSpacingChange">
        <short>Procedure to execute a change in the control's border spacing</short>
      </element>
      <element name="TControl.DoBorderSpacingChange.Sender">
        <short/>
      </element>
      <element name="TControl.DoBorderSpacingChange.InnerSpaceChanged">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.SendMoveSizeMessages">
        <short>Send a message to the system if the size and/or position of the control change</short>
      </element>
      <element name="TControl.SendMoveSizeMessages.SizeChanged">
        <short/>
      </element>
      <element name="TControl.SendMoveSizeMessages.PosChanged">
        <short/>
      </element>
      <element name="TControl.ConstrainedResize">
        <short>Procedure for performing a resize within defined boundaries (constraints)</short>
      </element>
      <element name="TControl.ConstrainedResize.MinWidth">
        <short/>
      </element>
      <element name="TControl.ConstrainedResize.MinHeight">
        <short/>
      </element>
      <element name="TControl.ConstrainedResize.MaxWidth">
        <short/>
      </element>
      <element name="TControl.ConstrainedResize.MaxHeight">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.CalculatePreferredSize">
        <short>
          <var>CalculatePreferredSize</var> - returns the preferred height and width.</short>
        <descr>
          <p>Calculates the preferred width and height for a control, which is used
  by the LCL autosizing algorithms as default size. Negative or 0 are treated as undefined and the LCL uses other sizes
  instead.</p>
          <p>
            <var>TWinControl</var>
 overrides this and asks the interface for theme dependent values.
  See 
            <link id="#lcl.Controls.TWinControl.CalculatePreferredSize">TWinControl.CalculatePreferredSize</link> for more information.</p>
          <p>WithThemeSpace: If true, adds space for stacking.</p>
          <p>For example: <var>TRadioButton</var> has a minimum size. But for stacking multiple TRadioButtons there should be
  some space around. This space is theme dependent, so the parameter is passed to the widgetset.</p>
        </descr>
      </element>
      <element name="TControl.CalculatePreferredSize.PreferredWidth">
        <short/>
      </element>
      <element name="TControl.CalculatePreferredSize.PreferredHeight">
        <short/>
      </element>
      <element name="TControl.CalculatePreferredSize.WithThemeSpace">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DoAllAutoSize">
        <short>[?]</short>
        <descr>
        </descr>
        <errors>
        </errors>
        <seealso>
        </seealso>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DoOnResize">
        <short>Calls <var>OnResize</var>
        </short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DoOnChangeBounds">
        <short>Calls the <var>OnChangeBounds</var> event handler</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.Resize">
        <short>Checks for changes and calls <var>DoOnResize</var>
        </short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.RequestAlign">
        <short>Smart calling <var>Parent.AlignControls</var>
        </short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.UpdateBaseBounds">
        <short>Update the basic boundaries of the control - essential if there has been a lot of re-sizing</short>
      </element>
      <element name="TControl.UpdateBaseBounds.StoreBounds">
        <short/>
      </element>
      <element name="TControl.UpdateBaseBounds.StoreParentClientSize">
        <short/>
      </element>
      <element name="TControl.UpdateBaseBounds.UseLoadedValues">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.LockBaseBounds">
        <short>Lock the base bounds, so that they do not change even if surrounding controls are changed</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.UnlockBaseBounds">
        <short>Unlock the base bounds so that they are free to change as surrounding controls are changed</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.UpdateAnchorRules">
        <short>Update the rules for anchoring the control</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.ChangeBounds">
        <short>Sets the bounds (left, top, height, width) optionally the BaseBounds of the control.</short>
        <descr>ChangeBounds is called whenever the position or size of the control is set, either via the properties or by the layouter of the LCL. SetBounds calls internally ChangeBounds with KeepBase=false, while the LCL layouter calls it with KeepBase=true. Override this for code that might change the preferred size or resizes other controls. Keep in mind that the given aLeft, aTop, aWidth, aHeight might not be valid and will be changed by the LCL before applied. You can call this function in your custom controls. </descr>
      </element>
      <element name="TControl.ChangeBounds.ALeft">
        <short/>
      </element>
      <element name="TControl.ChangeBounds.ATop">
        <short/>
      </element>
      <element name="TControl.ChangeBounds.AWidth">
        <short/>
      </element>
      <element name="TControl.ChangeBounds.AHeight">
        <short/>
      </element>
      <element name="TControl.ChangeBounds.KeepBase">
        <short>[?]</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DoSetBounds">
        <short>Perform the actual setting of the boundary rectangle.</short>
        <descr>DoSetBounds is a low level function to set the private variables FLeft, FTop, FWidth, FHeight.
          Do not call this function, only the LCL calls it.
          It also updates FClientWidth and FClientHeight accordingly.
          Override this to update the content layout of the control, for example scroll bars.
          As always: do not paint here, but call Invalidate and paint in OnPaint or override Paint. </descr>
      </element>
      <element name="TControl.DoSetBounds.ALeft">
        <short/>
      </element>
      <element name="TControl.DoSetBounds.ATop">
        <short/>
      </element>
      <element name="TControl.DoSetBounds.AWidth">
        <short/>
      </element>
      <element name="TControl.DoSetBounds.AHeight">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.ChangeScale">
        <short>Change the scale factor (multiplier and divider) for drawing the control.</short>
      </element>
      <element name="TControl.ChangeScale.Multiplier">
        <short/>
      </element>
      <element name="TControl.ChangeScale.Divider">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.ScaleConstraints">
        <short>Scale the minimum and maximum Width and Height.</short>
        <descr>
        </descr>
        <errors>
        </errors>
        <seealso>
        </seealso>
      </element>
      <element name="TControl.ScaleConstraints.Multiplier">
        <short></short>
      </element>
      <element name="TControl.ScaleConstraints.Divider">
        <short></short>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.CanAutoSize">
        <short>Function to determine if autosizing is possible, and if so, gets the new width and height</short>
      </element>
      <element name="TControl.CanAutoSize.Result">
        <short/>
      </element>
      <element name="TControl.CanAutoSize.NewWidth">
        <short/>
      </element>
      <element name="TControl.CanAutoSize.NewHeight">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.GetClientOrigin" link="TControl.ClientOrigin"/>
      <element name="TControl.GetClientOrigin.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.GetClientRect" link="TControl.ClientRect"/>
        <short>Visual size of the client area.</short>
      </element>
      <element name="TControl.GetClientRect.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.GetLogicalClientRect">
        <short>Logical client area, can be bigger than the visible client area.</short>
        <descr>A TScrollingWinControl has a logical client area, of which only a portion can be visible.
          The origin always is (0,0), regardless of an ScrollOffset.</descr>
        <seealso>
          <link id="TControl.BoundsRect"/>
          <link id="TControl.ClientRect"/>
          <link id="TControl.GetScrolledClientRect"/>
        </seealso>
      </element>
      <element name="TControl.GetLogicalClientRect.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.GetScrolledClientRect">
        <short>Get the visible part of the logical client area.</short>
        <descr>
          <p>Includes the ScrollOffset in a TScrollingWinControl Parent.</p>
          <p>TControl: When the Parent is a TScrollingWinControl, the ClientRect is offset by it's ScrollOffset.
            This Rect can be intersected with the visible ClientArea of the Parent, to get the really visible part of the control.
          </p>
          <p>TWinControl: The visible ClientRect is offset by ScrollOffset, to reflect the visible part of the logical ClientRect.
          </p>
        </descr>
      </element>
      <element name="TControl.GetScrolledClientRect.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.GetChildsRect">
        <short>Get the visible part of a possibly scrolled client area.</short>
        <descr>If <var>Scrolled</var> is False, the ScrollOffset is ignored, so that the ClientRect is returned.
        </descr>
      </element>
      <element name="TControl.GetChildsRect.Result">
        <short>The visible part of the client area.</short>
      </element>
      <element name="TControl.GetChildsRect.Scrolled">
        <short>True forces scrolling taken into account.</short>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.GetClientScrollOffset">
        <short>Returns the offset of the scrolled client area (in a scrolling TWinControl).</short>
      </element>
      <element name="TControl.GetClientScrollOffset.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.GetControlOrigin" link="TControl.ControlOrigin">
        <short>Returns the origin (top left pixel) of the control in screen coordinates.</short>
      </element>
      <element name="TControl.GetControlOrigin.Result">
        <short/>
      </element>
      <element name="TControl.WMCancelMode">
        <short>Message handler for
          cancel mode request.
        </short>
      </element>
      <element name="TControl.WMCancelMode.Message">
        <short></short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMContextMenu">
        <short>Protected messages to system - when context menu is required</short>
      </element>
      <element name="TControl.WMContextMenu.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMLButtonDown">
        <short>Message handler for
          left mouse button going down.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.WMLButtonDown.Message">
        <short/>
      </element>
      <element name="TControl.WMRButtonDown">
        <short>Message handler for
          right mouse button going down.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.WMRButtonDown.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMMButtonDown">
        <short>Message handler for
          middle mouse button going down.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.WMMButtonDown.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMLButtonDBLCLK">
        <short>Message handler for
          left mouse button double click.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.WMLButtonDBLCLK.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMRButtonDBLCLK">
        <short>Message handler for
          right mouse button double click.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.WMRButtonDBLCLK.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMMButtonDBLCLK">
        <short>Message handler for
          middle mouse button double click.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.WMMButtonDBLCLK.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMLButtonTripleCLK">
        <short>Message handler for
          left mouse button triple click.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.WMLButtonTripleCLK.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMRButtonTripleCLK">
        <short>Message handler for
          right mouse button triple click.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.WMRButtonTripleCLK.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMMButtonTripleCLK">
        <short>Message handler for
          middle mouse button triple click.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.WMMButtonTripleCLK.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMLButtonQuadCLK">
        <short>Message handler for
          left mouse button quadruple click.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.WMLButtonQuadCLK.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMRButtonQuadCLK">
        <short>Message handler for
          right mouse button quadruple click.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.WMRButtonQuadCLK.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMMButtonQuadCLK">
        <short>Message handler for
          middle mouse button quadruple click.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.WMMButtonQuadCLK.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMXButtonDown">
        <short>Message handler for
          extra mouse button going down.
        </short>
        <descr>
        </descr>
        <errors>
        </errors>
        <seealso>
        </seealso>
      </element>
      <element name="TControl.WMXButtonDown.Message">
        <short></short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMXButtonDBLCLK">
        <short>Message handler for
          extra mouse button double click.
        </short>
        <descr>
        </descr>
        <errors>
        </errors>
        <seealso>
        </seealso>
      </element>
      <element name="TControl.WMXButtonDBLCLK.Message">
        <short></short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMXButtonTripleCLK">
        <short>Message handler for
          extra mouse button triple click.
        </short>
        <descr>
        </descr>
        <errors>
        </errors>
        <seealso>
        </seealso>
      </element>
      <element name="TControl.WMXButtonTripleCLK.Message">
        <short></short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMXButtonQuadCLK">
        <short>Message handler for
          extra mouse button quadruple click.
        </short>
        <descr>
        </descr>
        <errors>
        </errors>
        <seealso>
        </seealso>
      </element>
      <element name="TControl.WMXButtonQuadCLK.Message">
        <short></short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMXButtonUp">
        <short>Message handler for
          extra mouse button going up.
        </short>
        <descr>
        </descr>
        <errors>
        </errors>
        <seealso>
        </seealso>
      </element>
      <element name="TControl.WMXButtonUp.Message">
        <short></short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMMouseMove">
        <short>Message handler for
          mouse moved.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.WMMouseMove.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMLButtonUp">
        <short>Message handler for
          left mouse button going up.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.WMLButtonUp.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMRButtonUp">
        <short>Message handler for
          right mouse button going up.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.WMRButtonUp.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMMButtonUp">
        <short>Message handler for
          middle mouse button going up.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.WMMButtonUp.Message">
        <short/>
      </element>
      <element name="TControl.WSRegisterClass" link="#LCL.LCLClasses.TLCLComponent.WSRegisterClass"/>
      <element name="TControl.OnMouseWheel">
        <short>
          <var>OnMouseWheel</var> - event handler for a movement of the mouse wheel</short>
      </element>
      <element name="TControl.OnMouseWheelDown">
        <short>
          <var>OnMouseWheelDown</var> - event handler for downward movement of mouse wheel</short>
      </element>
      <element name="TControl.OnMouseWheelUp">
        <short>
          <var>OnMouseWheelUp</var> - event handler for upward movement of mouse wheel</short>
      </element>
      <element name="TControl.WMMouseWheel">
        <short>Protected message to system - when mouse wheel moves</short>
      </element>
      <element name="TControl.WMMouseWheel.Message">
        <short></short>
      </element>
      <element name="TControl.DoMouseWheel">
        <short>
          <var>DoMouseWheel</var> - performs the action to deal with a movement of the mouse wheel; returns True if handled</short>
      </element>
      <element name="TControl.DoMouseWheel.Result">
        <short></short>
      </element>
      <element name="TControl.DoMouseWheel.Shift">
        <short></short>
      </element>
      <element name="TControl.DoMouseWheel.WheelDelta">
        <short></short>
      </element>
      <element name="TControl.DoMouseWheel.MousePos">
        <short></short>
      </element>
      <element name="TControl.DoMouseWheelDown">
        <short>
          <var>DoMouseWheelDown</var> - performs the action for a downward movement[button down?] of the mouse wheel; returns True if handled</short>
      </element>
      <element name="TControl.DoMouseWheelDown.Result">
        <short></short>
      </element>
      <element name="TControl.DoMouseWheelDown.Shift">
        <short></short>
      </element>
      <element name="TControl.DoMouseWheelDown.MousePos">
        <short></short>
      </element>
      <element name="TControl.DoMouseWheelUp">
        <short>
          <var>DoMouseWheelUp</var> - performs the action for an upward movement[?] of the mouse wheel; returns True if handled</short>
      </element>
      <element name="TControl.DoMouseWheelUp.Result">
        <short></short>
      </element>
      <element name="TControl.DoMouseWheelUp.Shift">
        <short></short>
      </element>
      <element name="TControl.DoMouseWheelUp.MousePos">
        <short></short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMDragStart">
        <short>Message handler for
          [?]
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.WMDragStart.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMMove">
        <short>Message handler for
          control moved.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.WMMove.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMSize">
        <short>Message handler for
          changed control size.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.WMSize.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMWindowPosChanged">
        <short>Message handler for
          changed control position.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.WMWindowPosChanged.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.LMCaptureChanged">
        <short>Message handler for
          changed capture.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.LMCaptureChanged.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.CMCursorChanged">
        <short>Message handler for
          changed cursor[?].
        </short>
        <descr>
        </descr>
        <errors>
        </errors>
        <seealso>
        </seealso>
      </element>
      <element name="TControl.CMCursorChanged.Message">
        <short></short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.CMEnabledChanged">
        <short>Message handler for
          changed Enabled state.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.CMEnabledChanged.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.CMHitTest">
        <short>Message handler for
          hit test.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.CMHitTest.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.CMMouseEnter">
        <short>Message handler for
          mouse enters the control.
        </short>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.CMMouseEnter.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.CMMouseLeave">
        <short>Message handler for
          mouse leaving the control.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.CMMouseLeave.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.CMHintShow">
        <short>Message handler for
          hint display.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.CMHintShow.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.CMSysFontChanged">
        <short>Message handler for
          changed system Font.
        </short>
        <descr>
        </descr>
        <errors>
        </errors>
        <seealso>
        </seealso>
      </element>
      <element name="TControl.CMSysFontChanged.Message">
        <short></short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.CMParentFontChanged">
        <short>Message handler for
          changed parent Font.
        </short>
        <descr>
        </descr>
        <errors>
        </errors>
        <seealso>
        </seealso>
      </element>
      <element name="TControl.CMParentFontChanged.Message">
        <short></short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.CMParentColorChanged">
        <short>Message handler for
          changed Color.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.CMParentColorChanged.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.CMParentShowHintChanged">
        <short>Message handler for
          changed ShowHint.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.CMParentShowHintChanged.Message">
        <short>Message handler for
          changed ShowHint.
        </short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.CMTextChanged">
        <short>Message handler for control's Text changed.</short>
      </element>
      <element name="TControl.CMTextChanged.Message">
        <short/>
      </element>
      <element name="TControl.CMWantSpecialKey">
        <short>Message handler for
          special character (TAB...).
        </short>
      </element>
      <element name="TControl.CMWantSpecialKey.Message">
        <short></short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.CMVisibleChanged">
        <short>Message handler for
          changed visibility.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.CMVisibleChanged.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.CalculateDockSizes">
        <short>Saves the docked and undocked extent of the control.</short>
        <descr>
          <p>In floating state sets UndockWidth/Height to the current Width/Height.</p>
          <p>In docked state sets LRDockWidth/TBDockHeight to the current Width/Height.</p>
          <remark>[Note: should save both in any case, independent from DockOrientation or host Align.
Rationale: a DockManager will either ignore these values, or use them according to the *new* alignment.
Without a DockManager both extents are required, because no (valid) alignment information applies.]</remark>
        </descr>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.GetDragImages">
        <short>Get the list of Images to be dragged - returned as a list</short>
      </element>
      <element name="TControl.GetDragImages.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DoFloatMsg">
        <short>Handler called when the control starts floating.</short>
        <descr>
          <p>Since TControls cannot float for themselves, a FloatHost site is created and the control is docked into it.</p>
          <p>When the control already has a Parent (FloatHost site), the Parent's position and extent is adjusted to fit the DockRect as its ClientRect</p>
        </descr>
      </element>
      <element name="TControl.DoFloatMsg.ADockSource">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.GetDefaultDockCaption">
        <short>Returns the default string for the dock caption, control's Name.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.GetDefaultDockCaption.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.CreateFloatingDockSite">
        <short>Create a floating dock site within the Bounds specified as an argument</short>
      </element>
      <element name="TControl.CreateFloatingDockSite.Result">
        <short/>
      </element>
      <element name="TControl.CreateFloatingDockSite.Bounds">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.GetDockEdge">
        <short>Find out which edge is used for docking (returned in Result)</short>
      </element>
      <element name="TControl.GetDockEdge.Result">
        <short/>
      </element>
      <element name="TControl.GetDockEdge.MousePos">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.GetFloating">
        <short>Guess whether the control is floating.</short>
        <descr>Floating state is assumed when the control has a HostDockSite of FloatingDockSiteClass, and is the only docked client.</descr>
      </element>
      <element name="TControl.GetFloating.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.GetFloatingDockSiteClass">
        <short>Returns the class for a floating host dock site</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.GetFloatingDockSiteClass.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.BeginAutoDrag">
        <short>Start the AutoDrag process.</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DefaultDockImage">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.DefaultDockImage.DragDockObject">
        <short/>
      </element>
      <element name="TControl.DefaultDockImage.Erase">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DockTrackNoTarget">
        <short>Adjust the DockRect for floating state (not over a DockSite)</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.DockTrackNoTarget.Source">
        <short/>
      </element>
      <element name="TControl.DockTrackNoTarget.X">
        <short/>
      </element>
      <element name="TControl.DockTrackNoTarget.Y">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DoDock">
        <short>Adjust the control's position and extent for the new docksite.</short>
        <descr>
          <p>If NewDockSite=Nil, Parent is set to Nil (in preparation of floating the control).</p>
          <p>Otherwise ARect is adjusted to fit into the logical ClientRect of the NewDockSite. The origin is adjusted according to Align[??? should be DropAlign!], so that the control sits at the according side of the NewDockSite.</p>
          <p>Finally the computed coordinates are stored, in BoundsRectForNewParent when the NewDockSite differs from Parent, else in BoundsRect.</p>
          <p>ARect is the perfect BoundsRect for the control, in screen coordinates when it becomes floating, or in client coordinates of the target docksite.</p>
        </descr>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.DoDock.NewDockSite">
        <short/>
      </element>
      <element name="TControl.DoDock.ARect">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DoDragMsg">
        <short>Handler for a drag message, sent by the DragManager</short>
        <descr>
          <ul>
            <li>On dmFindTarget: return Self for the DropOnControl.</li>
            <li>On dmDragEnter/Leave/Move: invokes DragOver or, if docking, the target.DockOver.
              Result indicates acceptance of an drop.</li>
            <li>On dmDragDrop: invokes DragDrop or, if docking, the target.DockDrop.</li>
          </ul>
          <p>Sender is the DragDockObject when docking.
            Else if the DragObject has been AutoCreated, the dragged control is passed to DragOver as the Sender; otherwise the DragObject itself is passed as Sender.
          </p>
        </descr>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.DoDragMsg.Result">
        <short/>
      </element>
      <element name="TControl.DoDragMsg.ADragMessage">
        <short/>
      </element>
      <element name="TControl.DoDragMsg.APosition">
        <short/>
      </element>
      <element name="TControl.DoDragMsg.ADragObject">
        <short/>
      </element>
      <element name="TControl.DoDragMsg.ATarget">
        <short/>
      </element>
      <element name="TControl.DoDragMsg.ADocking">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DoEndDock">
        <short>Invokes the OnEndDock handler</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.DoEndDock.Target">
        <short/>
      </element>
      <element name="TControl.DoEndDock.X">
        <short/>
      </element>
      <element name="TControl.DoEndDock.Y">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DoEndDrag">
        <short>Invokes the OnEndDrag handler</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.DoEndDrag.Target">
        <short/>
      </element>
      <element name="TControl.DoEndDrag.X">
        <short/>
      </element>
      <element name="TControl.DoEndDrag.Y">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DoStartDock">
        <short>Invokes the OnStartDock handler</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.DoStartDock.DragObject">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DoStartDrag">
        <short>Invokes the OnStartDrag handler</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.DoStartDrag.DragObject">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DragCanceled">
        <short>
          <var>DragCanceled</var> - handler for a canceld drag.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DragOver">
        <short>Determines whether a drop is acceptable, using the OnDragOver handler.</short>
        <descr>
          <p>An OnDragOver handler is required, or any drop will be rejected (Accept becomes False).</p>
          <p>When an OnDragOver handler is installed, Accept is set to True and can be changed by the handler.</p>
          <remark>Caution: Sender can be either a TDragObject, or the dragged control.</remark>
        </descr>
        <seealso>
          <link id="TControl.OnDragOver"/>
        </seealso>
      </element>
      <element name="TControl.DragOver.Source">
        <short/>
      </element>
      <element name="TControl.DragOver.X">
        <short/>
      </element>
      <element name="TControl.DragOver.Y">
        <short/>
      </element>
      <element name="TControl.DragOver.State">
        <short/>
      </element>
      <element name="TControl.DragOver.Accept">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DrawDragDockImage">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.DrawDragDockImage.DragDockObject">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.EraseDragDockImage">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.EraseDragDockImage.DragDockObject">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.PositionDockRect">
        <short>Get the DockRect for an drop.</short>
        <descr>Either calls the DockManager.PositionDockRect of the target site, or DragDockObject.AdjustDockRect after moving the undocked control rectangle to the DragPos.
          AdjustDockRect takes the hotspot of the DockRect into account.</descr>
        <errors/>
        <seealso>
          <link id="TDragDockObject.AdjustDockRect"/>
        </seealso>
      </element>
      <element name="TControl.PositionDockRect.DragDockObject">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.SetDragMode">
        <short>
          <var>SetDragMode</var> - specify the mode for dragging</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.SetDragMode.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.Click">
        <short>Invokes the
          <link id="#lcl.Controls.TControl.OnClick">OnClick</link>
          handler.</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DblClick">
        <short>Invokes the
          <link id="#lcl.Controls.TControl.OnDblClick">OnDblClick</link>
          handler.</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.TripleClick">
        <short>Invokes the
          <link id="#lcl.Controls.TControl.OnTripleClick">OnTripleClick</link>
          handler.</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.QuadClick">
        <short>Invokes the
          <link id="#lcl.Controls.TControl.OnQuadClick">OnQuadClick</link>
          handler.</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.MouseDown">
        <short>Handler for MouseDown events.</short>
        <descr>
          <p>Called by the MouseDown message handler.
            Handles Focus changes.
            Notifies the DragManager while dragging [for what purpose???].
            Finally calls the <link id="#lcl.Controls.TControl.OnMouseDown"/> handler.</p>
          <p>
            <var>X, Y</var> is the mouse position in client coordinates.</p>
        </descr>
      </element>
      <element name="TControl.MouseDown.Button">
        <short>which buttons are down</short>
      </element>
      <element name="TControl.MouseDown.Shift">
        <short>which of Ctrl, Shift or Alt keys are also pressed</short>
      </element>
      <element name="TControl.MouseDown.X">
        <short/>
      </element>
      <element name="TControl.MouseDown.Y">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.MouseMove">
        <short>Handler for MouseMove events.</short>
        <descr>
          <p>Called by the MouseMove message handler.
            The DragManager is notified while the control is being dragged.
            Finally the <link id="#lcl.Controls.TControl.OnMouseMove">OnMouseMove</link> handler is invoked.</p>
          <p>
            <var>X, Y</var> is the mouse position in client coordinates.</p>
        </descr>
      </element>
      <element name="TControl.MouseMove.Shift">
        <short>The currently pressed mouse buttons and modifier keys.
        </short>
      </element>
      <element name="TControl.MouseMove.X">
        <short/>
      </element>
      <element name="TControl.MouseMove.Y">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.MouseUp">
        <short>
          <var>MouseUp</var> invokes the 
          <link id="#lcl.Controls.TControl.OnMouseUp">OnMouseUp</link> handler.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.MouseUp.Button">
        <short/>
      </element>
      <element name="TControl.MouseUp.Shift">
        <short/>
      </element>
      <element name="TControl.MouseUp.X">
        <short/>
      </element>
      <element name="TControl.MouseUp.Y">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.MouseEnter">
        <short>
          <var>MouseEnter</var> invokes the 
          <link id="#lcl.Controls.TControl.OnMouseEnter">OnMouseEnter</link> handler.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.MouseLeave">
        <short>
          <var>MouseLeave</var> invokes the 
          <link id="#lcl.Controls.TControl.OnMouseLeave">OnMouseLeave</link> handler.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.DialogChar">
        <short>
          <var>DialogChar</var> - checks whether Message is a dialog message.[?]</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.DialogChar.Result">
        <short/>
      </element>
      <element name="TControl.DialogChar.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.Changed">
        <short>
          <var>Changed</var> - method to signal that a change has occured</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.GetPalette">
        <short>
          <var>GetPalette</var> - returns a handle to the palette for this control</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.GetPalette.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.ChildClassAllowed">
        <short>
          <var>ChildClassAllowed</var> - returns True if the specified class is allowed to be a child of this class</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.ChildClassAllowed.Result">
        <short/>
      </element>
      <element name="TControl.ChildClassAllowed.ChildClass">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.ReadState" link="#rtl.Classes.TComponent.ReadState"/>
      <element name="TControl.ReadState.Reader">
        <short></short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.Loaded" link="#rtl.Classes.TComponent.Loaded"/>
      <!-- procedure Visibility: protected -->
      <element name="TControl.LoadedAll">
        <short>[?]</short>
        <descr>
        </descr>
        <errors>
        </errors>
        <seealso>
        </seealso>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DefineProperties">
        <short>Defines which non-published properties should be streamed (none here).</short>
        <seealso>
          <link id="#rtl.Classes.TComponent.DefineProperties">TComponent.DefineProperties</link>
          <link id="#rtl.Classes.TPersistent.DefineProperties">TPersistent.DefineProperties</link>
        </seealso>
      </element>
      <element name="TControl.DefineProperties.Filer">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.AssignTo">
        <short/>
        <descr>
          <p>Implements the assignment to an Action object, otherwise calls the inherited method.
          </p>
          <p>The copied properties are:</p>
          <ul>
            <li>Enabled</li>
            <li>Hint</li>
            <li>Caption</li>
            <li>Visible</li>
            <li>OnExecute (copied to OnClick)</li>
            <li>HelpContext</li>
            <li>HelpKeyword</li>
            <li>HelpType</li>
          </ul>
        </descr>
        <seealso>
          <link id="#rtl.Classes.TPersistent.AssignTo"/>
        </seealso>
      </element>
      <element name="TControl.AssignTo.Dest">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.InvalidateControl">
        <short>Request a repaint of the control.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.InvalidateControl.CtrlIsVisible">
        <short/>
      </element>
      <element name="TControl.InvalidateControl.CtrlIsOpaque">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.InvalidateControl">
        <short>Request a repaint of the control.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.InvalidateControl.CtrlIsVisible">
        <short/>
      </element>
      <element name="TControl.InvalidateControl.CtrlIsOpaque">
        <short/>
      </element>
      <element name="TControl.InvalidateControl.IgnoreWinControls">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.FontChanged">
        <short>
          <var>FontChanged</var> - handles an change of the Font property.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.FontChanged.Sender">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.GetAction">
        <short>Returns the Action property.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.GetAction.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.RealGetText">
        <short>Returns the Caption property.</short>
        <descr>This method is called by <var>GetText</var>, when GetTextBuf is not overridden.</descr>
        <seealso>
          <link id="#lcl.Controls.TControl.GetTextBuf">GetTextBuf</link>
          <link id="#lcl.Controls.TControl.RealSetText">RealSetText</link>
          <link id="#lcl.Controls.TControl.SetTextBuf">SetTextBuf</link>
        </seealso>
      </element>
      <element name="TControl.RealGetText.Result">
        <short>The Caption property.</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.RealSetText">
        <short>Sets the Caption property.</short>
        <descr>This method is called by <var>SetText</var>, when SetTextBuf is not overridden.</descr>
        <seealso>
          <link id="#lcl.Controls.TControl.SetTextBuf">SetTextBuf</link>
          <link id="#lcl.Controls.TControl.RealGetText">RealGetText</link>
          <link id="#lcl.Controls.TControl.GetTextBuf">GetTextBuf</link>
        </seealso>
      </element>
      <element name="TControl.RealSetText.Value">
        <short>The text-string that is to be stored</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.TextChanged">
        <short>Procedure to deal with changes in text</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.GetCachedText">
        <short>
          <var>GetCachedText</var> - method for retrieving caption text from cache; returns True if successful</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.GetCachedText.Result">
        <short/>
      </element>
      <element name="TControl.GetCachedText.CachedText">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.SetAction">
        <short>Set up the action to be associated with this control</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.SetAction.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.SetColor">
        <short>Set up the color to be used by the control</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.SetColor.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.SetEnabled">
        <short>Set up the flag to determine whether the control is to be enabled</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.SetEnabled.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.SetHint">
        <short>Set up the hinting pop-up for this control</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.SetHint.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.SetName">
        <short>Set the name of the control</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.SetName.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.SetParent">
        <short>Sets the Parent property.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.SetParent.NewParent">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.SetParentComponent">
        <short>Sets the Parent property, if NewParentCompnent is a TWinControl</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.SetParentComponent.NewParentComponent">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WndProc">
        <short>The general message handler for this control.</short>
        <descr>Preprocesses several messages, then calls Dispatch to invoke the applicable message handler.</descr>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.WndProc.TheMessage">
        <short>The message to handle.</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.ParentFormHandleInitialized">
        <short>
          <var>ParentFormHandleInitialized</var> - called by 
          <var>ChildHandlesCreated</var> of parent form</short>
        <descr>
          <p>Functions like GetTextWidth require valid widgets and their device contexts.
            That's why AdjustSize delays AutoSizing till this moment.</p>
        </descr>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.CaptureChanged">
        <short>Handler for mouse capture moved to a different control.</short>
        <descr>Notifies the DragManager of the changed capture control, to stop dragging this control.
          A very dangerous implementation, that can cause immediate abort of dragging before dragging really starts.
        </descr>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.Notification">
        <short>Notification handler for insertion or deletion of components.</short>
        <descr>
          <p>First the inherited <link id="TComponent.Notification"/> is invoked,
            to notify all attached notification handlers.</p>
          <p>If Operation is removal, additional actions are performed, depending on AComponent:<br/>
            PopupMenu, Action, or anchors to the removed control are detached.</p>
        </descr>
        <seealso>
          <link id="#rtl.Classes.TComponent.Notification"/>
        </seealso>
      </element>
      <element name="TControl.Notification.AComponent">
        <short>The component being inserted or removed.</short>
      </element>
      <element name="TControl.Notification.Operation">
        <short>The action (opInsert or opRemove).</short>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.CanTab">
        <short>
          <var>CanTab</var> - if True, the Tab key can be used to navigate to this control.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.CanTab.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.GetDeviceContext">
        <short>Returns a device context handle for the control.
        </short>
        <descr>Initializes the device context position to the control origin,
          and shrinks its clipping rectangle to the control bounds.
        </descr>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.GetDeviceContext.Result">
        <short>The device context.</short>
      </element>
      <element name="TControl.GetDeviceContext.WindowHandle">
        <short>Returns the window of the device context.</short>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.GetEnabled">
        <short>Returns the <var>Enabled</var> status.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.GetEnabled.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.GetPopupMenu">
        <short>
          <var>GetPopupMenu</var> - returns the popup menu for this control.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.GetPopupMenu.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DoOnParentHandleDestruction">
        <short>[?]</short>
        <descr>
        </descr>
        <errors>
        </errors>
        <seealso>
        </seealso>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DoOnShowHint">
        <short>Invokes the <var>OnShowHint</var> event handler.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.DoOnShowHint.HintInfo">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.VisibleChanging">
        <short>Invokes all <var>OnVisibleChanging</var> handlers.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.AddHandler">
        <short>Adds an notification handler.</short>
        <descr>Notification handlers allow to notify other components of certain events.
          When the registered event occurs, all installed (added) handlers are invoked.
        </descr>
      </element>
      <element name="TControl.AddHandler.HandlerType">
        <short>Type of the event.</short>
      </element>
      <element name="TControl.AddHandler.AMethod">
        <short>The handler to be added.</short>
      </element>
      <element name="TControl.AddHandler.AsFirst">
        <short>Unused. [If true, the handler is added before all installed handlers?]</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.RemoveHandler">
        <short>Removes the given notification handler.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.RemoveHandler.HandlerType">
        <short>Type of the notification.</short>
      </element>
      <element name="TControl.RemoveHandler.AMethod">
        <short>The handler to be removed.</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DoContextPopup">
        <short>Invokes the OnContextPopup handler.</short>
        <descr>The handler can show and handle the menu selection itself.
          If so, it should set Handled to True.
          [to be moved into OnContextPopup]
        </descr>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.DoContextPopup.MousePos">
        <short>Mouse position, used to place the menu.</short>
      </element>
      <element name="TControl.DoContextPopup.Handled">
        <short>To be set by the handler, when it has handled the menu display and selection.</short>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.GetActionLinkClass">
        <short>
          <var>GetActionLinkClass</var> - returns the default Action class.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.GetActionLinkClass.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.ActionChange">
        <short>Handler for a changed Action.</short>
        <descr>Several properties are copied from the new Action.</descr>
      </element>
      <element name="TControl.ActionChange.Sender">
        <short>The changed Action.</short>
      </element>
      <element name="TControl.ActionChange.CheckDefaults">
        <short>When True, forces update of all properties. Otherwise only properties in default state are overwritten.</short>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.ActionLink">
        <short>Link to the default Action associated with this control.</short>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.DesktopFont">
        <short>[?]</short>
        <descr>
        </descr>
        <seealso>
        </seealso>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.AutoSize">
        <short>Whether auto-size is to be used</short>
        <descr>
          <p>AutoSize permits the size of a control to be adjusted automatically, for example a button can become bigger or smaller to accommodate a longer or shorter caption.</p>
          <p>Default is false, ie no auto-sizing</p>
        </descr>
        <seealso>
          <link id="#lcl.Controls.Autosize">Autosize topic</link>
        </seealso>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.Ctl3D">
        <short>
          <var>Ctl3D</var> - retained for Delphi compatibility; even there it is deprecated</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.DragCursor">
        <short>
          <var>DragCursor </var>- the style of cursor to be used during the Drag process</short>
        <descr>Default is crDrag. When no drop is allowed, the cursor changes temporarily to crNoDrop.</descr>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.DragKind">
        <short>
          <var>DragKind</var> - what sort of dragging? Drag or Dock</short>
        <descr>Set to dkDrag to allow for drag-drop, or to dkDock to allow for drag-dock.</descr>
        <seealso/>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.DragMode">
        <short>
          <var>DragMode </var>- whether manual or automatic</short>
        <descr>
          <p>Default is dmManual, meaning that dragging must be started in code.</p>
          <p>Set to dmAutomatic to allow the user to drag this control. In this mode dragging can start immediately (on left mouse button press) or delayed, after the mouse has been moved away by a number of pixels (Threshold).</p>
        </descr>
        <seealso>
          <link id="TDragManager.DragImmediate"/>
        </seealso>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.MouseCapture">
        <short>Are mouse messages captured by this control?</short>
        <descr>
          <p>Mouse messages can be sent to a capturing control. This occurs automatically when a control is dragged.
            In normal operation all mouse messages are sent to the control under the mouse pointer.</p>
          <p>Applications should capture mouse events only for special purposes, and release the capture as soon as a the target position has been determined.
            Limited user feedback is possible while the mouse is captured, but not all application controls will work properly so long.</p>
        </descr>
        <seealso/>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.ParentFont">
        <short>
          <var>ParentFont</var> - should the control use the same font as the parent? Default is true.</short>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.ParentColor">
        <short>
          <var>ParentColor</var> - should the control have the same color as the parent? Default is true.</short>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.ParentShowHint">
        <short>
          <var>ParentShowHint</var> - does the control use the same hinting behaviour as its parent? Default is true.</short>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.SessionProperties">
        <short>The stored (saved) properties of the current session, expressed as a string</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.Text">
        <short>
          <var>Text</var> - the character string associated with the control.</short>
        <descr>
          <p>This is the character string, shown in controls with visible text content (<link id="#lcl.StdCtrls.TEdit">TEdit</link>...).</p>
          <remark>BEWARE: In other controls it can be the Name or Caption of the control, quite tricky to use.</remark>
        </descr>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.OnConstrainedResize">
        <short>Event Handler for constrained resize</short>
        <descr>
          <p>Event handler needs to be supplied to cover the need to resize a control within the given constraints of maximum and minimum width and height</p>
        </descr>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.OnContextPopup">
        <short>Event handler to supply information when a context-sensitive pop-up menu is required</short>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.OnDblClick">
        <short>Event Handle for mouse double-click</short>
        <descr>
          <p>Double-clicking is much more common in a Windows environment than in Unix or Linux, where single-clicking is the default method for selecting an object. However, in all environments there could be valid use for a double-click, and a method should be supplied if appropriate.</p>
        </descr>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.OnTripleClick">
        <short>Event handler for mouse triple-click</short>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.OnQuadClick">
        <short>Event handler for quadruple click</short>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.OnDragDrop">
        <short>Event handler for the drop of a control onto this control.</short>
        <descr>
          <p>The handler determines what shall happen when another control is dropped onto this (Sender) control.</p>
          <p>Sender is the target control onto which the Source control is dropped.</p>
          <p>X and Y are the client coordinates of the drop.</p>
        </descr>
        <seealso>
          <link id="TControl.DragDrop"/>
        </seealso>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.OnDragOver">
        <short>Event handler for the case when a control is dragged over another control</short>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.OnEndDock">
        <short>Event handler for the end of a docking operation</short>
        <descr>
          <p>This message is sent to the dragged control.</p>
          <p>Sender is the control to be docked [or DragDock object?].</p>
          <p>Target is the control into which the Sender is docked, or Nil when dragging has been aborted.</p>
          <p>X and Y are the screen coordinates of the drop.</p>
        </descr>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.OnEndDrag">
        <short>Event handler for the end of a dragging process</short>
        <descr>
          <p>This message is sent to the dragged control.</p>
          <p>Sender is the dragged control [or DragDrop object?].</p>
          <p>Target is the control onto which the Sender has been dropped, or Nil when dragging has been aborted.</p>
          <p>X and Y are the screen coordinates of the drop.</p>
        </descr>
        <seealso>
          <link id="TDragDropEvent"/>
        </seealso>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.OnMouseDown">
        <short>Event handler for when a mouse button is pressed down</short>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.OnMouseMove">
        <short>Event handler for mouse movement within the current control</short>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.OnMouseUp">
        <short>Event handler for when the mouse button is released, ie "up"</short>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.OnMouseEnter">
        <short>Event handler for when the mouse enters the area of the current control</short>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.OnMouseLeave">
        <short>Event handler for when the mouse leaves the area of the current control</short>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.OnStartDock">
        <short>Event handler for the start of a docking operation</short>
        <descr>
          <p>The handler can provide a special DragDock object, otherwise a default object is created.</p>
        </descr>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.OnStartDrag">
        <short>Event handler for start of dragging operation</short>
        <descr>
          <p>The handler can provide a special DragControl object, otherwise a default object is created.</p>
        </descr>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.OnEditingDone">
        <short>Event handler when editing is done</short>
      </element>
      <!-- variable Visibility: public -->
      <element name="TControl.FCompStyle">
        <short>
          <var>FCompStyle</var> - deprecated</short>
        <descr>
          <pre>// DEPRECATED. Enables (valid) use of 'IN' operator (this
      // is a hack for speed. It will be replaced by the use of the widgetset
      // classes.
      // So, don't use it anymore.        
</pre>
        </descr>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.DragDrop">
        <short>Invokes the OnDragDrop handler, when the control is dropped.</short>
        <seealso>
          <link id="TControl.OnDragDrop"/>
        </seealso>
      </element>
      <element name="TControl.DragDrop.Source">
        <short>The object to be dragged and dropped</short>
      </element>
      <element name="TControl.DragDrop.X">
        <short>The X co-ordinate to which the object is to be dropped (target)</short>
      </element>
      <element name="TControl.DragDrop.Y">
        <short>The Y co-ordinate to which the object is to be dropped (target)</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.Dock">
        <short>Moves the control into a new docksite.</short>
        <descr>
          <p>Calls <link id="TControl.DoDock">DoDock</link> to calculate the new position the control, when docked into an unmanaged or floating docksite.</p>
          <p>When the old and new docksites are different,
            the control is removed from the DockClients of the old docksite, and added to the DockClients of the new docksite;
            afterwards the docksites are notified by calling their DoAddDockClient and DoRemoveDockClient methods, to adjust the control's Parent.</p>
        </descr>
        <errors>An exception is raised if there is already a docking process in progress for this control</errors>
      </element>
      <element name="TControl.Dock.NewDockSite">
        <short>The host control to which which the control is to be docked</short>
      </element>
      <element name="TControl.Dock.ARect">
        <short>The position at which the control is to be docked.</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.ManualDock">
        <short>Docks a control programmatically.</short>
        <descr>
          <p>Docks this control into NewDockSite, relative to DropControl. When NewDockSite is Nil, the control becomes floating.</p>
          <p>When the new docksite uses an DockManager, and DropControl is not Nil, the control will be docked relative to DropControl, as specified by ControlSide.
            The interpretation of ControlSide depends on the DockManager of NewDockSite, or on the OnDockDrop handler in an unmanaged  docksite.
            A tree docking manager (TDockTree) should interpret alCustom as NoteBook docking, i.e. a tabbed notebook is created in place of DropControl, and both DropControl and this control are docked into pages of this notebook.</p>
        </descr>
      </element>
      <element name="TControl.ManualDock.Result">
        <short>The function returns True if a manual dock has been successfully performed.</short>
      </element>
      <element name="TControl.ManualDock.NewDockSite">
        <short>The new site to which the control is docked, if DropControl is <b>nil</b>.</short>
      </element>
      <element name="TControl.ManualDock.DropControl">
        <short>If <b>nil</b> (default) then ignored, else used as the control for docking, on side specified by ControlSide</short>
      </element>
      <element name="TControl.ManualDock.ControlSide">
        <short>The side of DropControl on which the control is to be docked.
        </short>
      </element>
      <element name="TControl.ManualDock.KeepDockSiteSize">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.ManualFloat">
        <short>Undocks the control into floating state.</short>
        <descr>TWinControls float for themselves, for TControls a floating host dock site is created, and the control is docked into it.
        </descr>
      </element>
      <element name="TControl.ManualFloat.Result">
        <short>The function returns True if a manual float has been succesfully performed.</short>
      </element>
      <element name="TControl.ManualFloat.TheScreenRect">
        <short>The screen area where the floating control is moved.</short>
        <descr>The rectangle within which the floating control is located
          <br/>(ie the location of the floating dock site to which the control is docked) [site or client coordinates?]
        </descr>
      </element>
      <element name="TControl.ManualFloat.KeepDockSiteSize">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.ReplaceDockedControl">
        <short>Remove a previously docked control and put a new control in its place</short>
        <descr>
          <p>This method works only when the control to replace resides in a managed docksite (using an DockManager), or is not docked at all.
            Even then exist situations where it won't work as expected, depending on the used DockManager and other subtle conditions.</p>
          <p>When the control to replace is docked, then it's replaced by this control; otherwise this control becomes floating (seems to be a design flaw).</p>
          <p>Finally the control to replace is docked into NewDockSite, according to DropControl and ControlSide (see <link id="TControl.ManualDock"/>).</p>
          <p>This method primarily exists for use by the DockManager itself, for NoteBook docking. It should not be used in application code.</p>
        </descr>
        <seealso>
          <link id="#lcl.Controls.TControl.ManualDock"/>
        </seealso>
      </element>
      <element name="TControl.ReplaceDockedControl.Result">
        <short>Returns True if a docked control has been successfully replaced with a new one</short>
      </element>
      <element name="TControl.ReplaceDockedControl.Control">
        <short>The old control that was previously docked at this site</short>
      </element>
      <element name="TControl.ReplaceDockedControl.NewDockSite">
        <short>The new site for docking; used if DropControl is <b>nil</b>
        </short>
      </element>
      <element name="TControl.ReplaceDockedControl.DropControl">
        <short>The control site to be used for docking, unless it is <b>nil</b> when it is igored. Passed straight through as an argument to ManualDock</short>
      </element>
      <element name="TControl.ReplaceDockedControl.ControlSide">
        <short>The side to which the new control is to be aligned; passed straight through as an argument to ManualDock</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.Dragging">
        <short>Returns True if the control is being dragged</short>
      </element>
      <element name="TControl.Dragging.Result">
        <short>Returns True if the control is being dragged</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.AdjustSize">
        <short>
          <var>AdjustSize</var> - Smart way to 
          <var>DoAutoSize</var>
        </short>
        <descr>
          <p>
            <var>TControl.AdjustSize</var> calls 
            <var>DoAutoSize</var> in a smart fashion.</p>
          <p>During loading and handle creation the calls are delayed.</p>
          <p>This method initially does the same as <var>TWinControl.DoAutoSize</var>.
            But since <var>DoAutoSize</var> is commonly overriden by descendant components, it is not useful to perform all tests, which can result in too much overhead.[?]
            To reduce this the LCL calls <var>AdjustSize</var> instead.</p>
        </descr>
        <seealso>
          <link id="#lcl.Controls.AutoSize"/>
        </seealso>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.AutoSizeDelayed">
        <short>Auto-sizing has been delayed until some other process is complete</short>
      </element>
      <element name="TControl.AutoSizeDelayed.Result">
        <short>Returns True if auto-sizing has been delayed</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.AutoSizePhases">
        <short></short>
        <descr>
        </descr>
        <errors>
        </errors>
        <seealso>
        </seealso>
      </element>
      <element name="TControl.AutoSizePhases.Result">
        <short></short>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.AutoSizeCheckParent">
        <short></short>
        <descr>
        </descr>
        <errors>
        </errors>
        <seealso>
        </seealso>
      </element>
      <element name="TControl.AutoSizeCheckParent.Result">
        <short></short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.AnchorToNeighbour">
        <short>
          <var>AnchorToNeighbour</var> - anchoring instructions</short>
        <descr>
          <p>Setup AnchorSide to anchor a side to the side of a neighbour sibling.
            For example Right side to Left side, or Top side to Bottom.</p>
        </descr>
      </element>
      <element name="TControl.AnchorToNeighbour.Side">
        <short>The side on which we should anchor</short>
      </element>
      <element name="TControl.AnchorToNeighbour.Space">
        <short>The minimum space to be left around the control when anchoring</short>
      </element>
      <element name="TControl.AnchorToNeighbour.Sibling">
        <short>The sibling control to which we should anchor</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.AnchorParallel">
        <short>
          <var>AnchorParallel </var> - instructions for anchoring beside another control</short>
        <descr/>
      </element>
      <element name="TControl.AnchorParallel.Side">
        <short>The side which we should anchor to the sibling</short>
      </element>
      <element name="TControl.AnchorParallel.Space">
        <short>The size of the space to be left around the control when anchoring</short>
      </element>
      <element name="TControl.AnchorParallel.Sibling">
        <short>The sibling control to which we should anchor in a parallel manner</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.AnchorHorizontalCenterTo">
        <short></short>
      </element>
      <element name="TControl.AnchorHorizontalCenterTo.Sibling">
        <short>Another control to which the current control is to be anchored, centred horizontally</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.AnchorVerticalCenterTo">
        <short>
          <var>AnchorVertical </var> - instructions for anchoring</short>
      </element>
      <element name="TControl.AnchorVerticalCenterTo.Sibling">
        <short>Another control to which the current control is to be anchored, centered vertically</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.AnchorToCompanion">
        <short>
          <var>AnchorToCompanion</var> - anchor to another control, not necessarily an immediate neighbour</short>
      </element>
      <element name="TControl.AnchorToCompanion.Side">
        <short/>
      </element>
      <element name="TControl.AnchorToCompanion.Space">
        <short/>
      </element>
      <element name="TControl.AnchorToCompanion.Sibling">
        <short/>
      </element>
      <element name="TControl.AnchorToCompanion.FreeCompositeSide">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.AnchorSame">
        <short>Anchor on the same side as a sibling</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.AnchorSame.Side">
        <short/>
      </element>
      <element name="TControl.AnchorSame.Sibling">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.AnchorAsAlign">
        <short>
          <var>AnchorAsAlign</var> - Anchor following same rules as Align</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.AnchorAsAlign.TheAlign">
        <short/>
      </element>
      <element name="TControl.AnchorAsAlign.Space">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.AnchorClient">
        <short>Anchor to the client space</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.AnchorClient.Space">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.AnchoredControlCount">
        <short>The number of controls anchored to this one</short>
      </element>
      <element name="TControl.AnchoredControlCount.Result">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.AnchoredControls">
        <short>The indexed list of controls anchored to this one</short>
      </element>
      <element name="TControl.AnchoredControls.Index">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.GetAnchorsDependingOnParent">
        <short>Find out the required anchor settings by reference to the parents</short>
      </element>
      <element name="TControl.GetAnchorsDependingOnParent.Result">
        <short/>
      </element>
      <element name="TControl.GetAnchorsDependingOnParent.WithNormalAnchors">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.GetSidePosition">
        <short>Find which side is being used for anchoring</short>
      </element>
      <element name="TControl.GetSidePosition.Result">
        <short/>
      </element>
      <element name="TControl.GetSidePosition.Side">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.BaseBounds">
        <short>The rectangle of the designed bounds.</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.ReadBounds">
        <short>
          <var>ReadBounds</var> - find out what bounds have been defined[???]</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.BaseParentClientSize">
        <short>[?]</short>
        <descr>
        </descr>
        <seealso>
        </seealso>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.SetBounds">
        <short>Sets the bounds (left, top, height, width) of the control.</short>
        <descr>SetBounds can be used to change the left, top, width, height all at once, reducing some overhead.
          Use DisableAutoSize/EnableAutoSize to reduce recomputing/moving/resizing further.
          SetBounds is called when the properties Left, Top, Width, Height, BoundsRect is set.
          SetBounds updates the BaseBounds and BaseParentClientSize, which are used by anchoring to keep the distance.
          For example loading a Form with TMemo and the lfm contains TMemo's Left and Width, then SetBounds is called two times for the memo.
          When the user maximizes a window, SetBounds is called for the form, but not for the Memo, keeping the BaseBounds of the Memo.
          If the Memo is anchored to the right, the Width of the Memo is changed based on the BaseBounds and BaseParentClientSize.[?]
          Keep in mind that the given aLeft, aTop, aWidth, aHeight might not be valid and will be changed by the LCL before applied.
          Delphi calls SetBounds more often. SetBounds calls ChangeBounds with KeepBase=false.[format this]
        </descr>
      </element>
      <element name="TControl.SetBounds.aLeft">
        <short>The X co-ordinate of the top left pixel of the control</short>
      </element>
      <element name="TControl.SetBounds.aTop">
        <short>The Y co-ordinate of the top left pixel of the control</short>
      </element>
      <element name="TControl.SetBounds.aWidth">
        <short>The width of the control</short>
      </element>
      <element name="TControl.SetBounds.aHeight">
        <short>The height of the control</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.SetInitialBounds">
        <short>Sets the bounds of the control initially, when it is created</short>
        <descr>Checks that this is a new control, then calls SetBounds to set up coordinates defining its position
        </descr>
        <seealso>
          <link id="#lcl.Controls.TControl.SetBounds">SetBounds</link>
        </seealso>
      </element>
      <element name="TControl.SetInitialBounds.aLeft">
        <short>X co-ordinate of top left pixel</short>
      </element>
      <element name="TControl.SetInitialBounds.aTop">
        <short>Y co-ordinate of top left pixel</short>
      </element>
      <element name="TControl.SetInitialBounds.aWidth">
        <short>Width of control</short>
      </element>
      <element name="TControl.SetInitialBounds.aHeight">
        <short>Height of control</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.SetBoundsKeepBase">
        <short>Set the bounds, keeping the base values</short>
      </element>
      <element name="TControl.SetBoundsKeepBase.aLeft">
        <short/>
      </element>
      <element name="TControl.SetBoundsKeepBase.aTop">
        <short/>
      </element>
      <element name="TControl.SetBoundsKeepBase.aWidth">
        <short/>
      </element>
      <element name="TControl.SetBoundsKeepBase.aHeight">
        <short/>
      </element>
      <element name="TControl.SetBoundsKeepBase.Lock">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.GetPreferredSize">
        <short>Returns default/preferred height and width, to be used in autosizing.</short>
        <descr>
          <p>Called during AutoSize [link?] calculations. Only positive values are valid. Negative or 0 are treated as undefined and the LCL uses other sizes instead.</p>
          <p>WithThemeSpace: If true, adds space for stacking. [add to arguments]</p>
          <p>For example: <var>TRadioButton</var> has a minimum size. But for stacking multiple TRadioButtons there should be
            some space around. This space is theme dependent, so the parameter is passed to the widgetset</p>
          <p>
            <var>TWinControl</var> overrides this and asks the interface for theme dependent values. See
            
            <link id="#lcl.Controls.TWinControl.CalculatePreferredSize">TWinControl.CalculatePreferredSize</link> for more information.</p>
        </descr>
      </element>
      <element name="TControl.GetPreferredSize.PreferredWidth">
        <short/>
      </element>
      <element name="TControl.GetPreferredSize.PreferredHeight">
        <short/>
      </element>
      <element name="TControl.GetPreferredSize.Raw">
        <short/>
      </element>
      <element name="TControl.GetPreferredSize.WithThemeSpace">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.InvalidatePreferredSize">
        <short>Mark the preferred size no longer valid, for this control and all parents (implies that we will look for another).</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.GetDefaultWidth">
        <short>Find default width (by reference to ancestor)</short>
      </element>
      <element name="TControl.GetDefaultWidth.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.GetDefaultHeight">
        <short>Find the default height (by reference to ancestor)</short>
      </element>
      <element name="TControl.GetDefaultHeight.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.GetDefaultColor">
        <short>[?]</short>
        <descr>
        </descr>
        <errors>
        </errors>
        <seealso>
        </seealso>
      </element>
      <element name="TControl.GetDefaultColor.Result">
        <short></short>
      </element>
      <element name="TControl.GetDefaultColor.DefaultColorType">
        <short></short>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.GetControlClassDefaultSize">
        <short>Find the default size for this class of controls (by reference to parents)</short>
      </element>
      <element name="TControl.GetControlClassDefaultSize.Result">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.CNPreferredSizeChanged">
        <short>Message handler for preferred size changed.</short>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TControl.Create">
        <short/>
        <descr>
          <p>[todo: remove properties set to all zeroes - this has no special effect]</p>
          <p>Defaults set by the Constructor include ControlStyle, Constraints, BorderSpacing, Anchoring, alignment, CaptureMouseBottons, Color, Visibility, Hinting, Cursor, Font, the WindowProcedure to be used, the Help type, the FloatingDockSite and Enabled properties</p>
        </descr>
        <seealso>
          <link id="#rtl.Classes.TComponent.Create">TComponent.Create</link>
          <link id="#LCL.LCLClasses.TLCLComponent.Create">TLCLComponent.Create</link>
        </seealso>
      </element>
      <element name="TControl.Create.TheOwner">
        <short/>
      </element>
      <!-- destructor Visibility: public -->
      <element name="TControl.Destroy">
        <short>Removes the control from its Parent.</short>
        <descr>
          <p>Detaches the control from Parent, removes graphics, frees memory and Operating System handles, pointers etc.</p>
        </descr>
        <seealso>
          <link id="#rtl.Classes.TComponent.Destroy">TComponent.Destroy</link>
          <link id="#LCL.LCLClasses.TLCLComponent.Destroy">TLCLComponent.Destroy</link>
        </seealso>
      </element>
      <element name="TControl.CreateControlBorderSpacing">
        <short>
          <var>CreateControlBorderSpacing</var> - calls
          <var>TControlBorderSpacing.Create</var> to create the border spacing for this control</short>
        <seealso>
          <link id="TControlBorderSpacing.Create">TControlBorderSpacing.Create</link>
        </seealso>
      </element>
      <element name="TControl.CreateControlBorderSpacing.Result">
        <short></short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.EditingDone">
        <short>Calls the <var>OnEditingDone</var> event handler.</short>
        <descr>
          <p>Called when user has finished editing. This procedure can be used by data links to commit the changes.</p>
          <p>For example:</p>
          <ul>
            <li>When focus switches to another control (default)</li>
            <li>When user selected another item</li>
          </ul>
          <p>It's totally up to the control, what events will commit.</p>
        </descr>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.ExecuteDefaultAction">
        <short>Called when the RETURN button is pressed, signifying default action.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.ExecuteCancelAction">
        <short>Called when ESCAPE is hit or the CANCEL button is clicked - signifying CANCEL.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.BeginDrag"/>
      <element name="TControl.BeginDrag.Immediate">
        <short>If True, start dragging right now.</short>
      </element>
      <element name="TControl.BeginDrag.Threshold">
        <short>Minimum movement of cursor before delayed dragging starts (in pixels); ignored if Immediate=True.</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.BeginDrag">
        <short>
          <var>BeginDrag</var> - starts the dragging of a control. In this version BringToFront applies[?]</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.BeginDrag.Immediate">
        <short>If False, start drag only after the cursor has moved.</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.BringToFront">
        <short>Bring the control to the front of the viewed screen</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.ColorIsStored">
        <short>Returns True if color is stored</short>
      </element>
      <element name="TControl.ColorIsStored.Result">
        <short>Function returns True if Color has been stored.</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.HasParent">
        <short>Returns True if there is a parent component responsible for streaming</short>
        <descr>
          <p>This function will be called during streaming to decide if a component has to be streamed by its owner or parent</p>
        </descr>
        <seealso>
          <link id="#rtl.Classes.TComponent.HasParent">TComponent.HasParent</link>
        </seealso>
      </element>
      <element name="TControl.HasParent.Result">
        <short>Function returns True if there is a parent</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.GetParentComponent">
        <short>Returns Parent (implements TComponent.GetParentComponent).</short>
        <descr>
        </descr>
        <errors>
        </errors>
        <seealso>
        </seealso>
      </element>
      <element name="TControl.GetParentComponent.Result">
        <short>The Parent property.</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.NeedParentForAutoSize">
        <short>
          <var>NeedParentForAutoSize</var>:  True - need to know parent's properties to do autosize. False - can autosize independently</short>
      </element>
      <element name="TControl.NeedParentForAutoSize.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.IsParentOf">
        <short>Determines whether this control is a parent of AControl.</short>
        <descr>The recursive search in all Parents of AControl finds not only immediate parent/child controls.
        </descr>
      </element>
      <element name="TControl.IsParentOf.Result">
        <short>Function returns True if this control is a parent of AControl.</short>
      </element>
      <element name="TControl.IsParentOf.AControl">
        <short>The control of which this control may be a parent.</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.IsVisible">
        <short>Returns True if the control is visible in its form.</short>
      </element>
      <element name="TControl.IsVisible.Result">
        <short>True only if all Parents also are visible.</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.IsProcessingPaintMsg">
        <short></short>
        <descr>
        </descr>
        <errors>
        </errors>
        <seealso>
        </seealso>
      </element>
      <element name="TControl.IsProcessingPaintMsg.Result">
        <short></short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.Hide">
        <short>
          <var>Hide </var>this control</short>
        <seealso>
          <link id="#lcl.Controls.TControl.Visible"/>
          <link id="#lcl.Controls.TControl.Show"/>
        </seealso>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.Refresh">
        <short>
          <var>Refresh</var> the data on this control</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.Repaint">
        <short>
          <var>Repaint</var> the control, ie refill its canvas</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.Invalidate">
        <short>Render this control non-valid</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.AddControl">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.CheckChildClassAllowed">
        <short>Function checks whether a particular child class is allowed</short>
      </element>
      <element name="TControl.CheckChildClassAllowed.Result">
        <short>Function returns True if child class has been checked and is allowed</short>
      </element>
      <element name="TControl.CheckChildClassAllowed.ChildClass">
        <short>The child class which is being checked to see whether it is allowed</short>
      </element>
      <element name="TControl.CheckChildClassAllowed.ExceptionOnInvalid">
        <short>Boolean set to True if a non-valid class is found and an exception has been raised</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.CheckNewParent">
        <short>Checks a new parent for this control</short>
      </element>
      <element name="TControl.CheckNewParent.AParent">
        <short>The new parent associated with this control</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.SendToBack">
        <short>Send to back, ie behind all other controls in the Parent; it will not be visible unless the controls in front are transparent</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.SetTempCursor">
        <short>
          <var>SetTempCursor</var> - set a temporary cursor [purpose?]</short>
      </element>
      <element name="TControl.SetTempCursor.Value">
        <short>The temporary cursor which has been set</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.UpdateMouseCursor">
        <short>
          <var>UpdateMouseCursor</var> - ensure coordinates
          <var>X, Y </var> for the cursor are correctly stored</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.UpdateMouseCursor.X">
        <short/>
      </element>
      <element name="TControl.UpdateMouseCursor.Y">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.UpdateRolesForForm">
        <short>Update the roles for this form; see whether there have been any changes in its role</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.GetTextBuf">
        <short>Gets text associated with the control from the widget.</short>
        <descr>
          <remark>See SetTextBuf [document in one place?]</remark>
          <pre>* The VCL implementation relies on the virtual Get/SetTextBuf to 
 * exchange text between widgets and VCL. This means a lot of 
 * (unnecesary) text copies.
 * The LCL uses strings for exchanging text (more efficient).
 * To maintain VCL compatibility, the virtual RealGet/SetText is
 * introduced. These functions interface with the LCLInterface. The
 * default Get/SetTextbuf implementation calls the RealGet/SetText.
 * As long as the Get/SetTextBuf isn't overridden Get/SetText 
 * calls RealGet/SetText to avoid PChar copying.
 * To keep things optimal, LCL implementations should always 
 * override RealGet/SetText. Get/SetTextBuf is only kept for
 * compatibility.
</pre>
        </descr>
        <seealso>
          <link id="#lcl.Controls.TControl.RealGetText">RealGetText</link>
          <link id="#lcl.Controls.TControl.GetText">GetText</link>
        </seealso>
      </element>
      <element name="TControl.GetTextBuf.Result">
        <short>Pointer to the buffer containing the text</short>
      </element>
      <element name="TControl.GetTextBuf.Buffer">
        <short>Pointer to the buffer containing the string</short>
      </element>
      <element name="TControl.GetTextBuf.BufSize">
        <short>Length of the buffer</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.GetTextLen">
        <short>Get the length of the specified text</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.GetTextLen.Result">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.SetTextBuf">
        <short>Sends text associated with the control to the widget.</short>
        <descr>
          <p>This method exists only for VCL compatibility.
            The VCL sends text from the Text or Caption properties immediately to the widget,
            using WM_SETTEXT. The LCL instead transfers an string to the widget interface,
            and leaves eventual string/PChar conversions to the interface.
          </p>
          <remark>
            <b>Do not override this method</b>, because this will only cause overhead in the communication between LCL and widgetsets.
            The LCL SetText method bypasses SetTextBuf, if not overridden, and calls the fast RealSetText method.
            Instead override RealSetText, if ever required.
          </remark>
          <pre>[todo: remove?]
 * The VCL implementation relies on the virtual Get/SetTextBuf to
 * exchange text between widgets and VCL. This means a lot of 
 * (unnecesary) text copies.
 * The LCL uses strings for exchanging text (more efficient).
 * To maintain VCL compatibility, the virtual RealGet/SetText is
 * introduced. These functions interface with the LCLInterface. The
 * default Get/SetTextbuf implementation calls the RealGet/SetText.
 * As long as the Get/SetTextBuf isn't overridden Get/SetText 
 * calls RealGet/SetText to avoid PChar copying.
 * To keep things optimal, LCL implementations should always 
 * override RealGet/SetText. Get/SetTextBuf is only kept for
 * compatibility.
</pre>
        </descr>
        <seealso>
          <link id="#lcl.Controls.TControl.RealSetText">RealSetText</link>
          <link id="#lcl.Controls.TControl.SetText">SetText</link>
        </seealso>
      </element>
      <element name="TControl.SetTextBuf.Buffer">
        <short>Pointer to the buffer where the text is to be stored</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.Perform">
        <short>Direct call of an message handler, bypassing the message queue.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.Perform.Result">
        <short/>
      </element>
      <element name="TControl.Perform.Msg">
        <short/>
      </element>
      <element name="TControl.Perform.WParam">
        <short/>
      </element>
      <element name="TControl.Perform.LParam">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.ScreenToClient">
        <short>Convert absolute screen coordinates into client-relative coordinates</short>
      </element>
      <element name="TControl.ScreenToClient.Result">
        <short/>
      </element>
      <element name="TControl.ScreenToClient.APoint">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.ClientToScreen">
        <short>Convert client-relative coordinates into absolute screen coordinates.</short>
      </element>
      <element name="TControl.ClientToScreen.Result">
        <short/>
      </element>
      <element name="TControl.ClientToScreen.APoint">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.ScreenToControl">
        <short>Convert absolute screen coordinates into control-relative coordinates.</short>
      </element>
      <element name="TControl.ScreenToControl.Result">
        <short/>
      </element>
      <element name="TControl.ScreenToControl.APoint">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.ControlToScreen">
        <short>Convert control-relative coordinates into absolute screen coordinates.</short>
      </element>
      <element name="TControl.ControlToScreen.Result">
        <short/>
      </element>
      <element name="TControl.ControlToScreen.APoint">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.Show">
        <short>Makes the control visible.</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#lcl.Controls.TControl.Visible"/>
          <link id="#lcl.Controls.TControl.Hide"/>
        </seealso>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.Update">
        <short>Redraw invalidated parts of the control immediately.</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.SetZOrderPosition">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.SetZOrderPosition.NewPosition">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.SetZOrder">
        <short>
          <var>SetZOrder</var> - specify this control's place in the Z-order (ie front-to-back) of controls</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.SetZOrder.TopMost">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.HandleObjectShouldBeVisible">
        <short>
          <var>HandleObjectShouldBeVisible</var> - returns True if the Handle Object is required to be visible</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.HandleObjectShouldBeVisible.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.ParentHandlesAllocated">
        <short>
          <var>ParentHandlesAllocated</var> - returns True if the parent handles have been allocated</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.ParentHandlesAllocated.Result">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.InitiateAction">
        <short>
          <var>InitiateAction</var> - method to start[?] the action associated with this control</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DoCallNotifyHandler">
        <short>
          <var>DoCallNotifyHandler</var> - calls a Notify Handler of the specified type</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.DoCallNotifyHandler.HandlerType">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.RemoveAllHandlersOfObject" link="#LCL.LCLClasses.TLCLComponent.RemoveAllHandlersOfObject"/>
      <element name="TControl.RemoveAllHandlersOfObject.AnObject">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.AddHandlerOnResize">
        <short>Adds an handler for the <var>OnResize</var> event.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.AddHandlerOnResize.OnResizeEvent">
        <short/>
      </element>
      <element name="TControl.AddHandlerOnResize.AsFirst">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.RemoveHandlerOnResize">
        <short>Removes an handler for the <var>OnResize</var> event.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.RemoveHandlerOnResize.OnResizeEvent">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.AddHandlerOnChangeBounds">
        <short>Adds an handler for the <var>OnChangeBounds</var> event.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.AddHandlerOnChangeBounds.OnChangeBoundsEvent">
        <short/>
      </element>
      <element name="TControl.AddHandlerOnChangeBounds.AsFirst">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.RemoveHandlerOnChangeBounds">
        <short>Removes an handler for the <var>OnChangeBounds</var> event.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.RemoveHandlerOnChangeBounds.OnChangeBoundsEvent">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.AddHandlerOnKeyDown">
        <short>Adds an handler for the <var>OnKeyDown</var> event.</short>
        <descr>
        </descr>
        <errors>
        </errors>
        <seealso>
        </seealso>
      </element>
      <element name="TControl.AddHandlerOnKeyDown.OnKeyDownEvent">
        <short></short>
      </element>
      <element name="TControl.AddHandlerOnKeyDown.AsFirst">
        <short></short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.RemoveHandlerOnKeyDown">
        <short>Removes an handler for the <var>OnKeyDown</var> event.</short>
        <descr>
        </descr>
        <errors>
        </errors>
        <seealso>
        </seealso>
      </element>
      <element name="TControl.RemoveHandlerOnKeyDown.OnKeyDownEvent">
        <short></short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.AddHandlerOnVisibleChanging">
        <short>Adds an <var>OnVisibleChanging</var> handler.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.AddHandlerOnVisibleChanging.OnVisibleChangingEvent">
        <short/>
      </element>
      <element name="TControl.AddHandlerOnVisibleChanging.AsFirst">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.RemoveHandlerOnVisibleChanging">
        <short>Removes an <var>OnVisibleChanging</var> handler.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.RemoveHandlerOnVisibleChanging.OnVisibleChangingEvent">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.AddHandlerOnVisibleChanged">
        <short>Adds an
          <var>OnVisibleChanged</var> handler.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.AddHandlerOnVisibleChanged.OnVisibleChangedEvent">
        <short/>
      </element>
      <element name="TControl.AddHandlerOnVisibleChanged.AsFirst">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.RemoveHandlerOnVisibleChanged">
        <short>Removes an <var>OnVisibleChanged</var> handler.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.RemoveHandlerOnVisibleChanged.OnVisibleChangedEvent">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.VisibleChanged">
        <short>Notifies all OnVisibleChanged handlers.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.Action">
        <short>The Action associated with this control.</short>
        <seealso>
          <link id="#rtl.Classes.TBasicAction"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.Align">
        <short>Specifies the placement of the control inside its Parent.</short>
        <descr>
          <p>May have no alignment, may have custom or client alignment, or can be aligned to top, bottom, left or right[more precisely?]</p>
        </descr>
        <seealso>
          <link id="#lcl.Controls.TAlign">TAlign</link>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.Anchors">
        <short>The set of anchor definitions for this control</short>
        <descr>
          <p>Determines how the control is anchored to other controls.</p>
          <p>
            <var>IsAnchorsStored</var> is True if anchors have been defined.</p>
        </descr>
        <seealso>
          <link id="#lcl.Controls.TAnchors"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.AnchorSide">
        <short>Finds which side to use for anchor[?]</short>
        <descr>
          <p>Finds which side is to be used to anchor this control, and what relationships it has to other controls nearby. </p>
          <p>For complex relationships, use the <var>Side</var> property of the parent class <link id="#lcl.Controls.TAnchorSide">TAnchorSide</link>, and make a reference eg using <var>asrCenter</var>
          </p>
        </descr>
        <seealso>
          <link id="#lcl.Controls.TAnchorSide"/>
        </seealso>
      </element>
      <element name="TControl.AnchorSide.Kind">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.BorderSpacing">
        <short>Determines the border spacing for this control</short>
        <descr/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.BoundsRect">
        <short>The TopLeft and BottomRight of the control in client coordinates.</short>
        <descr>
          <p>The BoundsRect rectangle describes the TopLeft and BottomRight coordinates of the control, relative to its parent. The values are based on the Top, Left, Width and Height of the control.</p>
          <p>Set BoundsRect to move the control.</p>
        </descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.BoundsRectForNewParent">
        <short>
          <var>BoundsRectForNewParent</var> - get or set the bounding rectangle within a new parent control</short>
        <descr>
          <p>The rectangle describes the placement of the control when its Parent is changed later.</p>
          <p>Setting the rectangle also sets a flag, indicating that the values are available.</p>
        </descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.Caption">
        <short>
          <var>Caption</var> - the text describing the control to the user.</short>
        <descr>
          <p>By default, the <var>Caption</var> is the same as the control <var>Name</var> in the Object Inspector, and the developer needs to set it explicitly to some new text.</p>
          <remark>[todo: remove Text specific content]</remark>
          <p>The VCL implementation relies on the virtual <var>Get/SetTextBuf</var> to exchange text between widgets and VCL. This means a lot of (unnecesary) text copies. </p>
          <p>The LCL uses strings for exchanging text (more efficient). To maintain VCL compatibility, the virtual <var>RealGet/SetText</var> is
            introduced. These functions interface with the LCLInterface.</p>
          <p>The default <var>Get/SetTextBuf</var> implementation calls the <var>RealGet/SetText</var>. As long as the <var>Get/SetTextBuf</var> isn't overridden <var>Get/SetText</var> calls <var>RealGet/SetText</var> to avoid PChar copying.</p>
          <p>To keep things optimal, LCL implementations should always override RealGet/SetText. Get/SetTextBuf is only kept for compatibility.</p>
        </descr>
        <seealso>
          <link id="#lcl.Controls.TControl.RealGetText"/>
          <link id="#lcl.Controls.TControl.RealSetText"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.ClientHeight">
        <short>The height of the client area of the control.</short>
        <descr/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.ClientOrigin">
        <short>Screen coordinates of the TopLeft pixel (of the client area) of the control.</short>
        <descr>
          <p>Only TWinControls have a client area, for other controls ClientOrigin is the same as Origin.</p>
          <p>Note that this value is the position as stored in the object, not always in sync with the widget.</p>
        </descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.ClientRect">
        <short>Size of the client area of the control.</short>
        <descr>The origin is always (0,0). Bottom and Right reflect the ClientWidth and ClientHeight of the control.</descr>
        <seealso>
          <link id="#rtl.Classes.TRect"/>
          <link id="TControl.GetLogicalClientRect"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.ClientWidth">
        <short>The width of the client area of the control.</short>
        <descr/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.Color">
        <short>The background[?] color of the control.</short>
        <descr>
          <p>The default Color is the same as the parent window Color.</p>
        </descr>
        <seealso>
          <link id="#lcl.Graphics.TColor"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.Constraints">
        <short>Determine <var>Constraints</var> (max and min height and width) for this control</short>
        <descr/>
        <seealso>
          <link id="#lcl.Controls.TSizeConstraints"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.ControlOrigin">
        <short>
          <var>ControlOrigin</var> - top left pixel of this control, in screen coordinates.</short>
        <descr/>
        <seealso>
          <link id="#rtl.Classes.TPoint"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.ControlState">
        <short>
          <var>ControlState</var> - whether mouse has been clicked, data being read, control being re-drawn, etc</short>
        <descr/>
        <seealso>
          <link id="#lcl.Controls.TControlState"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.ControlStyle">
        <short>
          <var>ControlStyle</var> - whether the control responds to mouse clicks, can be re-sized, has particular actions, etc.</short>
        <descr/>
        <seealso>
          <link id="#lcl.Controls.TControlStyle"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.Enabled">
        <short>Determines whether the control reacts on mouse or keyboard input.</short>
        <descr>Disabled controls usually appear 'greyed-out'</descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.Font">
        <short>The <link id="#lcl.Graphics.TFont">font</link> to be used for text in this control (read/write).</short>
        <seealso>
          <link id="#lcl.Graphics.TFont"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.IsControl">
        <short>Determines whether this object shall be streamed as a control.</short>
        <descr>Delphi compatible property, affecting only the streaming of <var>Form</var> properties. [Has no effect in the LCL?]</descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.MouseEntered">
        <short>True when the mouse has entered the control.</short>
        <descr/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.OnChangeBounds">
        <short>Event handler for a change of the Bounds of the control.</short>
        <descr/>
        <seealso>
          <link id="#rtl.Classes.TNotifyEvent"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.OnClick">
        <short>Event Handler for mouse clicks.</short>
        <descr>
          <p>This is the default action for many controls, and is often the ONLY event handled in user code.
            The action can be specified by the user, either by typing explicit code into the implementation section for this control[???],
            or by selecting an action from a supplied <var>ActionList</var>
          </p>
        </descr>
        <seealso>
          <link id="#rtl.Classes.TNotifyEvent"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.OnResize">
        <short>Event Handler for resize of control</short>
        <descr>
          <p>This event is triggered whenever the Width, Height, ClientWidth or ClientHeight of the control has changed.
            During autosize the size can change multiple times and only the last change triggers the OnResize.
            Use OnResize to react to resizes or to put your custom aligning, positioning code into this.
            To also react on moves, use the OnChangeBounds event.</p>
          <p>Common mistake:
            Keep in mind that ClientWidth and ClientHeight can change even when Width, Height stays the same.
            For example when the theme changes, the Width and Height remain the same, but the changed frame reduces the ClientWidth and ClientHeight.
            This does not happen that often under Windows, but it happens quite often on other platforms.</p>
          <p>Especially it is not sufficient to write only a TForm.OnResize handler to resize all controls on the form. This is a common bug in Delphi applications.[???]</p>
        </descr>
        <seealso>
          <link id="#rtl.Classes.TNotifyEvent"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.OnShowHint">
        <short>Event Handler when a hint shall be shown.</short>
        <descr/>
        <seealso>
          <link id="#lcl.Controls.THintInfo"/>
          <link id="#lcl.Controls.TControlShowHintEvent"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.Parent"/>
      <!-- property Visibility: public -->
      <element name="TControl.PopupMenu">
        <short>
          <var>PopupMenu</var> - a context-sensitive menu that pops up when the right mouse button is clicked over this control</short>
        <descr/>
        <seealso>
          <link id="#lcl.Menus.TPopupMenu"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.ShowHint">
        <short>Shall the Hint displayed for this control?</short>
        <descr>When True, the Hint text is shown when mouse hovers over this control.
          Display of the actual hint is controlled by OnShowHint.</descr>
        <seealso>
          <link id="#lcl.Controls.TControl.OnShowHint">OnShowHint</link>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.Visible">
        <short>
          <var>Visible</var> - shall the control be hidden (False) or visible (True)?</short>
        <descr>
          <p>The Visible property allows to show or hide a visual control.</p>
          <p>Visible is set to True by Show, or to False by Hide. Calling these methods is equivalent to setting the Visible property.</p>
          <remark>The Visible property does not take into account control's parent visibility. Use IsVisible method to get the real visibility.</remark>
        </descr>
        <seealso>
          <link id="#lcl.Controls.TControl.IsVisible"/>
          <link id="#lcl.Controls.TControl.Show"/>
          <link id="#lcl.Controls.TControl.Hide"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.WindowProc">
        <short>The handler for all messages.</short>
        <descr/>
        <seealso>
          <link id="#lcl.Controls.TWndMethod">TWndMethod</link>
          <link id="#lcl.LMessages.TLMessage">TLMessage</link>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.DockOrientation">
        <short>
          <var>DockOrientation</var> - whether docking is oriented horizontally, vertically, according to pages or not at all</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.Floating">
        <descr/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.FloatingDockSiteClass">
        <short>The class of the floating host dock site.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.HostDockSite">
        <short>
          <var>HostDockSite</var> - the host site to which this control is docked</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.LRDockWidth">
        <short>The width when last docked with siblings left or right.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.TBDockHeight">
        <short>The height when last docked with siblings above or below.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.UndockHeight">
        <short>The height of the undocked control.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.UndockWidth">
        <short>The width of the undocked control.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControl.AnchorSideLeft">
        <short>Anchor to the left side</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControl.AnchorSideTop">
        <short>Anchor to the Top</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControl.AnchorSideRight">
        <short>Anchor to the right side</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControl.AnchorSideBottom">
        <short>Anchors to the bottom</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControl.Cursor">
        <short>The type of cursor to be used with this control</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControl.Left">
        <short>
          <var>Left</var>
 - the coordinate of the left edge of the control</short>
      </element>
      <!-- property Visibility: published -->
      <element name="TControl.Height">
        <short>
          <var>Height</var> - the vertical dimension of the control</short>
      </element>
      <!-- property Visibility: published -->
      <element name="TControl.Hint">
        <short>
          <var>Hint</var> - a small informative pop-up box that appears when the mouse 'hovers' over a control</short>
        <descr>
          <p>Requires <var>ShowHint</var> to be True</p>
        </descr>
      </element>
      <!-- property Visibility: published -->
      <element name="TControl.Top"/>
      <!-- property Visibility: published -->
      <element name="TControl.Width">
        <short>
          <var>Width </var> - the horizontal dimension of the control</short>
      </element>
      <!-- property Visibility: published -->
      <element name="TControl.HelpType">
        <short>The type of help to be used with this control - keyword or context</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControl.HelpKeyword">
        <short>The keyword to be used for Help in this control</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControl.HelpContext">
        <short>The context-sensitive help message to be used with this control</short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.FormEndUpdated">
        <short>
          <var>FormEndUpdated</var> - the update for the Form has ended</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.DisableAutoSizing">
        <short>Turn off automatic sizing - implies that default is accepted or sizing is done manually</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.EnableAutoSizing">
        <short>Turns on (enables) automatic sizing</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.WriteLayoutDebugReport">
        <short>Used for debugging</short>
      </element>
      <element name="TControl.WriteLayoutDebugReport.Prefix">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.GetTopParent">
        <short>Find which control is the top parent (ie ultimate ancestor)</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.GetTopParent.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.IsControlVisible">
        <short>Is the control visible on the current desktop?</short>
        <descr>
          <p>Does not check for invisible parents</p>
        </descr>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.IsControlVisible.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.FormIsUpdating">
        <short>True if the form is being updated</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.FormIsUpdating.Result">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.ActiveDefaultControlChanged">
        <short>The active default control [what's this?] has changed to <var>NewControl</var>.</short>
      </element>
      <element name="TControl.ActiveDefaultControlChanged.NewControl">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.ParentDestroyingHandle">
        <short>
          <var>ParentDestroyingHandle</var> - returns True if the parent control is destroying the Handle</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.ParentDestroyingHandle.Result">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.ShowHelp">
        <short>Procedure for displaying the Help associated with this control</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.HasHelp">
        <short>Indicates that this control has an entry in the Help-file</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.HasHelp.Result">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.CaptureMouseButtons">
        <short>Which mouse button(s) to be used for capture? Default left button, but may be a set of up to three</short>
        <descr/>
        <seealso/>
      </element>
      <!-- range type Visibility: default -->
      <element name="TBorderWidth">
        <short>Integer type defining width of the border of a control</short>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TGetChildProc">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TGetChildProc.Child">
        <short/>
      </element>
      <!-- object Visibility: default -->
      <element name="TControlChildSizing">
        <short>How Child controls are to be sized relative to parent.</short>
        <descr>
          <code>{ LeftRightSpacing, TopBottomSpacing: integer;
        minimum space between client border and nearest child control.
        For example: ClientLeftRight=5 means leftmost child's Left position is at least 5.

    HorizontalSpacing, VerticalSpacing: integer;
        minimum space between each child control.
  }

  {   Defines how child controls are resized/aligned.

      cesAnchorAligning, cssAnchorAligning
        Anchors and Align work like Delphi. For example if Anchors property of
        the control is [akLeft], it means fixed distance between left border of
        parent's client area. [akRight] means fixed distance between right
        border of the control and the right border of the parent's client area.
        When the parent is resized the child is moved to keep the distance.
        [akLeft,akRight] means fixed distance to left border and fixed distance
        to right border. When the parent is resized, the controls width is
        changed (resized) to keep the left and right distance.
        Same for akTop,akBottom.

        Align=alLeft for a control means set Left leftmost, Top topmost and
        maximize Height. The width is kept, if akRight is not set. If akRight
        is set in the Anchors property, then the right distance is kept and
        the control's width is resized.
        If there several controls with Align=alLeft, they will not overlapp and
        be put side by side.
        Same for alRight, alTop, alBottom. (Always expand 3 sides).

        Align=alClient. The control will fill the whole remaining space.
        Setting two children to Align=alClient does only make sense, if you set
        maximum Constraints.

        Order: First all alTop children are resized, then alBottom, then alLeft,
        then alRight and finally alClient.

      cesScaleChilds, cssScaleChilds
        Scale children, keep space between them fixed.
        Children are resized to their normal/advised size. If there is some space
        left in the client area of the parent, then the children are scaled to
        fill the space. You can set maximum Constraints. Then the other children
        are scaled more.
        For example: 3 child controls A, B, C with A.Width=10, B.Width=20 and
        C.Width=30 (total=60). If the Parent's client area has a ClientWidth of
        120, then the children are scaled with Factor 2.
        If B has a maximum constraint width of 30, then first the children will be
        scaled with 1.5 (A.Width=15, B.Width=30, C.Width=45). Then A and C
        (15+45=60 and 30 pixel space left) will be scaled by 1.5 again, to a
        final result of: A.Width=23, B.Width=30, C.Width=67 (23+30+67=120).

      cesHomogenousChildGrowth, cssHomogenousChildDecrease
        Enlarge children equally.
        Children are resized to their normal/advised size. If there is some space
        left in the client area of the parent, then the remaining space is
        distributed equally to each child.
        For example: 3 child controls A, B, C with A.Width=10, B.Width=20 and
        C.Width=30 (total=60). If the Parent's client area has a ClientWidth of
        120, then 60/3=20 is added to each Child.
        If B has a maximum constraint width of 30, then first 10 is added to
        all children (A.Width=20, B.Width=30, C.Width=40). Then A and C
        (20+40=60 and 30 pixel space left) will get 30/2=15 additional,
        resulting in: A.Width=35, B.Width=30, C.Width=55 (35+30+55=120).

      cesHomogenousSpaceGrowth
        Enlarge space between children equally.
        Children are resized to their normal/advised size. If there is some space
        left in the client area of the parent, then the space between the children
        is expanded.
        For example: 3 child controls A, B, C with A.Width=10, B.Width=20 and
        C.Width=30 (total=60). If the Parent's client area has a ClientWidth of
        120, then there will be 60/2=30 space between A and B and between
        B and C.
  }

</code>
        </descr>
        <errors/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControlChildSizing.FControl">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControlChildSizing.FEnlargeHorizontal">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControlChildSizing.FEnlargeVertical">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControlChildSizing.FHorizontalSpacing">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControlChildSizing.FLeftRightSpacing">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControlChildSizing.FOnChange">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControlChildSizing.FShrinkHorizontal">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControlChildSizing.FShrinkVertical">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControlChildSizing.FTopBottomSpacing">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControlChildSizing.FVerticalSpacing">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControlChildSizing.SetEnlargeHorizontal">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControlChildSizing.SetEnlargeHorizontal.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControlChildSizing.SetEnlargeVertical">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControlChildSizing.SetEnlargeVertical.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControlChildSizing.SetHorizontalSpacing">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControlChildSizing.SetHorizontalSpacing.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControlChildSizing.SetLeftRightSpacing">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControlChildSizing.SetLeftRightSpacing.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControlChildSizing.SetShrinkHorizontal">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControlChildSizing.SetShrinkHorizontal.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControlChildSizing.SetShrinkVertical">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControlChildSizing.SetShrinkVertical.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControlChildSizing.SetTopBottomSpacing">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControlChildSizing.SetTopBottomSpacing.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControlChildSizing.SetVerticalSpacing">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControlChildSizing.SetVerticalSpacing.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControlChildSizing.Change">
        <short>
          <var>Change</var> calls the 
          <var>OnChange</var> handler.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TControlChildSizing.Create">
        <short/>
        <descr/>
        <errors/>
        <seealso>
          <link id="#rtl.System.TObject.Create">TObject.Create</link>
        </seealso>
      </element>
      <element name="TControlChildSizing.Create.OwnerControl">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControlChildSizing.Assign" link="#rtl.Classes.TPersistent.Assign"/>
      <element name="TControlChildSizing.Assign.Source">
        <short></short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControlChildSizing.AssignTo" link="TPersistent.AssignTo"/>
      <element name="TControlChildSizing.AssignTo.Dest">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControlChildSizing.IsEqual">
        <short>
          <var>IsEqual</var> - returns True if the specified sizing is the same as the current value</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControlChildSizing.IsEqual.Result">
        <short/>
      </element>
      <element name="TControlChildSizing.IsEqual.Sizing">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControlChildSizing.Control">
        <short>The <var>Control</var> to which childsizing is to be applied</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControlChildSizing.OnChange">
        <short>
          <var>OnChange</var> - event handler for a chaange in sizing</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControlChildSizing.EnlargeHorizontal">
        <short>
          <var>EnlargeHorizontal</var> - make larger in the horizontal plane</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControlChildSizing.EnlargeVertical">
        <short>
          <var>EnlargeVertical</var> - make larger in the vertical plane</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControlChildSizing.ShrinkHorizontal">
        <short>
          <var>ShrinkHorizontal</var> - make smaller in the horizontal plane</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControlChildSizing.ShrinkVertical">
        <short>
          <var>ShrinkVertical</var> - make smaller in the vertical plane</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControlChildSizing.LeftRightSpacing">
        <short>
          <var>LeftRightSpacing</var> - spacing from left to right</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControlChildSizing.TopBottomSpacing">
        <short>
          <var>TopBottomSpacing</var> - spacing from top to bottom</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControlChildSizing.HorizontalSpacing">
        <short>
          <var>HorizontalSpacing</var> - spacing in the horizontal plane</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControlChildSizing.VerticalSpacing">
        <short>
          <var>VerticalSpacing</var> - spacing in the vertical plane</short>
        <descr/>
        <seealso/>
      </element>
      <!-- object Visibility: default -->
      <element name="TWinControlActionLink">
        <short>
          <var>TWinControlActionLink</var> - same as 
          <var>TControlActionLink</var>
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControlActionLink.AssignClient">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControlActionLink.AssignClient.AClient">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControlActionLink.IsHelpContextLinked">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControlActionLink.IsHelpContextLinked.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControlActionLink.SetHelpContext">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControlActionLink.SetHelpContext.Value">
        <short/>
      </element>
      <!-- "class of" type Visibility: default -->
      <element name="TWinControlActionLinkClass">
        <short>
          <var>TWinControlActionLinkClass</var> - class of 
          <var>TWinControlActionLink</var>
        </short>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TWinControlFlag">
        <short>State flags of TWinControl.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControlFlag.wcfClientRectNeedsUpdate">
        <short></short>
      </element>
      <element name="TWinControlFlag.wcfColorChanged">
        <short></short>
      </element>
      <element name="TWinControlFlag.wcfFontChanged">
        <short>Set if font was changed before handle creation.</short>
      </element>
      <element name="TWinControlFlag.wcfAllAutoSizing">
        <short>Set during DoAllAutosize.</short>
      </element>
      <element name="TWinControlFlag.wcfAligningControls">
        <short></short>
      </element>
      <element name="TWinControlFlag.wcfEraseBackground">
        <short></short>
      </element>
      <element name="TWinControlFlag.wcfCreatingHandle">
        <short>Set while constructing the handle of this control.</short>
      </element>
      <element name="TWinControlFlag.wcfInitializing">
        <short>Set while initializing during handle creation.</short>
      </element>
      <element name="TWinControlFlag.wcfCreatingChildHandles">
        <short>Set while constructing the handles of the children.</short>
      </element>
      <element name="TWinControlFlag.wcfRealizingBounds">
        <short>Set inside RealizeBoundsRecursive.</short>
      </element>
      <element name="TWinControlFlag.wcfBoundsRealized">
        <short>Set when bounds were sent to the interface.</short>
      </element>
      <element name="TWinControlFlag.wcfUpdateShowing">
        <short></short>
      </element>
      <element name="TWinControlFlag.wcfHandleVisible">
        <short/>
      </element>
      <element name="TWinControlFlag.wcfAdjustedLogicalClientRectValid">
        <short></short>
      </element>
      <element name="TWinControlFlag.wcfKillIntfSetBounds">
        <short></short>
      </element>
      <!-- set type Visibility: default -->
      <element name="TWinControlFlags" link="TWinControlFlag">
        <short>Set of TWinControlFlag.</short>
      </element>
      <!-- record type Visibility: default -->
      <element name="TAlignInfo">
        <short>needed for VCL compatibility on custom aligning[~]</short>
        <descr>This record was added only after D7.
          It may affect the CustomInsertBefore and CustomAlignPosition methods (dropped, overload?).
        </descr>
        <seealso>
        </seealso>
      </element>
      <element name="TAlignInfo.AlignList">
        <short>The list of controls currently being aligned.</short>
        <descr>
        </descr>
        <seealso>
        </seealso>
      </element>
      <element name="TAlignInfo.ControlIndex">
        <short>Index of current control [in AlignList?].</short>
        <descr>
        </descr>
        <seealso>
        </seealso>
      </element>
      <element name="TAlignInfo.Align">
        <short>The kind of alignment currently processed (always alCustom).</short>
        <descr>
        </descr>
        <seealso>
        </seealso>
      </element>
      <element name="TAlignInfo.Scratch">
        <short>[??? Declared in the VCL, not used and not documented]</short>
        <descr>
        </descr>
        <seealso>
        </seealso>
      </element>
      <!-- function type Visibility: default -->
      <element name="TAlignInsertBeforeEvent">
        <short></short>
        <descr>
        </descr>
        <seealso>
        </seealso>
      </element>
      <element name="TAlignInsertBeforeEvent.Result">
        <short></short>
      </element>
      <element name="TAlignInsertBeforeEvent.Sender">
        <short></short>
      </element>
      <element name="TAlignInsertBeforeEvent.Control1">
        <short></short>
      </element>
      <element name="TAlignInsertBeforeEvent.Control2">
        <short></short>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TAlignPositionEvent">
        <short></short>
        <descr>
        </descr>
        <seealso>
        </seealso>
      </element>
      <element name="TAlignPositionEvent.Sender">
        <short></short>
      </element>
      <element name="TAlignPositionEvent.Control">
        <short></short>
      </element>
      <element name="TAlignPositionEvent.NewLeft">
        <short></short>
      </element>
      <element name="TAlignPositionEvent.NewTop">
        <short></short>
      </element>
      <element name="TAlignPositionEvent.NewWidth">
        <short></short>
      </element>
      <element name="TAlignPositionEvent.NewHeight">
        <short></short>
      </element>
      <element name="TAlignPositionEvent.AlignRect">
        <short></short>
      </element>
      <element name="TAlignPositionEvent.AlignInfo">
        <short></short>
      </element>
      <!-- object Visibility: default -->
      <element name="TWinControl">
        <short>The base class for controls which can contain other (child) controls.</short>
        <descr>The name reflects the fact that (on Windows) these controls are based on OS provided widgets, which have window handles.
        </descr>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TWinControl.FBorderStyle" link="TWinControl.BorderStyle"/>
      <element name="TWinControl.FBorderWidth" link="TWinControl.BorderWidth"/>
      <element name="TWinControl.FBoundsLockCount" link="TWinControl.BoundsLockCount"/>
      <element name="TWinControl.FBoundsRealized" link="TControl.BoundsRealized"/>
      <element name="TWinControl.FBrush" link="TWinControl.Brush"/>
      <element name="TWinControl.FChildSizing" link="TWinControl.ChildSizing"/>
      <element name="TWinControl.FClientWidth" link="TWinControl.ClientWidth"/>
      <element name="TWinControl.FClientHeight" link="TWinControl.ClientHeight"/>
      <element name="TWinControl.FControls" link="TWinControl.Controls"/>
      <element name="TWinControl.FDefWndProc" link="TWinControl.DefWndProc"/>
      <element name="TWinControl.FDockClients" link="TWinControl.DockClients"/>
      <element name="TWinControl.FDockManager" link="TWinControl.DockManager"/>
      <element name="TWinControl.FDockSite" link="TWinControl.DockSite"/>
      <element name="TWinControl.FDoubleBuffered" link="TWinControl.DoubleBuffered"/>
      <element name="TWinControl.FHandle" link="TWinControl.Handle"/>
      <element name="TWinControl.FOnAlignInsertBefore" link="TWinControl.OnAlignInsertBefore"/>
      <element name="TWinControl.FOnAlignPosition" link="TWinControl.OnAlignPosition"/>
      <element name="TWinControl.FOnDockDrop" link="TWinControl.OnDockDrop"/>
      <element name="TWinControl.FOnDockOver" link="TWinControl.OnDockOver"/>
      <element name="TWinControl.FOnGetDockCaption" link="TWinControl.OnGetDockCaption"/>
      <element name="TWinControl.FOnGetSiteInfo" link="TWinControl.OnGetSiteInfo"/>
      <element name="TWinControl.FOnKeyDown" link="TWinControl.OnKeyDown"/>
      <element name="TWinControl.FOnKeyPress" link="TWinControl.OnKeyPress"/>
      <element name="TWinControl.FOnKeyUp" link="TWinControl.OnKeyUp"/>
      <element name="TWinControl.FOnMouseWheel" link="TWinControl.OnMouseWheel"/>
      <element name="TWinControl.FOnMouseWheelDown" link="TWinControl.OnMouseWheelDown"/>
      <element name="TWinControl.FOnMouseWheelUp" link="TWinControl.OnMouseWheelUp"/>
      <element name="TWinControl.FOnEnter" link="TWinControl.OnEnter"/>
      <element name="TWinControl.FOnExit" link="TWinControl.OnExit"/>
      <element name="TWinControl.FOnUnDock" link="TWinControl.OnUnDock"/>
      <element name="TWinControl.FOnUTF8KeyPress" link="TWinControl.OnUTF8KeyPress"/>
      <element name="TWinControl.FParentCtl3D" link="TWinControl.ParentCtl3D"/>
      <element name="TWinControl.FParentWindow" link="TWinControl.ParentWindow"/>
      <element name="TWinControl.FShowing" link="TWinControl.Showing"/>
      <element name="TWinControl.FTabOrder" link="TWinControl.TabOrder"/>
      <element name="TWinControl.FTabStop" link="TWinControl.TabStop"/>
      <element name="TWinControl.FUseDockManager" link="TWinControl.UseDockManager"/>
      <!-- variable Visibility: private -->
      <element name="TWinControl.FAlignOrder">
        <short></short>
        <descr>
        </descr>
        <seealso>
        </seealso>
      </element>
      <!-- variable Visibility: private -->
      <element name="TWinControl.FAlignLevel">
        <short>[replaced by FAlignOrder? dropped?]</short>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TWinControl.FAdjustClientRectRealized">
        <short></short>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TWinControl.FAdjustClientRect">
        <short>valid if wcfAdjustClientRectValid</short>
        <descr>
        </descr>
        <seealso>
        </seealso>
      </element>
      <!-- variable Visibility: private -->
      <element name="TWinControl.FWinControlFlags">
        <short>
          <var>FWinControlFlags</var> - local variable to hold status flags</short>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TWinControl.FRealizeBoundsLockCount">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TWinControl.FTabList">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TWinControl.FWinControls">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TWinControl.AlignControl">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.AlignControl.AControl">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TWinControl.AlignNonAlignedControls">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.AlignNonAlignedControls.ListOfControls">
        <short/>
      </element>
      <element name="TWinControl.AlignNonAlignedControls.BoundsModified">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TWinControl.IsClientHeightStored" link="#LCL.Controls.TControl.IsClientHeightStored"/>
      <element name="TWinControl.IsClientHeightStored.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TWinControl.IsClientWidthStored" link="#LCL.Controls.TControl.IsClientWidthStored"/>
      <element name="TWinControl.IsClientWidthStored.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TWinControl.GetBrush" link="TWinControl.Brush"/>
      <element name="TWinControl.GetBrush.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TWinControl.GetControl" link="TWinControl.Controls"/>
      <element name="TWinControl.GetControl.Result">
        <short/>
      </element>
      <element name="TWinControl.GetControl.Index">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TWinControl.GetControlCount" link="TWinControl.ControlCount"/>
      <element name="TWinControl.GetControlCount.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TWinControl.GetDockClientCount" link="TWinControl.DockClientCount"/>
      <element name="TWinControl.GetDockClientCount.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TWinControl.GetDockClients" link="TWinControl.DockClients"/>
      <element name="TWinControl.GetDockClients.Result">
        <short/>
      </element>
      <element name="TWinControl.GetDockClients.Index">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TWinControl.GetHandle" link="TWinControl.Handle"/>
      <element name="TWinControl.GetHandle.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TWinControl.GetIsResizing" link="TWinControl.IsResizing"/>
      <element name="TWinControl.GetIsResizing.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TWinControl.GetTabOrder" link="TWinControl.TabOrder"/>
      <element name="TWinControl.GetTabOrder.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TWinControl.GetVisibleDockClientCount">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.GetVisibleDockClientCount.Result">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TWinControl.SetChildSizing" link="TWinControl.ChildSizing"/>
      <element name="TWinControl.SetChildSizing.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.SetDockManager" link="TWinControl.DockManager"/>
      <element name="TWinControl.SetDockManager.AMgr">
        <short></short>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TWinControl.SetDockSite" link="TWinControl.DockSite"/>
      <element name="TWinControl.SetDockSite.NewDockSite">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TWinControl.SetHandle" link="TWinControl.Handle"/>
      <element name="TWinControl.SetHandle.NewHandle">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TWinControl.SetBorderWidth" link="TWinControl.BorderWidth"/>
      <element name="TWinControl.SetBorderWidth.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TWinControl.SetParentCtl3D" link="TControl.ParentCtl3D"/>
      <element name="TWinControl.SetParentCtl3D.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TWinControl.SetParentWindow" link="TWinControl.ParentWindow"/>
      <element name="TWinControl.SetParentWindow.AValue">
        <short></short>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TWinControl.SetTabOrder" link="TWinControl.TabOrder"/>
      <element name="TWinControl.SetTabOrder.NewTabOrder">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TWinControl.SetTabStop" link="TWinControl.TabStop"/>
      <element name="TWinControl.SetTabStop.NewTabStop">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TWinControl.SetUseDockManager" link="TWinControl.UseDockManager"/>
      <element name="TWinControl.SetUseDockManager.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TWinControl.UpdateTabOrder">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.UpdateTabOrder.NewTabOrder">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TWinControl.WantsKeyBeforeInterface">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.WantsKeyBeforeInterface.Result">
        <short/>
      </element>
      <element name="TWinControl.WantsKeyBeforeInterface.Key">
        <short/>
      </element>
      <element name="TWinControl.WantsKeyBeforeInterface.Shift">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.AssignTo"/>
      <element name="TWinControl.AssignTo.Dest">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.ActionChange">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.ActionChange.Sender">
        <short/>
      </element>
      <element name="TWinControl.ActionChange.CheckDefaults">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.GetActionLinkClass">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.GetActionLinkClass.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.AdjustClientRect">
        <short>
          <var>AdjustClientRect</var> - method for adjusting the size and position of the client control</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.AdjustClientRect.ARect">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.AlignControls">
        <short>
          <var>AlignControls</var> - align a control within the given client rectangle.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.AlignControls.AControl">
        <short/>
      </element>
      <element name="TWinControl.AlignControls.RemainingClientRect">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CreateControlAlignList">
        <short>
          <var>CreateControlAlignList</var> - creates a list of the controls that are aligned with the present window control</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.CreateControlAlignList.TheAlign">
        <short/>
      </element>
      <element name="TWinControl.CreateControlAlignList.AlignList">
        <short/>
      </element>
      <element name="TWinControl.CreateControlAlignList.StartControl">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.ResizeDelayedAutoSizeChildren">
        <short>
          <var>ResizeDelayedAutoSizeChildren</var> - method for re-sizing children, using autosize delayed</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.DoAlignChildControls">
        <short>
          <var>DoAlignChildControls</var> - method for aligning child controls from a list; returns True if successful</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.DoAlignChildControls.Result">
        <short/>
      </element>
      <element name="TWinControl.DoAlignChildControls.TheAlign">
        <short/>
      </element>
      <element name="TWinControl.DoAlignChildControls.AControl">
        <short/>
      </element>
      <element name="TWinControl.DoAlignChildControls.AControlList">
        <short/>
      </element>
      <element name="TWinControl.DoAlignChildControls.ARect">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.DoChildSizingChange">
        <short>
          <var>DoChildSizingChange</var> - method for changing size of a child component</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.DoChildSizingChange.Sender">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.CanTab" link="#LCL.Controls.TControl.CanTab"/>
      <element name="TWinControl.CanTab.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.DoDragMsg">
        <short>Dispatch a drag message, sent by the DragManager</short>
        <descr>
          <p>On dmFindTarget a TWinControl returns the child control under the mouse, or Self if none is found.</p>
          <p>All other messages are handled by inherited <link id="TControl.DoDragMsg"/>.</p>
        </descr>
        <seealso>
          <link id="#LCL.Controls.TControl.DoDragMsg"/>
        </seealso>
      </element>
      <element name="TWinControl.DoDragMsg.Result">
        <short/>
      </element>
      <element name="TWinControl.DoDragMsg.ADragMessage">
        <short/>
      </element>
      <element name="TWinControl.DoDragMsg.APosition">
        <short/>
      </element>
      <element name="TWinControl.DoDragMsg.ADragObject">
        <short/>
      </element>
      <element name="TWinControl.DoDragMsg.ATarget">
        <short/>
      </element>
      <element name="TWinControl.DoDragMsg.ADocking">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.DoDockClientMsg">
        <short>Handles dmDragDock message, when a control has been docked to this site.</short>
        <descr>
          <p>Called when a control is dropped for docking.</p>
          <p>Asks the dropped control to Dock itself into this control (adjust HostDockSite etc.).<br/>
            Calls an installed DockManager to adjust the coordinates of the docked control.</p>
          <p>The Result is always True (unless overridden).</p>
        </descr>
      </element>
      <element name="TWinControl.DoDockClientMsg.Result">
        <short/>
      </element>
      <element name="TWinControl.DoDockClientMsg.DragDockObject">
        <short/>
      </element>
      <element name="TWinControl.DoDockClientMsg.aPosition">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.DoUndockClientMsg">
        <short>Notifies the DockManager of the undock of a client control; always returns True.</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="TDockManager.RemoveControl"/>
        </seealso>
      </element>
      <element name="TWinControl.DoUndockClientMsg.Result">
        <short/>
      </element>
      <element name="TWinControl.DoUndockClientMsg.NewTarget">
        <short/>
      </element>
      <element name="TWinControl.DoUndockClientMsg.Client">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CMBiDiModeChanged">
        <short>Message handler for
          changed <var>BiDiMode</var> property
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.CMBiDiModeChanged.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CMBorderChanged">
        <short>Handler for
          changed <var>Border</var>
          message.</short>
      </element>
      <element name="TWinControl.CMBorderChanged.Message">
        <short></short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CMDrag">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.CMDrag.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CMShowingChanged">
        <short>
          <var>CMShowingChanged</var> - control message when Showing property is changed</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.CMShowingChanged.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CMVisibleChanged">
        <short>
          <var>CMVisibleChanged</var> - control message when Visible property is changed</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.CMVisibleChanged.TheMessage">
        <short/>
      </element>
      <element name="TWinControl.CMVisibleChanged.Message">
        <short></short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CMEnter">
        <short></short>
        <descr>
        </descr>
        <errors>
        </errors>
        <seealso>
        </seealso>
      </element>
      <element name="TWinControl.CMEnter.Message">
        <short></short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CMExit">
        <short></short>
        <descr>
        </descr>
        <errors>
        </errors>
        <seealso>
        </seealso>
      </element>
      <element name="TWinControl.CMExit.Message">
        <short></short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WMContextMenu">
        <short></short>
        <descr>
        </descr>
        <errors>
        </errors>
        <seealso>
        </seealso>
      </element>
      <element name="TWinControl.WMContextMenu.Message">
        <short></short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WMWindowPosChanged">
        <short></short>
        <descr>
        </descr>
        <errors>
        </errors>
        <seealso>
        </seealso>
      </element>
      <element name="TWinControl.WMWindowPosChanged.Message">
        <short></short>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.ContainsControl">
        <short>This component contains a specified control</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.ContainsControl.Result">
        <short/>
      </element>
      <element name="TWinControl.ContainsControl.Control">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.ControlsAligned">
        <short>
          <var>ControlsAligned</var> - called by AlignControls after aligning controls</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.DoSendBoundsToInterface">
        <short>
          <var>DoSendBoundsToInterface</var> - sends information about the control's bounds to the interface</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.DoSendShowHideToInterface">
        <descr/>
        <errors/>
        <seealso/>
        <short>
          <var>DoSendShowHideToInterface</var> - send the Show/Hide status to the interface</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.RealizeBounds">
        <short>
          <var>RealizeBounds</var> - checks for changes and calls DoSendBoundsToInterface</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.RealizeBoundsRecursive">
        <short>
          <var>RealizeBoundsRecursive</var> - perform
          <var>RealizeBounds</var> in a recursive manner</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CreateSubClass">
        <short>
          <var>CreateSubClass</var> - creates a sub-class using the supplied parameters</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.CreateSubClass.Params">
        <short/>
      </element>
      <element name="TWinControl.CreateSubClass.ControlClassName">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.DestroyComponent">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.DoConstraintsChange" link="#LCL.Controls.TControl.DoConstraintsChange"/>
      <element name="TWinControl.DoConstraintsChange.Sender">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.DoSetBounds">
        <short>
          <var>DoSetBounds</var> - anticipate the new clientwidth/height and call inherited method</short>
        <descr>
          <p>Anticipate the new clientwidth/height and call inherited method</p>
          <p>Normally the clientwidth/clientheight is adjusted automatically by the interface. But it is up to interface when this will be done. The gtk for example just puts resize requests into a queue. The LCL would resize the child components just after this procedure due to the clientrect. On complex forms with lots of nested controls, this would result in thousands of resizes.</p>
          <p>Changing the clientrect in the LCL to the most probable size reduces unneccessary resizes.</p>
        </descr>
        <seealso>
          <link id="#LCL.Controls.TControl.DoSetBounds"/>
        </seealso>
      </element>
      <element name="TWinControl.DoSetBounds.ALeft">
        <short/>
      </element>
      <element name="TWinControl.DoSetBounds.ATop">
        <short/>
      </element>
      <element name="TWinControl.DoSetBounds.AWidth">
        <short/>
      </element>
      <element name="TWinControl.DoSetBounds.AHeight">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.DoAutoSize">
        <short>
          <var>DoAutoSize</var> - performs a lot of calculations and adjustments of child components in the window before automatically adjusting the size of the window itself</short>
        <descr>
          <p>
            <printshort id="TWinControl.DoAutoSize"/>
          </p>
          <ul>
            <li>Checks whether Autosize is in fact permitted</li>
            <li>Checks for unaligned child components and fits them in as best it can</li>
            <li>Moves the constrained (aligned) child components to the correct position</li>
            <li>Adjusts the size of the client rectangle</li>
            <li>Adjusts the bounds of the whole control</li>
          </ul>
          <p>Because this method involves so much overhead, the simpler <link id="#lcl.Controls.TControl.AdjustSize">TControl.AdjustSize</link> is often called instead.</p>
        </descr>
        <errors/>
        <seealso>
          <link id="#LCL.Controls.TControl.DoAutoSize">TControl.DoAutoSize</link>
        </seealso>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CalculatePreferredSize">
        <short>
          <var>CalculatePreferredSize</var> returns the default/preferred width and height for a TWinControl, for use by LCL autosizing.</short>
        <descr>
          <p>Calls the inherited method to calculate the default/preferred width and height for a <var>TWinControl</var>, which is used by the LCL autosizing algorithms as default size.
            Only positive values are valid. Negative or 0 are treated as undefined and the LCL uses other sizes instead.</p>
          <p>
            <var>TWinControl</var> overrides this:</p>
          <ul>
            <li>If there are child components, their total preferred size is calculated</li>
            <li>If this value can not be computed (e.g. the children depend too much on their
              parent clientrect), then the interface is asked for the preferred size</li>
          </ul>
          <p>For example the preferred size of a <var>TButton</var> is the size, where the label fits
            exactly. This depends heavily on the current theme and widgetset.</p>
          <p>This value is independent of constraints and siblings, only the inner parts are relevant.</p>
          <p>
            <var>WithThemeSpace</var>: If true, adds space for stacking. For example:
            <var>TRadioButton</var> has a minimum size. But for stacking multiple TRadioButtons there should be some space around.
            This space is theme dependent, so it is passed as a parameter to the widgetset. </p>
        </descr>
        <errors/>
        <seealso>
          <link id="#LCL.Controls.TControl.CalculatePreferredSize">TControl.CalculatePreferredSize</link>
        </seealso>
      </element>
      <element name="TWinControl.CalculatePreferredSize.PreferredWidth">
        <short/>
      </element>
      <element name="TWinControl.CalculatePreferredSize.PreferredHeight">
        <short/>
      </element>
      <element name="TWinControl.CalculatePreferredSize.WithThemeSpace">
        <short/>
      </element>
      <element name="TWinControl.CustomAlignInsertBefore">
        <short>Invokes the <var>OnAlignInsertBefore</var> event handler.</short>
      </element>
      <element name="TWinControl.CustomAlignInsertBefore.Result">
        <short></short>
      </element>
      <element name="TWinControl.CustomAlignInsertBefore.AControl1">
        <short></short>
      </element>
      <element name="TWinControl.CustomAlignInsertBefore.AControl2">
        <short></short>
      </element>
      <element name="TWinControl.CustomAlignPosition">
        <short>Invokes the <var>OnAlignPosition</var> handler.</short>
      </element>
      <element name="TWinControl.CustomAlignPosition.AControl">
        <short></short>
      </element>
      <element name="TWinControl.CustomAlignPosition.ANewLeft">
        <short></short>
      </element>
      <element name="TWinControl.CustomAlignPosition.ANewTop">
        <short></short>
      </element>
      <element name="TWinControl.CustomAlignPosition.ANewWidth">
        <short></short>
      </element>
      <element name="TWinControl.CustomAlignPosition.ANewHeight">
        <short></short>
      </element>
      <element name="TWinControl.CustomAlignPosition.AlignRect">
        <short></short>
      </element>
      <element name="TWinControl.CustomAlignPosition.AlignInfo">
        <short></short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.DoAllAutoSize" link="TControl.DoAllAutoSize"/>
      <!-- function Visibility: protected -->
      <element name="TWinControl.AutoSizeCanStart">
        <short></short>
        <descr>
        </descr>
        <errors>
        </errors>
        <seealso>
        </seealso>
      </element>
      <element name="TWinControl.AutoSizeCanStart.Result">
        <short></short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.AllAutoSized">
        <short>called by DoAllAutoSize after all bounds are computed</short>
        <descr>
        </descr>
        <errors>
        </errors>
        <seealso>
          <link id="#lcl.forms.TCustomForm.AllAutoSized"/>
        </seealso>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.ScaleControls">
        <short>Change the scale of all child controls.</short>
        <descr>
        </descr>
        <errors>
        </errors>
        <seealso>
        </seealso>
      </element>
      <element name="TWinControl.ScaleControls.Multiplier">
        <short></short>
      </element>
      <element name="TWinControl.ScaleControls.Divider">
        <short></short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.ChangeScale" link="TControl.ChangeScale">
        <short>Overridden to also change the scale of all child controls.</short>
        <descr>
        </descr>
        <errors>
        </errors>
        <seealso>
        </seealso>
      </element>
      <element name="TWinControl.ChangeScale.Multiplier">
        <short></short>
      </element>
      <element name="TWinControl.ChangeScale.Divider">
        <short></short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.ScrollBy">
        <short></short>
        <descr>
        </descr>
        <errors>
        </errors>
        <seealso>
        </seealso>
      </element>
      <element name="TWinControl.ScrollBy.DeltaX">
        <short></short>
      </element>
      <element name="TWinControl.ScrollBy.DeltaY">
        <short></short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.ScaleBy">
        <short></short>
        <descr>
        </descr>
        <errors>
        </errors>
        <seealso>
        </seealso>
      </element>
      <element name="TWinControl.ScaleBy.Multiplier">
        <short></short>
      </element>
      <element name="TWinControl.ScaleBy.Divider">
        <short></short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.GetChildBounds">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.GetChildBounds.ChildBounds">
        <short/>
      </element>
      <element name="TWinControl.GetChildBounds.WithBorderSpace">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.GetAdjustedLogicalClientRect">
        <short></short>
        <descr>
        </descr>
        <errors>
        </errors>
        <seealso>
        </seealso>
      </element>
      <element name="TWinControl.GetAdjustedLogicalClientRect.ARect">
        <short></short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.GetChildren">
        <short>
          <var>GetChildren</var> - makes a list of all the child components for this control</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#rtl.Classes.TComponent.GetChildren">TComponent.GetChildren</link>
        </seealso>
      </element>
      <element name="TWinControl.GetChildren.Proc">
        <short/>
      </element>
      <element name="TWinControl.GetChildren.Root">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.ChildClassAllowed">
        <short>
          <var>ChildClassAllowed</var> - returns True if the given child class is permitted</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.ChildClassAllowed.Result">
        <short/>
      </element>
      <element name="TWinControl.ChildClassAllowed.ChildClass">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.PaintControls">
        <short>
          <var>PaintControls</var> - method for painting a series of controls</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.PaintControls.DC">
        <short/>
      </element>
      <element name="TWinControl.PaintControls.First">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.PaintHandler">
        <short>
          <var>PaintHandler</var> - message handler for painting</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.PaintHandler.TheMessage">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.PaintWindow">
        <short>
          <var>PaintWindow</var> - method for painting a window</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.PaintWindow.DC">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CreateBrush">
        <short>
          <var>CreateBrush</var> - method to create a brush for painting</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.WSRegisterClass" link="#LCL.LCLClasses.TLCLComponent.WSRegisterClass"/>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CMEnabledChanged">
        <short>Message handler for a change in the <var>Enabled</var> property.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.CMEnabledChanged.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CMShowHintChanged">
        <short>Message handler, notifies child controls of a change in the <var>ShowHint</var> property.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.CMShowHintChanged.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WMEraseBkgnd">
        <short>
          <var>WMEraseBkgnd</var> - LCL message for erasing background</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.WMEraseBkgnd.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WMNotify">
        <short>
          <var>WMNotify</var> - LCL Notify message</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.WMNotify.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WMSetFocus">
        <short>
          <var>WMSetFocus</var> - LCL Message to set focus</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.WMSetFocus.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WMKillFocus">
        <short>
          <var>WMKillFocus</var> - LCL Message to kill focus</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.WMKillFocus.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WMShowWindow">
        <short>
          <var>WMShowWindow</var> - LCL Message to show window</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.WMShowWindow.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WMEnter">
        <short>
          <var>WMEnter</var> - LCL Message for entry to the control</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.WMEnter.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WMExit">
        <short>
          <var>WMExit</var> - LCL Message for exit from control</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.WMExit.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WMMouseWheel">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.WMMouseWheel.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WMKeyDown">
        <short>
          <var>WMKeyDown</var> - LCL Message for a key down</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.WMKeyDown.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WMSysKeyDown">
        <short>
          <var>WMSysKeyDown</var> - LCL Message for a system key down</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.WMSysKeyDown.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WMKeyUp">
        <short>
          <var>WMKeyUp</var> - LCL Message for a key up</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.WMKeyUp.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WMSysKeyUp">
        <short>
          <var>WMSysKeyUp</var> - LCL Message for a system key up</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.WMSysKeyUp.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WMChar">
        <short>
          <var>WMChar</var> - LCL Message signifying a character</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.WMChar.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WMSysChar">
        <short>
          <var>WMSysChar</var> - LCL Message signifying a system character</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.WMSysChar.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WMPaint">
        <short>
          <var>WMPaint</var> - LCL Message for Paint</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.WMPaint.Msg">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WMDestroy">
        <short>
          <var>WMDestroy</var> - LCL Message for control destruction</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.WMDestroy.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WMMove">
        <short>
          <var>WMMove</var> - LCL Message for movement</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.WMMove.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WMSize">
        <short>
          <var>WMSize</var> - LCL Message for sizing control</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.WMSize.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CNKeyDown">
        <short>
          <var>CNKeyDown</var> - control message for key down</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.CNKeyDown.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CNSysKeyDown">
        <short>
          <var>CNSysKeyDown</var> - control message for system key down</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.CNSysKeyDown.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CNKeyUp">
        <short>
          <var>CNKeyUp</var> - control message for key up</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.CNKeyUp.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CNSysKeyUp">
        <short>
          <var>CNSysKeyUp</var> - control message for system key up</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.CNSysKeyUp.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CNChar">
        <short>
          <var>CNChar</var> - control message specifying a character</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.CNChar.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CNSysChar">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.CNSysChar.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.DoAddDockClient">
        <short>Adjust the Parent of the docked Client.</short>
        <descr>The default action is to set the Parent to the new docksite (this control), so that the client is displayed within the new site.</descr>
      </element>
      <element name="TWinControl.DoAddDockClient.Client">
        <short/>
      </element>
      <element name="TWinControl.DoAddDockClient.ARect">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.DockOver">
        <short>Position DockRect, invoke OnDockOver (via DoDockOver)</short>
        <descr>
          <p>Called on dragmanager messages dmEnter/Leave/Move, to get the DockRect to show.</p>
          <p>Accept has been set to True, to signal acceptance.</p>
          <p>Everything can be overridden by the OnDockOver handler, if installed.</p>
        </descr>
        <seealso>
          <link id="TControl.PositionDockRect"/>
        </seealso>
      </element>
      <element name="TWinControl.DockOver.Source">
        <short/>
      </element>
      <element name="TWinControl.DockOver.X">
        <short/>
      </element>
      <element name="TWinControl.DockOver.Y">
        <short/>
      </element>
      <element name="TWinControl.DockOver.State">
        <short/>
      </element>
      <element name="TWinControl.DockOver.Accept">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.DoDockOver">
        <short>Invoke the <link id="TWinControl.OnDockOver">OnDockOver</link> handler.</short>
      </element>
      <element name="TWinControl.DoDockOver.Source">
        <short/>
      </element>
      <element name="TWinControl.DoDockOver.X">
        <short/>
      </element>
      <element name="TWinControl.DoDockOver.Y">
        <short/>
      </element>
      <element name="TWinControl.DoDockOver.State">
        <short/>
      </element>
      <element name="TWinControl.DoDockOver.Accept">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.DoRemoveDockClient">
        <short>Perform special actions on removal of an docked client.</short>
        <descr>The default implementation does nothing.</descr>
      </element>
      <element name="TWinControl.DoRemoveDockClient.Client">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.DoUnDock">
        <short>Notifies an <var>OnUnDock</var> handler and DockManager of the undocked client control.</short>
        <descr>The OnUnDock handler can deny to undock the control.</descr>
        <errors/>
        <seealso>
          <link id="TWinControl.DoUndockClientMsg"/>
        </seealso>
      </element>
      <element name="TWinControl.DoUnDock.Result">
        <short/>
      </element>
      <element name="TWinControl.DoUnDock.NewTarget">
        <short/>
      </element>
      <element name="TWinControl.DoUnDock.Client">
        <short/>
      </element>
      <element name="TWinControl.DoUnDock.KeepDockSiteSize">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.GetSiteInfo">
        <short>Return information about this dock site (InfluenceRect).</short>
        <descr>The InfluenceRect determines the screen coordinates, within which a drop is accepted.<br/>
          The InfluenceRect is the slightly inflated WindowRect of the dock site, adjustable in an OnGetSiteInfo handler.
        </descr>
      </element>
      <element name="TWinControl.GetSiteInfo.Client">
        <short/>
      </element>
      <element name="TWinControl.GetSiteInfo.InfluenceRect">
        <short/>
      </element>
      <element name="TWinControl.GetSiteInfo.MousePos">
        <short/>
      </element>
      <element name="TWinControl.GetSiteInfo.CanDock">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.ReloadDockedControl">
        <short>Returns the docked control of the specified name.</short>
        <descr>
          <p>The control is searched in the controls owned by the owner of this control.</p>
          <p>Override to search other places, or to create a control of the requested name.</p>
        </descr>
      </element>
      <element name="TWinControl.ReloadDockedControl.AControlName">
        <short/>
      </element>
      <element name="TWinControl.ReloadDockedControl.AControl">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.UpdateDockCaption">
        <short>Updates the Caption to reflect the names of the docked clients.</short>
        <descr>
          <p>Called when this is a hostdocksite and either the list of docked clients have changed, or one of their captions.</p>
          <p>When a control is currently being undocked, but still is in the DockClients list, Exclude is set to this control.</p>
        </descr>
        <errors>
        </errors>
        <seealso>
        </seealso>
      </element>
      <element name="TWinControl.UpdateDockCaption.Exclude">
        <short>Control to be excluded from the DockCaption.</short>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.CreateDockManager">
        <short>Returns the DockManager for this control.</short>
        <descr>If DockManager is nil, and UseDockManager is True, a new default DockManager is created.</descr>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.CreateDockManager.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.DoEnter">
        <short>Invoke the <var>OnEnter</var> event handler.</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.DoExit">
        <short>Invoke the <var>OnExit</var> event handler.</short>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.DoMouseWheel">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.DoMouseWheel.Result">
        <short/>
      </element>
      <element name="TWinControl.DoMouseWheel.Shift">
        <short/>
      </element>
      <element name="TWinControl.DoMouseWheel.WheelDelta">
        <short/>
      </element>
      <element name="TWinControl.DoMouseWheel.MousePos">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.DoMouseWheelDown">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.DoMouseWheelDown.Result">
        <short/>
      </element>
      <element name="TWinControl.DoMouseWheelDown.Shift">
        <short/>
      </element>
      <element name="TWinControl.DoMouseWheelDown.MousePos">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.DoMouseWheelUp">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.DoMouseWheelUp.Result">
        <short/>
      </element>
      <element name="TWinControl.DoMouseWheelUp.Shift">
        <short/>
      </element>
      <element name="TWinControl.DoMouseWheelUp.MousePos">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.DoKeyDownBeforeInterface">
        <short>
          <var>DoKeyDownBeforeInterface</var> - issues a message to the interface and returns True if a key was already down</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.DoKeyDownBeforeInterface.Result">
        <short/>
      </element>
      <element name="TWinControl.DoKeyDownBeforeInterface.Message">
        <short/>
      </element>
      <element name="TWinControl.DoKeyDownBeforeInterface.IsRecurseCall">
        <short></short>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.DoRemainingKeyDown">
        <short>
          <var>DoRemainingKeyDown</var> - issues a LCL message and returns True if a key remains down</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.DoRemainingKeyDown.Result">
        <short/>
      </element>
      <element name="TWinControl.DoRemainingKeyDown.Message">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.DoRemainingKeyPress">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.DoRemainingKeyPress.Result">
        <short/>
      </element>
      <element name="TWinControl.DoRemainingKeyPress.Message">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.DoRemainingKeyUp">
        <short>
          <var>DoRemainingKeyUp</var> - issues a LCL message and returns True if a key remains up</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.DoRemainingKeyUp.Result">
        <short/>
      </element>
      <element name="TWinControl.DoRemainingKeyUp.Message">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.DoKeyPress">
        <short>
          <var>DoKeyPress</var> - issues a LCL message and returns True if a key is pressed</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.DoKeyPress.Result">
        <short/>
      </element>
      <element name="TWinControl.DoKeyPress.Message">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.DoUTF8KeyPress">
        <short>
          <var>DoUTF8KeyPress</var> - issues a LCL message and returns True if there has been a UTF8 key press</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.DoUTF8KeyPress.Result">
        <short/>
      </element>
      <element name="TWinControl.DoUTF8KeyPress.UTF8Key">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.DoKeyUpBeforeInterface">
        <short>
          <var>DoKeyUpBeforeInterface</var> - issues an interface message and returns True if a key was already up</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.DoKeyUpBeforeInterface.Result">
        <short/>
      </element>
      <element name="TWinControl.DoKeyUpBeforeInterface.Message">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.ChildKey">
        <short>
          <var>ChildKey</var> - LCL message: returns True if this is a child key</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.ChildKey.Result">
        <short/>
      </element>
      <element name="TWinControl.ChildKey.Message">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.DialogChar" link="#LCL.Controls.TControl.DialogChar"/>
      <element name="TWinControl.DialogChar.Result">
        <short/>
      </element>
      <element name="TWinControl.DialogChar.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.ControlKeyDown">
        <short>
          <var>ControlKeyDown</var> - contains the set of special keys (shift, control, alt, meta) that are pressed</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.ControlKeyDown.Key">
        <short/>
      </element>
      <element name="TWinControl.ControlKeyDown.Shift">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.ControlKeyUp">
        <short>
          <var>ControlKeyUp</var> - contains the set of special keys (shift, control, alt, meta) that are not pressed ('up')</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.ControlKeyUp.Key">
        <short/>
      </element>
      <element name="TWinControl.ControlKeyUp.Shift">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.KeyDown">
        <short>The <var>KeyDown</var> message handler, calls <var>OnKeyDown</var>.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.KeyDown.Key">
        <short/>
      </element>
      <element name="TWinControl.KeyDown.Shift">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.KeyDownBeforeInterface">
        <short>
          <var>KeyDownBeforeInterface</var> - informs interface that the specified key (with defined shift state) was already pressed</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.KeyDownBeforeInterface.Key">
        <short/>
      </element>
      <element name="TWinControl.KeyDownBeforeInterface.Shift">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.KeyDownAfterInterface">
        <short>
          <var>KeyDownAfterInterface</var> - informs interface that the specified key (with defined shift state) was pressed after an event</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.KeyDownAfterInterface.Key">
        <short/>
      </element>
      <element name="TWinControl.KeyDownAfterInterface.Shift">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.KeyPress">
        <short>The <var>KeyPress</var> message handler.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.KeyPress.Key">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.KeyUp">
        <short>The KeyUp message handler, calls <var>OnKeyUp</var>.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.KeyUp.Key">
        <short/>
      </element>
      <element name="TWinControl.KeyUp.Shift">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.KeyUpBeforeInterface">
        <short>
          <var>KeyUpBeforeInterface</var> - informs interface that the specified key (with defined shift state) was already up</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.KeyUpBeforeInterface.Key">
        <short/>
      </element>
      <element name="TWinControl.KeyUpBeforeInterface.Shift">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.KeyUpAfterInterface">
        <short>
          <var>KeyUpAfterInterface</var> - informs interface that the specified key (with defined shift state) was released (up) after an event</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.KeyUpAfterInterface.Key">
        <short/>
      </element>
      <element name="TWinControl.KeyUpAfterInterface.Shift">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.UTF8KeyPress">
        <short>
          <var>UTF8KeyPress</var> - simulates the action of pressing the specified (UTF8) key</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.UTF8KeyPress.UTF8Key">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.FindNextControl">
        <short>
          <var>FindNextControl</var> - returns the next control on the list; optionally checks if it is a TabStop or a parent control</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.FindNextControl.Result">
        <short/>
      </element>
      <element name="TWinControl.FindNextControl.CurrentControl">
        <short/>
      </element>
      <element name="TWinControl.FindNextControl.GoForward">
        <short/>
      </element>
      <element name="TWinControl.FindNextControl.CheckTabStop">
        <short/>
      </element>
      <element name="TWinControl.FindNextControl.CheckParent">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.RealGetText" link="#LCL.Controls.TControl.RealGetText"/>
      <element name="TWinControl.RealGetText.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.GetBorderStyle">
        <short>
          <var>GetBorderStyle</var> - returns the style of the border</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.GetBorderStyle.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.GetChildsRect" link="#LCL.Controls.TControl.GetChildsRect"/>
      <element name="TWinControl.GetChildsRect.Result">
        <short/>
      </element>
      <element name="TWinControl.GetChildsRect.Scrolled">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.GetClientOrigin" link="#LCL.Controls.TControl.GetClientOrigin"/>
      <element name="TWinControl.GetClientOrigin.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.GetClientRect" link="#LCL.Controls.TControl.GetClientRect"/>
      <element name="TWinControl.GetClientRect.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.GetControlOrigin" link="#LCL.Controls.TControl.GetControlOrigin">
        <short>The screen coordinates of the control.</short>
        <descr>
          <p>Returns the screen coordinates of the topleft pixel of the control on the screen.</p>
          <remark>Note that this value is the position as stored in the interface and is not always in sync with the LCL.
            When a control is moved, the LCL sets the bounds to the wanted position and sends a move message to the interface.
            It is up to the interface to handle moves instantly or queued.
          </remark>
        </descr>
      </element>
      <element name="TWinControl.GetControlOrigin.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.GetDeviceContext" link="#LCL.Controls.TControl.GetDeviceContext"/>
      <element name="TWinControl.GetDeviceContext.Result">
        <short/>
      </element>
      <element name="TWinControl.GetDeviceContext.WindowHandle">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.IsControlMouseMsg">
        <short>
          <var>IsControlMouseMsg</var> - returns True if the specified message is a control mouse message</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.IsControlMouseMsg.Result">
        <short/>
      </element>
      <element name="TWinControl.IsControlMouseMsg.TheMessage">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.ParentHandlesAllocated" link="#LCL.Controls.TControl.ParentHandlesAllocated"/>
      <element name="TWinControl.ParentHandlesAllocated.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CreateHandle">
        <short>
          <var>CreateHandle</var> - generates an operating system handle</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CreateParams">
        <short>
          <var>CreateParams</var> - create parameters for this windowed class</short>
        <descr>
          <p>Definition of parameters:</p>
          <pre>TCreateParams = record
    Caption: PChar;
    Style: Cardinal;
    ExStyle: Cardinal;
    X, Y: Integer;
    Width, Height: Integer;
    WndParent: HWnd;
    Param: Pointer;
    WindowClass: TWndClass;
    WinClassName: array[0..63] of Char; 
End;
</pre>
        </descr>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.CreateParams.Params">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CreateWnd">
        <short>
          <var>CreateWnd</var> - Creates the Window</short>
        <descr>
          <p>
            <printshort id="TWinControl.CreateWnd"/>
          </p>
          <p>Creates the interface object, sets parameters and assigns the handle</p>
        </descr>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.DestroyHandle">
        <short>
          <var>DestroyHandle</var> - removes the handle for this window</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.DestroyWnd">
        <short>
          <var>DestroyWnd</var> - destroy the window for this control</short>
        <descr>
          <p>
            <printshort id="TWinControl.DestroyWnd"/>
          </p>
          <p>Removes handles and restores color and font flags</p>
        </descr>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.DoFlipChildren">
        <short>
          <var>DoFlipChildren</var> - reverses the order of the children</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.FixupTabList">
        <short>
          <var>FixupTabList</var> - renders the Tab list into a suitable state</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.FontChanged" link="#LCL.Controls.TControl.FontChanged"/>
      <element name="TWinControl.FontChanged.Sender">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.InitializeWnd">
        <short>
          <var>InitializeWnd</var> - initialise the window for this control</short>
        <descr>
          <p>
            <var>InitializeWnd</var> - initialise the window for this control</p>
          <p>Gets called after the Handle is created and before the child handles are created</p>
          <p>Works out the correct bounds, sets style, fonts and colours, performs any pending resize operations</p>
        </descr>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.Loaded">
        <short>Called when the control has been loaded from a resource.
        </short>
        <descr>
          <var>Loaded</var> makes a number of checks, using client size if specified, and copying appropriate flags, fonts, text etc, makes list of child controls to notify them of any changes, then calls inherited 
          <var>Loaded</var>
        </descr>
        <errors/>
        <seealso>
          <link id="#LCL.Controls.TControl.Loaded">TControl.Loaded</link>
        </seealso>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.MainWndProc">
        <short>
          <var>MainWndProc</var> - issus a LCL message that this is the main window procedure</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.MainWndProc.Msg">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.ParentFormHandleInitialized">
        <short>Called after all children handles of the ParentForm are created. Tells all wincontrols about the final end of the handle creation phase</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#LCL.Controls.TControl.ParentFormHandleInitialized">TControl.ParentFormHandleInitialized</link>
        </seealso>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.ChildHandlesCreated">
        <short>
          <var>ChildHandlesCreated</var> - called after a child's handles are created</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.ReAlign">
        <short>
          <var>ReAlign</var> - realign all children</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.RealSetText" link="#LCL.Controls.TControl.RealSetText"/>
      <element name="TWinControl.RealSetText.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.RemoveFocus">
        <short>
          <var>RemoveFocus</var> from this WinContro</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.RemoveFocus.Removing">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.SendMoveSizeMessages" link="#LCL.Controls.TControl.SendMoveSizeMessages"/>
      <element name="TWinControl.SendMoveSizeMessages.SizeChanged">
        <short/>
      </element>
      <element name="TWinControl.SendMoveSizeMessages.PosChanged">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.SetBorderStyle">
        <short>
          <var>SetBorderStyle</var> - specify the style for the border</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.SetBorderStyle.NewStyle">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.SetColor" link="#LCL.Controls.TControl.SetColor"/>
      <element name="TWinControl.SetColor.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.SetZOrder">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.SetZOrder.Topmost">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.SetZOrderPosition">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.SetZOrderPosition.NewPosition">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.ShowControl">
        <short>
          <var>ShowControl</var> - method for showing the specified control</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.ShowControl.AControl">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.Update" link="#LCL.Controls.TControl.Update"/>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.UpdateControlState">
        <short>
          <var>UpdateControlState</var> - update the state of the control</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.UpdateShowing">
        <short>
          <var>UpdateShowing</var> - update the value of the 
          <var>Showing</var> property</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WndProc">
        <short>
          <var>WndProc</var> - makes specific reactions according to the message passed, then calls inherited 
          <var>WndProc</var>
        </short>
        <descr>
          <p>LM_SETFOCUS: gets parent form and show this control as focused</p>
          <p>LM_KILLFOCUS: removes focus fromthis control</p>
          <p>LM_NCHITTEST: check transparency etc</p>
          <p>Mouse and Button messages: process any docking instructions</p>
        </descr>
        <errors/>
        <seealso>
          <link id="#LCL.Controls.TControl.WndProc">TControl.WndProc</link>
        </seealso>
      </element>
      <element name="TWinControl.WndProc.Message">
        <short/>
      </element>
      <!-- property Visibility: protected -->
      <element name="TWinControl.BorderStyle">
        <short>
          <var>BorderStyle</var>
 - none, or single</short>
      </element>
      <element name="TWinControl.OnAlignInsertBefore">
        <short>
          <var>OnAlignInsertBefore</var> - event handler for an aligned insertion before action</short>
      </element>
      <element name="TWinControl.OnAlignPosition">
        <short>
          <var>OnAlignPosition</var> - event handler for supplying align position</short>
      </element>
      <!-- property Visibility: protected -->
      <element name="TWinControl.OnGetSiteInfo">
        <short>
          <var>OnGetSiteInfo</var> - event handler for finding out information about the (docking) site</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.BorderWidth">
        <short>Property to determine width of the window's border</short>
        <descr>Default is zero.</descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.BoundsLockCount">
        <short>Finds how many of the Bounds are locked</short>
        <descr>// properties which are supported by all descendants</descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.Brush">
        <short>Find which type of brush to use for drawing the control</short>
        <seealso>
          <link id="#lcl.graphics.TBrush"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.CachedClientHeight">
        <short>Stored value of client height (read-only).</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.CachedClientWidth">
        <short>Stored value of Client Width (read-only).</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.ChildSizing">
        <short>Definitions how any child control is to be sized (read/write).</short>
        <seealso>
          <link id="#lcl.Controls.TControlChildSizing"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.ControlCount">
        <short>The number of controls associated with this window (read-only).</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.Controls">
        <short>The indexed list of child controls in this window (read-only).</short>
      </element>
      <element name="TWinControl.Controls.Index">
        <short>Numerical value to identify the control within the window</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.DefWndProc">
        <short>The default procedure to be associated with the window</short>
        <descr>[? properties which are supported by all descendants<br/>reads or writes a flag to define what is the default procedure]</descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.DockClientCount">
        <short>The number of clients docked into this control.</short>
        <descr>
          <p>The docked controls can be accessed in<link id="TWinControl.DockClients">DockClients[]</link>.</p>
          <p>
            <var>DockClientCount</var> is equivalent to DockClients.Count, but handles also the special case when DockClients is Nil.</p>
        </descr>
        <seealso>
          <link id="TWinControl.DockClients"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.DockClients">
        <short>The indexed list of controls docked into this control</short>
      </element>
      <element name="TWinControl.DockClients.Index">
        <short>Index of the docked client.</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.DockManager">
        <short>The docking layout manager for this control.</short>
        <descr>
          <p>A docksite can be managed (using an DockManager) or unmanaged (positioning docked controls in the event handlers).
            The DockManager determines the placement of docked controls, by setting DropOnControl and DropAlign before the drop, and by resizing and positioning the control when it's dropped.</p>
          <p>A DockManager is used only when UseDockManager also is True.
            Setting UseDockManager to True creates an DockManager of the DefaultDockManagerClass for this docksite, if none was previously installed.</p>
          <p>An unmanaged docksite, without an DockManager, can handle the placement of dropped controls in the OnDockOver and OnDockDrop event handlers.</p>
        </descr>
        <seealso>
          <link id="TWinControl.UseDockManager"/>
          <link id="TWinControl.DockSite"/>
          <link id="TWinControl.OnDockDrop"/>
          <link id="TWinControl.OnDockOver"/>
          <link id="TDockManager"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.DockSite">
        <short>Is this a dock site? (read/write, default is False)</short>
        <descr>Enable this to use the DockManager automatically. For example to call DockManager.ResetBounds when the control resizes.</descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.DoubleBuffered">
        <short>Is painting of this window double buffered? (read/write)</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.Handle">
        <short>Widget handle for identifying and manipulating this window (read/write).</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.IsResizing">
        <short>Is the window being re-sized?</short>
        <descr>Reads or writes flag to indicate re-sizing</descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.TabOrder">
        <short>The place this control occupies in the list of tabs</short>
        <descr>Reads or writes information in flag; default is -1</descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.TabStop">
        <short>Is the control in the sequence of controls accessed by successive presses of the Tab key?</short>
        <descr>
          <p>Use the TabStop to allow or disallow access to the control using the Tab key.
</p>
          <p>If the TabStop is True, the control is in the tab order. If TabStop is False, the control is not in the tab order and the user can't press the Tab key to move to the control.</p>
        </descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.OnDockDrop">
        <short>Event handler for the drop of a control to be docked.</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.OnDockOver">
        <short>Event handler for moves of a control over this docksite.</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.OnEnter">
        <short>
          <var>OnEnter</var>
 - event handler for when the mouse enters the control, and the control receives focus</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.OnExit">
        <short>
          <var>OnExit</var>
 - event handler for when the mouse leaves the control and it loses focus</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.OnKeyDown">
        <short>
          <var>OnKeyDown</var>
 - event handler for instance when key is down while control has focus</short>
        <descr>
          <p>
            <var>OnKeyDown</var>
 - event handler for instance when key is down while control has focus</p>
          <p>Differs from <link id="#lcl.Controls.TWinControl.OnKeyPress">OnKeyPress</link> in that the key may have already been down when the control received focus; with <var>OnKeyPress</var> the key needs to become pressed while the control has focus.</p>
        </descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.OnKeyPress">
        <short>OnKeyPress - event controller for a key being pressed while the control has focus. To properly handle national chars use UTF8KeyPress instead.</short>
        <descr>
          <p>
            <var>OnKeyPress</var>
 - event controller for a key being pressed while the control has focus</p>
          <p>Differs from <link id="#lcl.Controls.TWinControl.OnKeyDown">OnKeyDown</link> in that the key needs to become pressed while the control has focus; with <var>OnKeyDown</var>  the key may have already been down when the control received focus.</p>
          <p>Note: we recommend you to use OnUTF8KeyPress to prevent data lost. National chars are converted from UTF8 to the system encoding in OnKeyPressEvent. This can cause a data lost if symbol cannot be converted, which means OnKeyPress is not called or with Char=#0. OnUTF8KeyPress does not perform this conversion.</p>
        </descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.OnKeyUp">
        <short>
          <var>OnKeyUp</var>
  - event handler for instance when a key is up (not pressed) while the control has focus</short>
        <descr>
          <p>
            <var>OnKeyUp</var>
  - event handler for instance when a key is up (not pressed) while the control has focus</p>
          <p>The key may already have been up when the control received focus, or a pressed key may become released during the time the control has focus.</p>
        </descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.OnMouseWheel">
        <short>Event handler for any movement of the mouse wheel</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.OnMouseWheelDown">
        <short>Event handler for downward movement of the mouse wheel</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.OnMouseWheelUp">
        <short>Event handler for upward movement of the mouse wheel</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.OnUnDock">
        <short>Event handler for control becoming disconnected (undocked) from parent.</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.OnUTF8KeyPress">
        <short>UTF8KeyPress - event controller for a key being pressed while the control has focus.</short>
        <descr>
          <p>
            <var>OnUTF8KeyPress</var> - event controller for a key being pressed while the control has focus</p>
          <p>Differs from <link id="#lcl.Controls.TWinControl.OnKeyPress">OnKeyDown</link> in that the char does not converts to the system encoding</p>
        </descr>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.ParentCtl3D">
        <short>
          <var>ParentCtl3D</var> - does it inherit Ctl3D properties from parents? (Deprecated)</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.ParentWindow">
        <short></short>
        <descr>
        </descr>
        <seealso>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.Showing">
        <short>Is the window showing? (similar to Visible in other contexts)</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.UseDockManager">
        <short>Create DockManager for docking (read/write)</short>
        <descr>The DockManager is created via a call to CreateDockManager.</descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.VisibleDockClientCount">
        <short>The number of visible docked controls.</short>
      </element>
      <!-- property Visibility: protected -->
      <element name="TWinControl.WindowHandle">
        <short></short>
        <descr>
        </descr>
        <seealso>
        </seealso>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.AdjustSize">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: public -->
      <element name="TWinControl.AutoSizeDelayed" link="#LCL.Controls.TControl.AutoSizeDelayed"/>
      <element name="TWinControl.AutoSizeDelayed.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TWinControl.AutoSizePhases">
        <short></short>
        <descr>
        </descr>
        <errors>
        </errors>
        <seealso>
        </seealso>
      </element>
      <element name="TWinControl.AutoSizePhases.Result">
        <short></short>
      </element>
      <!-- function Visibility: public -->
      <element name="TWinControl.AutoSizeCheckParent">
        <short></short>
        <descr>
        </descr>
        <errors>
        </errors>
        <seealso>
        </seealso>
      </element>
      <element name="TWinControl.AutoSizeCheckParent.Result">
        <short></short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.BeginUpdateBounds">
        <short>
          <var>BeginUpdateBounds</var> - start updating the bounds of the current WinControl</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.EndUpdateBounds">
        <short>
          <var>EndUpdateBounds</var> - finishes updating the bounds setting</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.LockRealizeBounds">
        <short>
          <var>LockRealizeBounds</var> - make the realized bounds unaccessible</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.UnlockRealizeBounds">
        <short>
          <var>UnlockRealizeBounds</var> - unlock the previously locked realized bounds</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: public -->
      <element name="TWinControl.ControlAtPos">
        <short>Get the child control at the given client position.</short>
        <descr>
          <p>[this applies to what?]</p>
          <ul>
            <li>capfHasScrollOffset: Take into account scroll offset of scrollable wincontrol. [when not???]</li>
            <li>capfWinControls: skip wincontrols if False (when???)</li>
            <li>capfRecursive: search nested children</li>
          </ul>
          <p>WinControls are found before Controls (if overlapping).</p>
        </descr>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.ControlAtPos.Result">
        <short/>
      </element>
      <element name="TWinControl.ControlAtPos.Pos"/>
      <element name="TWinControl.ControlAtPos.AllowDisabled">
        <short/>
      </element>
      <element name="TWinControl.ControlAtPos.AllowWinControls">
        <short/>
      </element>
      <element name="TWinControl.ControlAtPos.Flags">
        <short/>
      </element>
      <element name="TWinControl.ControlAtPos.OnlyClientAreas">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.DoAdjustClientRectChange">
        <short>
          <var>DoAdjustClientRectChange</var> - perform any adjustments needed when the client rectangle changes</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.DoAdjustClientRectChange.InvalidateRect">
        <short></short>
      </element>
      <element name="TWinControl.InvalidatePreferredChildSizes">
        <short>
          <var>InvalidatePreferredChildSizes</var> - renders the preferred child sizes invalid</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.InvalidateClientRectCache">
        <short>
          <var>InvalidateClientRectCache</var> - render invalid any information in the client rectangle cache</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.InvalidateClientRectCache.WithChildControls">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TWinControl.ClientRectNeedsInterfaceUpdate">
        <short>
          <var>ClientRectNeedsInterfaceUpdate</var> - True if update needed
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.ClientRectNeedsInterfaceUpdate.Result">
        <short>True if update needed.</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.SetBounds" link="#LCL.Controls.TControl.SetBounds">
        <short>Sets the control bounds and adjusts child and docked controls.</short>
      </element>
      <element name="TWinControl.SetBounds.aLeft">
        <short/>
      </element>
      <element name="TWinControl.SetBounds.aTop">
        <short/>
      </element>
      <element name="TWinControl.SetBounds.aWidth">
        <short/>
      </element>
      <element name="TWinControl.SetBounds.aHeight">
        <short/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TWinControl.Create"/>
      <element name="TWinControl.Create.TheOwner">
        <short/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TWinControl.CreateParented">
        <short>
          <var>CreateParented</var> - constructor for a window that is the child of a specified parent</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.CreateParented.AParentWindow">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TWinControl.CreateParentedControl">
        <short>
          <var>CreateParentedControl</var> - returns a newly created window control that has a specified window as its parent</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.CreateParentedControl.Result">
        <short/>
      </element>
      <element name="TWinControl.CreateParentedControl.AParentWindow">
        <short/>
      </element>
      <!-- destructor Visibility: public -->
      <element name="TWinControl.Destroy">
        <short/>
        <descr>
          <p>Destroys any allocated handles, removes any docking links, and frees the resources used by the control.</p>
        </descr>
        <seealso>
          <link id="#LCL.Controls.TControl.Destroy">TControl.Destroy</link>
        </seealso>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.DockDrop">
        <short>A dragged control has been dropped onto this docksite</short>
        <descr>
          <p>Asks the dropped control to dock itself into the target control, updating its Parent, HostDockSite and the DockClients of the old and new DockSite.</p>
          <p>When a DockManager is installed, asks the DockManager to position the docked control (InsertControl).</p>
          <p>Finally creates an OnDockDrop event.</p>
        </descr>
        <seealso>
          <link id="TWinControl.DoDockClientMsg"/>
          <link id="TWinControl.OnDockDrop"/>
          <link id="TDragDockObject"/>
        </seealso>
      </element>
      <element name="TWinControl.DockDrop.DragDockObject">
        <short/>
      </element>
      <element name="TWinControl.DockDrop.X">
        <short/>
      </element>
      <element name="TWinControl.DockDrop.Y">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TWinControl.CanFocus">
        <short>
          <var>CanFocus</var> -  is the current window allowed to receive focus?</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.CanFocus.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TWinControl.GetControlIndex">
        <short>
          <var>GetControlIndex</var> - find the index value for the given control</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.GetControlIndex.Result">
        <short/>
      </element>
      <element name="TWinControl.GetControlIndex.AControl">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.SetControlIndex">
        <short>
          <var>SetControlIndex</var> - set a new index value for the given control</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.SetControlIndex.AControl">
        <short/>
      </element>
      <element name="TWinControl.SetControlIndex.NewIndex">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TWinControl.Focused">
        <short>
          <var>Focused</var> - is the current window receiving focus?</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.Focused.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TWinControl.PerformTab">
        <short>
          <var>PerformTab</var> - perform a tab - is it in the forward direction?</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.PerformTab.Result">
        <short/>
      </element>
      <element name="TWinControl.PerformTab.ForwardTab">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TWinControl.ControlByName">
        <short>
          <var>ControlByName</var> - returns the identity of a control whose name is given as an argument</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.ControlByName.Result">
        <short/>
      </element>
      <element name="TWinControl.ControlByName.ControlName">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.SelectNext">
        <short>
          <var>SelectNext</var> - move to the next windowed control and give it focus</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.SelectNext.CurControl">
        <short/>
      </element>
      <element name="TWinControl.SelectNext.GoForward">
        <short/>
      </element>
      <element name="TWinControl.SelectNext.CheckTabStop">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.BroadCast">
        <short>
          <var>BroadCast</var> - send 
          <var>ToAllMessage</var> to all recipients</short>
      </element>
      <element name="TWinControl.BroadCast.ToAllMessage">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.NotifyControls">
        <short>
          <var>NotifyControls</var> - send 
          <var>Msg </var>(a message) to all controls</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.NotifyControls.Msg">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.DefaultHandler">
        <short>
          <var>DefaultHandler</var> handles all messages that the control doesn't fully handle itself.
        </short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#rtl.System.TObject.DefaultHandler">TObject.DefaultHandler</link>
        </seealso>
      </element>
      <element name="TWinControl.DefaultHandler.AMessage">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.DisableAlign">
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.EnableAlign">
        <short>
          <var>EnableAlign</var> - turn on the alignment process</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: public -->
      <element name="TWinControl.GetTextLen" link="#LCL.Controls.TControl.GetTextLen"/>
      <element name="TWinControl.GetTextLen.Result">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.Invalidate">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.InsertControl">
        <short>
          <var>InsertControl</var> - insert the specified control into the list, optionally with the specified index</short>
      </element>
      <element name="TWinControl.InsertControl.AControl">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.InsertControl">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.InsertControl.AControl">
        <short/>
      </element>
      <element name="TWinControl.InsertControl.Index">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.RemoveControl">
        <short>
          <var>RemoveControl</var> - remove the specified control from the list</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.RemoveControl.AControl">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.Insert">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.Insert.AControl">
        <short/>
      </element>
      <element name="TWinControl.Insert.Index">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.Remove">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.Remove.AControl">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.Repaint" link="#LCL.Controls.TControl.Repaint"/>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.SetFocus">
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: public -->
      <element name="TWinControl.FindChildControl">
        <short>
          <var>FindChildControl</var> - find what controls are descended from the current one</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.FindChildControl.Result">
        <short/>
      </element>
      <element name="TWinControl.FindChildControl.ControlName">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.FlipChildren">
        <short>
          <var>FlipChildren</var> - reverse the order of the child components</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.FlipChildren.AllLevels">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.GetTabOrderList">
        <short>
          <var>GetTabOrderList</var> - find the list with the Tab Order</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.GetTabOrderList.List">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TWinControl.HandleAllocated">
        <short>
          <var>HandleAllocated</var> - find if the operating system has allocated a handle to this control</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.HandleAllocated.Result">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.HandleNeeded">
        <short>
          <var>HandleNeeded</var> - tell the Operating System that this control requires a handle</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: public -->
      <element name="TWinControl.BrushCreated">
        <short>
          <var>BrushCreated</var> - has a brush been created for this control?</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.BrushCreated.Result">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.EraseBackground">
        <short>
          <var>EraseBackground</var> - remove all material from the background</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.EraseBackground.DC">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TWinControl.IntfUTF8KeyPress">
        <short>
          <var>IntfUTF8KeyPress</var> - returns the UTF8 value of the pressed key from the interface</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.IntfUTF8KeyPress.Result">
        <short/>
      </element>
      <element name="TWinControl.IntfUTF8KeyPress.UTF8Key">
        <short/>
      </element>
      <element name="TWinControl.IntfUTF8KeyPress.RepeatCount">
        <short/>
      </element>
      <element name="TWinControl.IntfUTF8KeyPress.SystemKey">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.DoFloatMsg" link="#LCL.Controls.TControl.DoFloatMsg">
        <short>Handler called when the control starts floating.</short>
        <descr>TWinControls can float for themselves, unless they request a special FloatingDockSiteClass.
[Bug: when no FloatingDockSiteClass was assigned, a default floating site is created?]
</descr>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.DoFloatMsg.ADockSource">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.DoGetDockCaption">
        <short>Calls an OnGetDockCaption handler, to adjust the dock-caption for the docked control.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.DoGetDockCaption.AControl">
        <short/>
      </element>
      <element name="TWinControl.DoGetDockCaption.ACaption">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.SendDialogChar">
        <short>
          <var>SendDialogChar</var> - LCL key message: returns True if a dialog character has been sent</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.SendDialogChar.Result">
        <short/>
      </element>
      <element name="TWinControl.SendDialogChar.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.SelectFirst">
        <short>
          <var>SelectFirst</var> - select the first control on the list</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.FinalizeWnd">
        <short>
          <var>FinalizeWnd</var> -  getting ready to remove window (gets called before the Handle is destroyed)</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.FormEndUpdated">
        <short>
          <var>FormEndUpdated</var> - calls inherited
          <var>FormEndUpdated</var> then informs each child control</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#LCL.Controls.TControl.FormEndUpdated">TControl.FormEndUpdated</link>
        </seealso>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.SetChildZPosition">
        <short>
          <var>SetChildZPosition</var> - specify the position of the child control in the Z plane (ie front-to-back)</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.SetChildZPosition.AChild">
        <short/>
      </element>
      <element name="TWinControl.SetChildZPosition.APosition">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WSSetText">
        <short>
          <var>WSSetText</var> - writes the name of the current widget set to a local variable</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.WSSetText.AText">
        <short/>
      </element>
      <!-- property Visibility: protected -->
      <element name="TWinControl.OnGetDockCaption">
        <short>
          <var>OnGetDockCaption</var> - event handler to find the caption for the docked control</short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.WriteLayoutDebugReport" link="#LCL.Controls.TControl.WriteLayoutDebugReport"/>
      <element name="TWinControl.WriteLayoutDebugReport.Prefix">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.SetTempCursor" link="#LCL.Controls.TControl.SetTempCursor"/>
      <element name="TWinControl.SetTempCursor.Value">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.AddControl">
        <short>
          <var>AddControl</var> - add this control to the list of controls</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: public -->
      <element name="TWinControl.GetDockCaption">
        <short>Returns the caption for the docked control.</short>
      </element>
      <element name="TWinControl.GetDockCaption.Result">
        <short/>
      </element>
      <element name="TWinControl.GetDockCaption.AControl">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.PaintTo">
        <short>
          <var>PaintTo</var> - Paint to a specified position on the canvas</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.PaintTo.DC">
        <short/>
      </element>
      <element name="TWinControl.PaintTo.X">
        <short/>
      </element>
      <element name="TWinControl.PaintTo.Y">
        <short/>
      </element>
      <element name="TWinControl.PaintTo.ACanvas">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.SetShape">
        <short>
          <var>SetShape</var> - make the specified shape appear on the Window</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.SetShape.AShape">
        <short/>
      </element>
      <!-- object Visibility: default -->
      <element name="TGraphicControl">
        <short>
          <var>TGraphicControl</var> is the base class for all lightweight controls.</short>
        <descr>
          <p>
            <var>TGraphicControl</var> supports simple lightweight controls that do not need the ability to accept keyboard input or contain other controls. </p>
          <p>Since lightweight controls do not wrap GUI screen objects, they are faster and use fewer resources than controls based on <var>TWinControl</var>.</p>
          <p>
            <var>TGraphicControl</var> provides a
            
            <var>Canvas</var> property for access to the control's drawing surface and a virtual
            
            <var>Paint</var> method called in response to paint requests received by the parent control.</p>
        </descr>
        <seealso>
          <link id="#lcl.Controls.TWinControl"/>
          <link id="#lcl.Graphics.TCanvas"/>
        </seealso>
      </element>
      <!-- variable Visibility: private -->
      <element name="TGraphicControl.FCanvas" link="TGraphicControl.Canvas"/>
      <element name="TGraphicControl.FOnPaint" link="TGraphicControl.OnPaint"/>
      <element name="TGraphicControl.WSRegisterClass" link="#LCL.LCLClasses.TLCLComponent.WSRegisterClass"/>
      <!-- procedure Visibility: private -->
      <element name="TGraphicControl.WMPaint">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TGraphicControl.WMPaint.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TGraphicControl.Paint">
        <short>Virtual <var>Paint</var> method called in response to paint requests.</short>
        <descr>Virtual <var>Paint</var> method called in response to paint requests received by the parent control.</descr>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TGraphicControl.Create"/>
      <element name="TGraphicControl.Create.AOwner">
        <short/>
      </element>
      <!-- destructor Visibility: public -->
      <element name="TGraphicControl.Destroy"/>
      <!-- property Visibility: public -->
      <element name="TGraphicControl.Canvas">
        <short>A clipping window to the parent canvas.</short>
        <descr>
          <p>
            <var>The TGraphicsControl.Canvas</var> is a clipped window in the parent canvas.</p>
          <p>If you ask for the <var>Canvas.Width</var> or <var>Canvas.Height</var>, you are actually getting the parent control's Canvas dimensions.</p>
          <p>To get the dimensions of the <var>TGraphicControl,</var> you must query the <var>ClientRect</var>.</p>
        </descr>
        <seealso>
          <link id="#lcl.Graphics.TCanvas">TCanvas</link>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TGraphicControl.OnPaint">
        <short>
          <var>OnPaint</var> - event handler for request to paint canvas</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TGraphicControl.FontChanged" link="#LCL.Controls.TControl.FontChanged"/>
      <element name="TGraphicControl.FontChanged.Sender">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TGraphicControl.DoOnChangeBounds" link="#LCL.Controls.TControl.DoOnChangeBounds"/>
      <!-- procedure Visibility: protected -->
      <element name="TGraphicControl.DoOnParentHandleDestruction"/>
      <!-- procedure Visibility: public -->
      <element name="TGraphicControl.Update"/>
      <!-- object Visibility: default -->
      <element name="TCustomControl">
        <short>
          <var>TCustomControl </var>- a base class for many window controls</short>
        <descr>
          <p>Contains simple basic definitions to create, destroy and paint window controls and set basic properties like canvas and border</p>
        </descr>
        <seealso>
          <link id="#lcl.Controls.TWinControl">TWinControl</link>
          <link id="#lcl.Controls.TControl">TControl</link>
        </seealso>
      </element>
      <!-- variable Visibility: private -->
      <element name="TCustomControl.FCanvas" link="TCustomControl.Canvas"/>
      <!-- variable Visibility: private -->
      <element name="TCustomControl.FOnPaint" link="TCustomControl.OnPaint"/>
      <!-- procedure Visibility: protected -->
      <element name="TCustomControl.FontChanged" link="#LCL.Controls.TControl.FontChanged"/>
      <element name="TCustomControl.FontChanged.Sender">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCustomControl.SetColor" link="#LCL.Controls.TControl.SetColor"/>
      <element name="TCustomControl.SetColor.Value">
        <short/>
      </element>
      <element name="TCustomControl.WSRegisterClass" link="#LCL.LCLClasses.TLCLComponent.WSRegisterClass"/>
      <!-- procedure Visibility: protected -->
      <element name="TCustomControl.WMPaint">
        <short>
          <var>WMPaint</var> - LCL message for painting</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TCustomControl.WMPaint.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCustomControl.PaintWindow" link="#LCL.Controls.TWinControl.PaintWindow">
        <short>Paint handler plug-in</short>
        <descr>This is a plug-in in TWinControl to get the DC, <br/>
assign it to our canvas and call the paint method for <br/>
descendants to do the actual painting
</descr>
        <seealso>
          <link id="#lcl.Controls.TWinControl.PaintWindow">TWinControl.PaintWindow</link>
        </seealso>
      </element>
      <element name="TCustomControl.PaintWindow.DC">
        <short>The Device Context in which to paint</short>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TCustomControl.Create"/>
      <element name="TCustomControl.Create.AOwner">
        <short>Owner, ie the component that called this control</short>
      </element>
      <!-- destructor Visibility: public -->
      <element name="TCustomControl.Destroy"/>
      <!-- procedure Visibility: public -->
      <element name="TCustomControl.DestroyWnd" link="#LCL.Controls.TWinControl.DestroyWnd"/>
      <!-- procedure Visibility: public -->
      <element name="TCustomControl.DestroyComponent">
        <short>If the custom control has been destroyed, free its handle as well</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCustomControl.Paint">
        <short>The virtual paint handler for the class.</short>
        <descr>Override this method in your derived class with your own paint handler.</descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomControl.Canvas">
        <short>The area of a control on which its components are drawn or painted</short>
        <descr>The Canvas is the area of screen on which the various components are drawn. <br/>
This inherits its properties from TCanvas, <br/>
and that description should be read to understand their definitions more fully.
</descr>
        <seealso>
          <link id="#lcl.Graphics.TCanvas">TCanvas</link>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomControl.BorderStyle" link="#LCL.Controls.TWinControl.BorderStyle">
        <descr>Only a restricted series of options is available: none or a single border.
        </descr>
        <seealso>
          <link id="#lcl.Controls.TBorderStyle"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomControl.OnPaint">
        <short>Event handler for painting</short>
      </element>
      <!-- object Visibility: default -->
      <element name="TImageList">
        <short>A list of images, as used for dragging.</short>
      </element>
      <!-- property Visibility: published -->
      <element name="TImageList.AllocBy">
        <short>
          <var>AllocBy</var> - for allocation</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TImageList.BlendColor">
        <short>
          <var>BlendColor</var> - the color for blending</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TImageList.DrawingStyle" link="#LCL.ImgList.TCustomImageList.DrawingStyle"/>
      <!-- property Visibility: published -->
      <element name="TImageList.ImageType" link="#LCL.ImgList.TCustomImageList.ImageType"/>
      <!-- property Visibility: published -->
      <element name="TImageList.ShareImages" link="#LCL.ImgList.TCustomImageList.ShareImages"/>
      <!-- property Visibility: published -->
      <element name="TImageList.BkColor" link="#LCL.ImgList.TCustomImageList.BkColor"/>
      <!-- property Visibility: published -->
      <element name="TImageList.Height" link="#LCL.ImgList.TCustomImageList.Height"/>
      <!-- property Visibility: published -->
      <element name="TImageList.Masked" link="#LCL.ImgList.TCustomImageList.Masked"/>
      <!-- property Visibility: published -->
      <element name="TImageList.Width" link="#LCL.ImgList.TCustomImageList.Width"/>
      <!-- property Visibility: published -->
      <element name="TImageList.OnChange" link="#LCL.ImgList.TCustomImageList.OnChange"/>
      <!-- object Visibility: default -->
      <element name="TControlPropertyStorage">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControlPropertyStorage.GetPropertyList">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControlPropertyStorage.GetPropertyList.List">
        <short/>
      </element>
      <!-- object Visibility: default -->
      <element name="TDockZone">
        <short>Represents an node in an <link id="TDockTree"/>.</short>
        <descr>
          <p>It encapsulates a dock zone, containing either other zones or a single control.
          </p>
          <p>This implementation is specific to <link id="TDockTree"/>/LDockTree. Every DockManager can (should!) use its own class instead.
          </p>
          </descr>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDockZone.FBounds" link="TDockZone.Bounds"/>
      <element name="TDockZone.FChildControl" link="TDockZone.ChildControl"/>
      <element name="TDockZone.FChildCount" link="TDockZone.ChildCount"/>
      <element name="TDockZone.FFirstChildZone" link="TDockZone.FirstChild"/>
      <element name="TDockZone.FTree" link="TDockZone.Tree"/>
      <element name="TDockZone.FParentZone" link="TDockZone.Parent"/>
      <element name="TDockZone.FOrientation" link="TDockZone.Orientation"/>
      <element name="TDockZone.FNextSibling" link="TDockZone.NextSibling"/>
      <element name="TDockZone.FPrevSibling" link="TDockZone.PrevSibling"/>
      <!-- function Visibility: private -->
      <element name="TDockZone.GetHeight" link="TDockZone.Height"/>
      <element name="TDockZone.GetHeight.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TDockZone.GetLeft" link="TDockZone.Left"/>
      <element name="TDockZone.GetLeft.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TDockZone.GetLimitBegin" link="TDockZone.LimitBegin"/>
      <element name="TDockZone.GetLimitBegin.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TDockZone.GetLimitSize" link="TDockZone.LimitSize"/>
      <element name="TDockZone.GetLimitSize.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TDockZone.GetTop" link="TDockZone.Top"/>
      <element name="TDockZone.GetTop.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TDockZone.GetVisible" link="TDockZone.Visible"/>
      <element name="TDockZone.GetVisible.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TDockZone.GetVisibleChildCount">
        <short>
          <var>GetVisibleChildCount</var> - returns the number of visible children</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TDockZone.GetVisibleChildCount.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TDockZone.GetWidth" link="TDockZone.Width"/>
      <element name="TDockZone.GetWidth.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TDockZone.GetNextVisibleZone">
        <short>
          <var>GetNextVisibleZone</var> - returns the next visible zone</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TDockZone.GetNextVisibleZone.Result">
        <short/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TDockZone.Create"/>
      <element name="TDockZone.Create.TheTree">
        <short>The dock tree to which this zone belongs.</short>
      </element>
      <element name="TDockZone.Create.TheChildControl">
        <short>The control in this zone (may be Nil).</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TDockZone.FindZone">
        <short>
          <var>FindZone</var> - returns the Dockzone for the nominated control</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TDockZone.FindZone.Result">
        <short/>
      </element>
      <element name="TDockZone.FindZone.AControl">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TDockZone.AddAsFirstChild">
        <short>
          <var>AddAsFirstChild</var> - add a new zone as the first child</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TDockZone.AddAsFirstChild.NewChildZone">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TDockZone.AddAsLastChild">
        <short>
          <var>AddAsLastChild</var> - add an new zone as the last child</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TDockZone.AddAsLastChild.NewChildZone">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TDockZone.ReplaceChild">
        <short>
          <var>ReplaceChild</var> - replace the
          <var>OldChild</var> zone by
          <var>NewChild</var>
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TDockZone.ReplaceChild.OldChild">
        <short/>
      </element>
      <element name="TDockZone.ReplaceChild.NewChild">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TDockZone.GetLastChild">
        <short>
          <var>GetLastChild</var> - returns the last child zone.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TDockZone.GetLastChild.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TDockZone.GetIndex">
        <short>
          <var>GetIndex</var> - returns the index of the current zone</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TDockZone.GetIndex.Result">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TDockZone.Remove">
        <short>
          <var>Remove</var> the nominated child zone</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TDockZone.Remove.ChildZone">
        <short/>
      </element>
      <element name="TDockZone.AddSibling">
        <short>
          <var>AddSibling</var> - inserts a new sibling zone.</short>
        <descr>The new zone is inserted immediately before or after this zone.</descr>
      </element>
      <element name="TDockZone.AddSibling.NewZone">
        <short>The zone to add.</short>
      </element>
      <element name="TDockZone.AddSibling.InsertAt">
        <short>How to add the zone.</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TDockZone.NextSibling">
        <short>The next sibling zone.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDockZone.PrevSibling">
        <short>The preceding sibling zone.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- function Visibility: public -->
      <element name="TDockZone.FirstVisibleChild">
        <short>
          <var>FirstVisibleChild</var> - returns the first visible child zone</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TDockZone.FirstVisibleChild.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TDockZone.NextVisible">
        <short>
          <var>NextVisible</var> - returns next visible zone.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TDockZone.NextVisible.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TDockZone.PrevVisible">
        <short>
          <var>PrevVisible</var> - returns the preceding visible zone.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TDockZone.PrevVisible.Result">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDockZone.Tree">
        <short>The dock tree of which this dock zone is a part.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDockZone.ChildControl">
        <short>The child control to be docked here</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDockZone.ChildCount">
        <short>The number of child zones.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDockZone.FirstChild">
        <short>The first child zone.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDockZone.Height">
        <short>The height of the zone.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDockZone.SetHeight" link="TDockZone.Height"/>
      <element name="TDockZone.SetHeight.AValue">
        <short></short>
      </element>
      <!-- property Visibility: public -->
      <element name="TDockZone.Left">
        <short>The left coordinate of the zone.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDockZone.SetLeft" link="TDockZone.Left"/>
      <element name="TDockZone.SetLeft.AValue">
        <short></short>
      </element>
      <!-- property Visibility: public -->
      <element name="TDockZone.LimitBegin">
        <short>The free coordinate of the DockZone (Left or Top).</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDockZone.SetLimitBegin" link="TDockZone.LimitBegin"/>
      <element name="TDockZone.SetLimitBegin.AValue">
        <short></short>
      </element>
      <!-- property Visibility: public -->
      <element name="TDockZone.LimitSize">
        <short>The free size of the DockZone (Width or Height).</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDockZone.SetLimitSize" link="TDockZone.LimitSize"/>
      <element name="TDockZone.SetLimitSize.AValue">
        <short></short>
      </element>
      <!-- property Visibility: public -->
      <element name="TDockZone.Orientation" link="TDockOrientation">
        <short>Whether docking is oriented vertically, horizontally, in pages, or not at all</short>
        <descr>
          <p>doNoOrient   : zone contains a TControl and no child zones.</p>
          <p>doHorizontal : zone's children are stacked top-to-bottom.</p>
          <p>doVertical     : zone's children are arranged left-to-right.</p>
          <p>doPages       : zone's children are pages arranged left-to-right.</p>
        </descr>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDockZone.Parent">
        <short>The parent dock zone to which this control is docked</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDockZone.Top">
        <short>The top coordinate of this zone.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDockZone.SetTop" link="TDockZone.Top"/>
      <element name="TDockZone.SetTop.AValue">
        <short></short>
      </element>
      <!-- property Visibility: public -->
      <element name="TDockZone.Visible">
        <short>Is the zone visible?</short>
        <descr>A zone is visible if it contains a visible control, or if any chilc zone is visible.</descr>
        <seealso><link id="TDockZone.VisibleChildCount"/></seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TDockZone.VisibleChildCount">
        <short>
          <var>VisibleChildCount</var> - the number of visible child zones.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDockZone.Width">
        <short>The width of this zone.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDockZone.SetWidth" link="TDockZone.Width"/>
      <element name="TDockZone.SetWidth.AValue">
        <short></short>
      </element>
      <!-- "class of" type Visibility: default -->
      <element name="TDockZoneClass">
        <short>Class of <link id="TDockZone"/>.</short>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TForEachZoneProc">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TForEachZoneProc.Zone">
        <short/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TDockTreeFlag">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TDockTreeFlag.dtfUpdateAllNeeded">
        <short/>
      </element>
      <!-- set type Visibility: default -->
      <element name="TDockTreeFlags">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- object Visibility: default -->
      <element name="TDockTree">
        <short>A docking manager for tree-style layouts.</short>
        <descr>
          <p>A tree-style layout is organized in layers of a specific (horizontal or vertical) orientation. Every node in the tree is either a container for other nodes, or represents a zone with a single docked control. All child zones of an node have the same DockOrientation.</p>
          <p>The following documentation is copied from the Controls unit. It is of historical interest only, since it effectively describes the AnchorDocking, implemented in TCustomAnchoredDockManager. AnchorDocking is not related to visual drag-dock procedures, it merely is an attempt to implement just an layout manager.
          <br/>[todo: make this description an topic]
          </p>
          <remark>The TLazDockTree implementation never was finished, due to problems with the anchor "docking" mechanism.
            Use the EasyDockManager (examples/dockmanager) instead.</remark>
          <pre>This is an abstract class. A real implementation is e.g. in ldocktree.pas.

    Docking means here: Combining several windows to one. A window can here be
    a TCustomForm or a floating control (undocked) or a TDockForm.
    A window can be docked to another to the left, right, top, bottom or "into".
    The docking source window will be resized, to fit to the docking target
    window.

    Example1: Docking "A" (source window) left to "B" (target window)
    
       +---+    +----+
       | A | -&gt; | B  |
       +---+    |    |
                +----+
      Result: A new docktree will be created. Height of "A" will be resized to
              the height of "B".
              A splitter will be inserted between "A" and "B".
              And all three are children of the newly created TLazDockForm of the
              newly created TDockTree.
      
       +------------+
       |+---+|+----+|
       || A ||| B  ||
       ||   |||    ||
       |+---+|+----+|
       +------------+

      If "A" or "B" were floating controls, the floating dock sites are freed.
      If "A" or "B" were forms, their decorations (title bars and borders) are
      replaced by docked decorations.
      If "A" had a TDockTree, it is freed and its child dockzones are merged to
      the docktree of "B". Analog for docking "C" left to "A":
      
       +------------------+
       |+---+|+---+|+----+|
       || C ||| A ||| B  ||
       ||   |||   |||    ||
       |+---+|+---+|+----+|
       +------------------+
       

      
    Example2: Docking A into B
                +-----+
       +---+    |     |
       | A | ---+-&gt; B |
       +---+    |     |
                +-----+

      Result: A new docktree will be created. "A" will be resized to the size
              of "B". Both will be put into a TLazDockPages control which is the
              child of the newly created TDockTree.
              
       +-------+
       |[B][A] |
       |+-----+|
       ||     ||
       || A   ||
       ||     ||
       |+-----+|
       +-------+

    Every DockZone has siblings and children. Siblings can either be
    - horizontally (left to right, splitter),
    - vertically (top to bottom, splitter)
    - or upon each other (as notebook pages).


    InsertControl - undock control and dock it into the dock site. For example
                    dock Form1 left to a Form2:
                    InsertControl(Form1,alLeft,Form2);
                    To dock "into", into a TDockPage, use Align=alCustom.
    PositionDockRect - calculates where a control would be placed, if it would
                       be docked via InsertControl.
    RemoveControl - removes a control from the dock site.

    GetControlBounds - TODO for Delphi compatibility
    ResetBounds - TODO for Delphi compatibility
    SetReplacingControl - TODO for Delphi compatibility
    PaintSite - TODO for Delphi compatibility

</pre>
        </descr>
        <seealso>
          <link id="#lcl.Controls.TDockManager"/>
        </seealso>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDockTree.FBorderWidth">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDockTree.FDockSite" link="TDockTree.DockSite"/>
      <element name="TDockTree.FDockZoneClass" link="TDockTree.DockZoneClass"/>
      <!-- variable Visibility: private -->
      <element name="TDockTree.FFlags">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDockTree.FRootZone">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDockTree.FUpdateCount" link="TDockTree.BeginUpdate"/>
      <!-- procedure Visibility: private -->
      <element name="TDockTree.SetDockSite" link="TDockTree.DockSite"/>
      <element name="TDockTree.SetDockSite.AValue">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDockTree.RootZone">
        <short>
          <var>RootZone</var> - the zone that forms the root of the current Dock Tree</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDockTree.MouseMessage" link="#LCL.Controls.TDockManager.MouseMessage"/>
      <!-- procedure Visibility: private -->
      <element name="TDockTree.DeleteZone">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TDockTree.DeleteZone.Zone">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDockTree.AdjustDockRect">
        <short>
          <var>AdjustDockRect</var> - adjust the docking rectangle for AControl.</short>
        <descr>
          <p>ARect initially describes the dockzone into which the control is docked.
            From that area the zone decoration is excluded, so that ARect describes the area reserved for the docked control.</p>
          <p>AdjustDockRect is not part of the general docking model.
            It can implemented and used for any purpose in a dock tree manager.
            Most docking managers will replace it by a method with more arguments, that allow to identify the zone and its properties immediately.</p>
        </descr>
        <errors/>
        <seealso/>
      </element>
      <element name="TDockTree.AdjustDockRect.AControl">
        <short/>
      </element>
      <element name="TDockTree.AdjustDockRect.ARect">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDockTree.BeginUpdate" link="#LCL.Controls.TDockManager.BeginUpdate"/>
      <!-- procedure Visibility: protected -->
      <element name="TDockTree.EndUpdate" link="#LCL.Controls.TDockManager.EndUpdate"/>
      <!-- procedure Visibility: protected -->
      <element name="TDockTree.GetControlBounds" link="#LCL.Controls.TDockManager.GetControlBounds"/>
      <element name="TDockTree.GetControlBounds.AControl">
        <short/>
      </element>
      <element name="TDockTree.GetControlBounds.ControlBounds">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TDockTree.HitTest">
        <short>
          <var>HitTest</var> - performs a Hit test at the specified mouse position, and returns the Control present there </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TDockTree.HitTest.Result">
        <short/>
      </element>
      <element name="TDockTree.HitTest.MousePos">
        <short/>
      </element>
      <element name="TDockTree.HitTest.HTFlag">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDockTree.InsertControl">
        <short>
          <var>InsertControl</var> - position <var>DropCtl</var> relative <var>Control</var>, using the alignment specified by <var>InsertAt.</var>
        </short>
        <descr>
          <p>InsertControl determines the layout and appearance of the just docked control, forcing a repaint of the container control if necessary.</p>
          <p>When SetReplacingControl has been called with a non-Nil Control before, the dropped control only should replace that control.</p>
          <p>A tree docking manager organizes the docksite into layers of horizontol or vertical orientation.
            As long as no more than one control is docked into a docksite, the tree has no orientation at all.
            The second docked control determines the orientation of the docksite and the dock tree.
            All further drops are either isogonal (in direction of the zone orientation) or orthogonal (opposite to the zone orientation).
            On an isogonal drop a new leaf zone is created for the dropped control, as a sibling of the already existing child zones.
            On an orthogonal drop the zone containing the DropControl becomes the root of another subtree, whose initial members are the leaf zones for Control and DropCtl.</p>
          <p>One value of InsertAt (alCustom) is reserved for notebook docking, where DropCtl is replaced by a tabbed notebook, and Control and DropCtl are moved into pages of the notebook.
            The notebook is a docksite of its own, further drops into the notebook are handled by the notebook itself, the DockManager of the host docksite is not involved.</p>
        </descr>
        <errors/>
        <seealso>
          <link id="TDockManager.RemoveControl"/>
        </seealso>
      </element>
      <element name="TDockTree.InsertControl.AControl">
        <short/>
      </element>
      <element name="TDockTree.InsertControl.InsertAt">
        <short/>
      </element>
      <element name="TDockTree.InsertControl.DropControl">
        <short/>
      </element>
      <element name="TDockTree.DumpLayout">
        <short>
          <var>DumpLayout</var> - stores layout in a file</short>
      </element>
      <element name="TDockTree.DumpLayout.FileName">
        <short></short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDockTree.LoadFromStream" link="#LCL.Controls.TDockManager.LoadFromStream"/>
      <element name="TDockTree.LoadFromStream.SrcStream">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TDockTree.MessageHandler">
        <short></short>
        <descr>
        </descr>
        <errors>
        </errors>
        <seealso>
        </seealso>
      </element>
      <element name="TDockTree.MessageHandler.Sender">
        <short></short>
      </element>
      <element name="TDockTree.MessageHandler.Message">
        <short></short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDockTree.PaintDockFrame">
        <short></short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TDockTree.PaintDockFrame.ACanvas">
        <short/>
      </element>
      <element name="TDockTree.PaintDockFrame.AControl">
        <short/>
      </element>
      <element name="TDockTree.PaintDockFrame.ARect">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDockTree.PositionDockRect" link="#LCL.Controls.TDockManager.PositionDockRect"/>
      <element name="TDockTree.PositionDockRect.AClient">
        <short/>
      </element>
      <element name="TDockTree.PositionDockRect.DropCtl">
        <short/>
      </element>
      <element name="TDockTree.PositionDockRect.DropAlign">
        <short/>
      </element>
      <element name="TDockTree.PositionDockRect.DockRect">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDockTree.RemoveControl" link="#LCL.Controls.TDockManager.RemoveControl"/>
      <element name="TDockTree.RemoveControl.AControl">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDockTree.SaveToStream" link="#LCL.Controls.TDockManager.SaveToStream"/>
      <element name="TDockTree.SaveToStream.DestStream">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDockTree.SetReplacingControl" link="#LCL.Controls.TDockManager.SetReplacingControl"/>
      <element name="TDockTree.SetReplacingControl.AControl">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDockTree.ResetBounds" link="#LCL.Controls.TDockManager.ResetBounds"/>
      <element name="TDockTree.ResetBounds.Force">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDockTree.UpdateAll">
        <short>
          <var>UpdateAll</var> - bring all data up to date</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- property Visibility: protected -->
      <element name="TDockTree.DockSite">
        <short>
          <var>DockSite</var> - the site for docking</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TDockTree.Create"/>
      <element name="TDockTree.Create.TheDockSite">
        <short>The window control to be managed.</short>
      </element>
      <!-- destructor Visibility: public -->
      <element name="TDockTree.Destroy"/>
      <!-- procedure Visibility: public -->
      <element name="TDockTree.PaintSite" link="#LCL.Controls.TDockManager.PaintSite"/>
      <element name="TDockTree.PaintSite.DC">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDockTree.DockZoneClass">
        <short>
          The class of all dock zones in this tree.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDockTree.SetDockZoneClass" link="TDockTree.DockZoneClass"/>
      <element name="TDockTree.SetDockZoneClass.AValue">
        <short/>
      </element>
      <!-- object Visibility: default -->
      <element name="TMouse">
        <short>Some properties of the Mouse.</short>
        <descr>Contains information about current mouse position, whether messages are captured by an object, whether it is dragging an object, and how far the mouse must move before a control starts dragging.</descr>
      </element>
      <!-- variable Visibility: default -->
      <element name="TMouse.FCapture" link="TMouse.Capture"/>
      <element name="TMouse.FDragImmediate"/>
      <element name="TMouse.FDragThreshold"/>
      <element name="TMouse.FWheelScrollLines"/>
      <!-- procedure Visibility: default -->
      <element name="TMouse.SetCapture" link="TMouse.Capture"/>
      <element name="TMouse.SetCapture.Value">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="TMouse.GetCapture" link="TMouse.Capture"/>
      <element name="TMouse.GetCapture.Result">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="TMouse.GetCursorPos" link="TMouse.CursorPos"/>
      <element name="TMouse.GetCursorPos.Result">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TMouse.SetCursorPos" link="TMouse.CursorPos"/>
      <element name="TMouse.SetCursorPos.AValue">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TMouse.GetWheelScrollLines" link="TMouse.WheelScrollLines"/>
      <element name="TMouse.GetWheelScrollLines.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TMouse.GetDragImmediate" link="TMouse.DragImmediate"/>
      <element name="TMouse.GetDragImmediate.Result">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TMouse.SetDragImmediate" link="TMouse.DragImmediate"/>
      <element name="TMouse.SetDragImmediate.AValue">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TMouse.GetDragThreshold" link="TMouse.DragThreshold"/>
      <element name="TMouse.GetDragThreshold.Result">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TMouse.SetDragThreshold" link="TMouse.DragThreshold"/>
      <element name="TMouse.SetDragThreshold.AValue">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="TMouse.GetIsDragging" link="TMouse.IsDragging"/>
      <element name="TMouse.GetIsDragging.Result">
        <short/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TMouse.Create"/>
      <!-- destructor Visibility: public -->
      <element name="TMouse.Destroy"/>
      <!-- property Visibility: public -->
      <element name="TMouse.Capture">
        <short>Handle of the capturing control.</short>
        <descr/>
      </element>
      <!-- property Visibility: public -->
      <element name="TMouse.CursorPos">
        <short>The screen position of the cursor.</short>
        <descr/>
      </element>
      <!-- property Visibility: public -->
      <element name="TMouse.DragImmediate">
        <short>Does dragging start immediately (True), or only after a mouse move?</short>
        <descr/>
      </element>
      <!-- property Visibility: public -->
      <element name="TMouse.DragThreshold">
        <short>The minimum distance the mouse must move before dragging starts (in delayed mode).</short>
        <descr>Default is 5 pixels</descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TMouse.IsDragging">
        <short>Is the mouse being used to drag an object?</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TMouse.WheelScrollLines">
        <short>
          <var>WheelScrollLines</var> - the number of lines the the scroll wheel has traversed</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="AnchorAlign">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="DefaultSideForAnchorKind">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="AnchorReferenceSide">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="AlignNames">
        <short>Array of names for the <link id="TAlign"/> elements.</short>
        <descr>
          <remark>The names include the "al;" prefix, e.g. alNone.</remark>
        </descr>
      </element>
      <!-- function Visibility: default -->
      <element name="FindDragTarget">
        <short>Get control at screen position.</short>
        <descr>Disabled controls <b>should</b> be excluded, but are not due to an bug in FindControlAtPosition.</descr>
        <errors/>
        <seealso/>
      </element>
      <element name="FindDragTarget.Result">
        <short/>
      </element>
      <element name="FindDragTarget.Position">
        <short/>
      </element>
      <element name="FindDragTarget.AllowDisabled">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="FindControlAtPosition">
        <short>Get control at screen position.</short>
        <descr>When AllowDisabled is True, also a disabled control will be found. In the current implementation AllowDisabled is ignored (assumed to be True).
          First a window at the given screen position is searched, then a control within it.</descr>
        <errors/>
        <seealso/>
      </element>
      <element name="FindControlAtPosition.Result">
        <short/>
      </element>
      <element name="FindControlAtPosition.Position">
        <short/>
      </element>
      <element name="FindControlAtPosition.AllowDisabled">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="FindLCLWindow">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="FindLCLWindow.Result">
        <short/>
      </element>
      <element name="FindLCLWindow.ScreenPos">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="FindControl">
        <short>Return the TWinControl of the given Handle.</short>
        <descr>
          <p>The result is very interface specific. Use FindOwnerControl when Handle may be a non-TWinControl handle.</p>
        </descr>
        <seealso>
          <link id="FindOwnerControl"/>
        </seealso>
      </element>
      <element name="FindControl.Result">
        <short/>
      </element>
      <element name="FindControl.Handle">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="FindOwnerControl">
        <short>Returns the TWinControl for the given Handle; the parent control for a non-TWinControl Handle.</short>
        <descr>
          <p>Handle can also be a child handle (of a TControl), in which case the returned control is the parent of the desired control. Parent, not Owner as suggested by the function name![?]</p>
          <p>[Remark] The function recursively tries GetParent(Handle), so the result depends on the implementation (meaning) of a parent handle.</p>
        </descr>
      </element>
      <element name="FindOwnerControl.Result">
        <short/>
      </element>
      <element name="FindOwnerControl.Handle">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="FindLCLControl">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="FindLCLControl.Result">
        <short/>
      </element>
      <element name="FindLCLControl.ScreenPos">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="SendAppMessage">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="SendAppMessage.Result">
        <short/>
      </element>
      <element name="SendAppMessage.Msg">
        <short/>
      </element>
      <element name="SendAppMessage.WParam">
        <short/>
      </element>
      <element name="SendAppMessage.LParam">
        <short/>
      </element>
      <!-- procedure Visibility: default -->
      <element name="MoveWindowOrg">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="MoveWindowOrg.dc">
        <short/>
      </element>
      <element name="MoveWindowOrg.X">
        <short/>
      </element>
      <element name="MoveWindowOrg.Y">
        <short/>
      </element>
      <!-- procedure Visibility: default -->
      <element name="RecreateWnd">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="RecreateWnd.AWinControl">
        <short/>
      </element>
      <!-- procedure Visibility: default -->
      <element name="SetCaptureControl">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="SetCaptureControl.Control">
        <short/>
      </element>
      <element name="SetCaptureControl.AWinControl">
        <short/>
      </element>
      <element name="SetCaptureControl.Position">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="GetCaptureControl">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="GetCaptureControl.Result">
        <short/>
      </element>
      <!-- procedure Visibility: default -->
      <element name="CancelDrag">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: default -->
      <element name="DragDone">
        <short>[Delphi compatible, dropped!]</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="DragDone.Drop">
        <short/>
      </element>
      <!-- variable Visibility: default -->
      <element name="NewStyleControls">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="Mouse">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- function Visibility: default -->
      <element name="CursorToString">
        <short>Returns a string for the name of the cursor as identified by an integer constant</short>
        <descr>Calls CursorToIdent to find correct entry in look-up table</descr>
        <errors/>
        <seealso>
          <link id="#lcl.Controls.CursorToIdent"/>
        </seealso>
      </element>
      <element name="CursorToString.Result">
        <short>Returns a string with the name of the cursor type corresponding to the integer constant</short>
      </element>
      <element name="CursorToString.Cursor">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="StringToCursor">
        <short>
          <var>StringToCursor</var> - returns the cursor value corresponding to the name supplied</short>
        <descr>
          <p>
            <var>StringToCursor</var> - returns the cursor value corresponding to the name supplied</p>
          <p>Finds the numeric cursor value corresponding to the name <var>S</var> in the cursor look-up table</p>
        </descr>
      </element>
      <element name="StringToCursor.Result">
        <short>The numeric cursor value from the look-up table</short>
      </element>
      <element name="StringToCursor.S">
        <short>The name of the cursor for which the numeric value is sought</short>
      </element>
      <!-- procedure Visibility: default -->
      <element name="GetCursorValues">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="GetCursorValues.Proc">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="CursorToIdent">
        <short>Uses look-up table to find cursor identifier corresponding to integer cursor constant</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="CursorToIdent.Result">
        <short>Returns true if a valid entry is found in the look-up table</short>
      </element>
      <element name="CursorToIdent.Cursor">
        <short/>
      </element>
      <element name="CursorToIdent.Ident">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="IdentToCursor">
        <short>Searches the Cursor name table for the given cursor name; returns True if found.</short>
        <descr>If found, the cursor value (handle[?]) is returned in <var>Cursor</var>.</descr>
      </element>
      <element name="IdentToCursor.Result">
        <short>Returns True if a valid entry was found in the look-up table.</short>
      </element>
      <element name="IdentToCursor.Ident">
        <short>The name of the cursor for which the numeric value is sought.</short>
      </element>
      <element name="IdentToCursor.Cursor">
        <short>The numeric value of the named cursor.</short>
      </element>
      <!-- function Visibility: default -->
      <element name="GetKeyShiftState">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="GetKeyShiftState.Result">
        <short/>
      </element>
      <!-- procedure Visibility: default -->
      <element name="AdjustBorderSpace">
        <short>Adjust space round border of this control</short>
        <descr>
          <p>RemainingClientRect: remaining clientrect without CurBorderSpace</p>
          <p>CurBorderSpace: current borderspace around RemainingClientRect</p>
          <p>Left, Top, Right, Bottom: apply these borderspaces to CurBorderSpace</p>
          <p>CurBorderSpace will be set to the maximum of CurBorderSpace and Left, Top, Right, Bottom.</p>
          <p>RemainingClientRect will shrink.</p>
          <p>RemainingClientRect will not shrink to negative size.</p>
        </descr>
        <errors/>
        <seealso/>
      </element>
      <element name="AdjustBorderSpace.RemainingClientRect">
        <short/>
      </element>
      <element name="AdjustBorderSpace.CurBorderSpace">
        <short/>
      </element>
      <element name="AdjustBorderSpace.Left">
        <short/>
      </element>
      <element name="AdjustBorderSpace.Top">
        <short/>
      </element>
      <element name="AdjustBorderSpace.Right">
        <short/>
      </element>
      <element name="AdjustBorderSpace.Bottom">
        <short/>
      </element>
      <element name="AdjustBorderSpace.Space">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="IsColorDefault">
        <short></short>
        <descr>
        </descr>
        <errors>
        </errors>
        <seealso>
        </seealso>
      </element>
      <element name="IsColorDefault.Result">
        <short></short>
      </element>
      <element name="IsColorDefault.AControl">
        <short></short>
      </element>
      <!-- function Visibility: default -->
      <element name="BidiFlipAlignment">
        <short></short>
        <descr>
        </descr>
        <errors>
        </errors>
        <seealso>
        </seealso>
      </element>
      <element name="BidiFlipAlignment.Result">
        <short></short>
      </element>
      <element name="BidiFlipAlignment.Alignment">
        <short></short>
      </element>
      <element name="BidiFlipAlignment.Flip">
        <short></short>
      </element>
      <!-- function Visibility: default -->
      <element name="BidiFlipAnchors">
        <short></short>
        <descr>
        </descr>
        <errors>
        </errors>
        <seealso>
        </seealso>
      </element>
      <element name="BidiFlipAnchors.Result">
        <short></short>
      </element>
      <element name="BidiFlipAnchors.Control">
        <short></short>
      </element>
      <element name="BidiFlipAnchors.Flip">
        <short></short>
      </element>
      <!-- function Visibility: default -->
      <element name="BidiFlipRect">
        <short></short>
        <descr>
        </descr>
        <errors>
        </errors>
        <seealso>
        </seealso>
      </element>
      <element name="BidiFlipRect.Result">
        <short></short>
      </element>
      <element name="BidiFlipRect.Rect">
        <short></short>
      </element>
      <element name="BidiFlipRect.ParentRect">
        <short></short>
      </element>
      <element name="BidiFlipRect.Flip">
        <short></short>
      </element>
      <!-- procedure Visibility: default -->
      <element name="ChangeBiDiModeAlignment">
        <short></short>
        <descr>
        </descr>
        <errors>
        </errors>
        <seealso>
        </seealso>
      </element>
      <element name="ChangeBiDiModeAlignment.Alignment">
        <short></short>
      </element>
      <!-- procedure Visibility: default -->
      <element name="Register">
        <short>Register the components provided by this unit or package, so that they can be instantiated.</short>
        <descr>Also can be used to register the controls required by an application.[?]</descr>
        <seealso>
          <link id="#rtl.classes.registercomponents"/>
        </seealso>
      </element>
      <!-- constant Visibility: default -->
      <element name="fsSurface">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="fsBorder">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="bvNone">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="bvLowered">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="bvRaised">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="bvSpace">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMMouseWheel.XPos">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMMouseWheel.YPos">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMMouseWheel.Pos">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMMouseWheel.Result">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- set type Visibility: default -->
      <element name="TCaptureMouseButtons">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- pointer type Visibility: default -->
      <element name="PHintInfo">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- record type Visibility: default -->
      <element name="THintInfo">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="THintInfo.HintControl">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="THintInfo.HintWindowClass">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="THintInfo.HintPos">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="THintInfo.HintMaxWidth">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="THintInfo.HintColor">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="THintInfo.CursorRect">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="THintInfo.CursorPos">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="THintInfo.ReshowTimeout">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="THintInfo.HideTimeout">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="THintInfo.HintStr">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="THintInfo.HintData">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TGetDockCaptionEvent">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TGetDockCaptionEvent.Sender">
        <short/>
      </element>
      <element name="TGetDockCaptionEvent.AControl">
        <short/>
      </element>
      <element name="TGetDockCaptionEvent.ACaption">
        <short/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDragDockObject.FEraseDockRect">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDragDockObject.FIncreaseDockArea">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragDockObject.IncreaseDockArea">
        <short>Determines whether the dock site shall be enlarged.</short>
        <descr>Not normally used, perhaps a special AnchorDocking property?</descr>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragDockObject.EraseDockRect">
        <short>The currently visible DockRect, to be removed later.</short>
        <descr>A special value indicates that the DockRect already has been removed.</descr>
        <seealso/>
      </element>
      <element name="TDragManagerDefault">
        <short>[dropped!] The default DragManager class.</short>
        <seealso>
          <link id="TDragManager"/>
        </seealso>
      </element>
      <!-- object Visibility: default -->
      <element name="TDragManager">
        <short>The abstract base class for managing the dragging of controls (to be dropped or docked).</short>
        <descr>
          <p>This is the OO version of the Delphi drag manager, implemented in TDragManagerDefault.</p>
          <remark>The registered dock sites should be stored in a persistent list, not in a DragManager instance.</remark>
          <p>[entire review DoDi 2010-02-16]</p>
        </descr>
        <errors/>
        <seealso>
          <link id="TDragManagerDefault"/>
        </seealso>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDragManager.FDragImmediate">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDragManager.FDragThreshold">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDragManager.KeyUp">
        <short>Handler for keyboard key released.</short>
        <descr>When the Ctrl key is released, a drop is enabled again.</descr>
        <errors/>
        <seealso/>
      </element>
      <element name="TDragManager.KeyUp.Key">
        <short/>
      </element>
      <element name="TDragManager.KeyUp.Shift">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDragManager.KeyDown">
        <short>Handler for keyboard key pressed.</short>
        <descr>
          <p>When (and while) the Ctrl key is pressed, dropping is disabled.</p>
          <p>The Esc key aborts the current dragging operation immediately.</p>
        </descr>
        <errors/>
        <seealso/>
      </element>
      <element name="TDragManager.KeyDown.Key">
        <short/>
      </element>
      <element name="TDragManager.KeyDown.Shift">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDragManager.CaptureChanged">
        <short>Aborts the dragging operation, when the capturing control really has changed.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TDragManager.CaptureChanged.OldCaptureControl">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDragManager.MouseMove">
        <short>Generates the visual feedback when the mouse moves.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TDragManager.MouseMove.Shift">
        <short/>
      </element>
      <element name="TDragManager.MouseMove.X">
        <short/>
      </element>
      <element name="TDragManager.MouseMove.Y">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDragManager.MouseUp">
        <short>Ends dragging.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TDragManager.MouseUp.Button">
        <short/>
      </element>
      <element name="TDragManager.MouseUp.Shift">
        <short/>
      </element>
      <element name="TDragManager.MouseUp.X">
        <short/>
      </element>
      <element name="TDragManager.MouseUp.Y">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDragManager.MouseDown">
        <short>Nop.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TDragManager.MouseDown.Button">
        <short/>
      </element>
      <element name="TDragManager.MouseDown.Shift">
        <short/>
      </element>
      <element name="TDragManager.MouseDown.X">
        <short/>
      </element>
      <element name="TDragManager.MouseDown.Y">
        <short/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TDragManager.Create">
        <short>Initializes the Delphi default dragging parameters.</short>
        <descr>
          <p>The Delphi VCL sets DragImmediate=True and DragThreshold=5.</p>
          <remark>A docking operation never should start immediately.</remark>
        </descr>
        <errors/>
        <seealso>
          <link id="#rtl.Classes.TComponent.Create">TComponent.Create</link>
        </seealso>
      </element>
      <element name="TDragManager.Create.TheOwner">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TDragManager.IsDragging">
        <short>True if dragging is in progress.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TDragManager.IsDragging.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TDragManager.Dragging">
        <short>True if the specified control is being dragged.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TDragManager.Dragging.Result">
        <short/>
      </element>
      <element name="TDragManager.Dragging.AControl">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TDragManager.RegisterDockSite">
        <short>Adds or removes the control to the list or register of docking sites.</short>
        <descr>
          <remark>This should become a class method, maintaining the list of registered docking sites outside any DragManager instance.</remark>
        </descr>
        <errors/>
        <seealso/>
      </element>
      <element name="TDragManager.RegisterDockSite.Site">
        <short/>
      </element>
      <element name="TDragManager.RegisterDockSite.DoRegister">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TDragManager.DragStart">
        <short>Starts dragging.</short>
        <descr>A DragObject must be created, depending on the Control.DragKind. The mouse has to be captured, and visual feedback must be initialized.</descr>
        <errors/>
        <seealso/>
      </element>
      <element name="TDragManager.DragStart.AControl">
        <short/>
      </element>
      <element name="TDragManager.DragStart.AImmediate">
        <short/>
      </element>
      <element name="TDragManager.DragStart.AThreshold">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TDragManager.DragMove">
        <short>Updates the visual dragging feedback.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TDragManager.DragMove.APosition">
        <short>DragStart</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TDragManager.DragStop">
        <short>Ends dragging.</short>
        <descr>
          <p>The visual feedback is reset.</p>
          <p>All related controls are notified of the outcome of the operation (drop, dock, abort).</p>
          <p>Finally all temporary objects are destroyed.</p>
        </descr>
        <errors/>
        <seealso/>
      </element>
      <element name="TDragManager.DragStop.ADrop">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragManager.DragImmediate">
        <short>Start dragging immediately, on MouseDown? (default value)</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragManager.DragThreshold">
        <short>The threshold amount by which the mouse must move before non-immediate dragging starts. (default 5 pixels)</short>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="DragManager">
        <short>The current DragManager.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDragDockCommon.SendDragMessage">
        <short>
          <var>SendDragMsg</var> - sends to AControl a drag message at specified position for nominated object; returns an integer Result for success</short>
      </element>
      <element name="TDragDockCommon.SendCmDragMsg">
        <short>
          <var>SendCmDragMsg</var> - sends to DragTarget a drag message at specified position for nominated object; returns True for success</short>
        <descr>The Result is used to select the DragCursor (deny/accept drop).</descr>
      </element>
      <element name="TDockPerformer.DragMove.FindDockSiteAtPosition">
        <short>Find a DockSite under the current mouse position.</short>
        <descr>
          <p>The list of registered docksites is searched. Sites are excluded when they are invisible or disabled, or when the site is (a child of) the dragged control.</p>
          <p>The Z-order of the docksites should be taken into account. Currently the first site found is returned.</p>
        </descr>
      </element>
      <element name="TDockPerformer.DragMove.GetDropControl">
        <short>Determine the target control within the target DockSite.</short>
        <descr>
          <p>Do nothing (return Nil) unless a DockManager is installed in the target site and something has already been docked.</p>
          <p>When the dragged control is the only client of the docksite, Nil is returned.</p>
          <p>[ToDo: The check for an drop of a control onto itself should be done in every case, after the target control has been determined.]</p>
        </descr>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TControlCellAlign">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlCellAlign.ccaFill">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlCellAlign.ccaLeftTop">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlCellAlign.ccaRightBottom">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlCellAlign.ccaCenter">
        <short/>
      </element>
      <!-- set type Visibility: default -->
      <element name="TControlCellAligns" link="TControlCellAlign"/>
      <!-- enumeration type Visibility: default -->
      <element name="TAnchorSideChangeOperation">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TAnchorSideChangeOperation.ascoAdd">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TAnchorSideChangeOperation.ascoRemove">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TAnchorSideChangeOperation.ascoChangeSide">
        <short/>
      </element>
      <!-- destructor Visibility: public -->
      <element name="TAnchorSide.Destroy">
        <short/>
        <descr/>
        <errors/>
        <seealso>
          <link id="#rtl.Classes.TPersistent.Destroy">TPersistent.Destroy</link>
        </seealso>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TChildControlResizeStyle">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TChildControlResizeStyle.crsAnchorAligning">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TChildControlResizeStyle.crsScaleChilds">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TChildControlResizeStyle.crsHomogenousChildResize">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TChildControlResizeStyle.crsHomogenousSpaceResize">
        <short/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TControlChildrenLayout">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlChildrenLayout.cclNone">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlChildrenLayout.cclLeftToRightThenTopToBottom">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlChildrenLayout.cclTopToBottomThenLeftToRight">
        <short/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControlChildSizing.FControlsPerLine">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControlChildSizing.FLayout">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControlChildSizing.SetControlsPerLine">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControlChildSizing.SetControlsPerLine.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControlChildSizing.SetLayout">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControlChildSizing.SetLayout.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControlChildSizing.SetGridSpacing">
        <short>
          <var>SetGridSpacing</var> - specifies a value for spacing on the grid (for drawing etc)</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControlChildSizing.SetGridSpacing.Spacing">
        <short/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControlChildSizing.Layout">
        <short>
          <var>Layout</var> - L-R then Top-Bottom, or Top-Bottom then L-R (or none)</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControlChildSizing.ControlsPerLine">
        <short>
          <var>ControlsPerLine</var> - number of controls per line</short>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TControlAtPosFlag">
        <short>Flags for finding a control at given (client) position.</short>
        <descr>capfAllowDisabled: include disabled controls?
capfAllowWinControls: do not find WinControls if False.
capfOnlyClientAreas: hit client areas only.
capfRecursive: search into child controls.
capfHasScrollOffset: crap, ScrollOffset is taken into account only for the first (top level) WinControl.</descr>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlAtPosFlag.capfAllowDisabled">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlAtPosFlag.capfAllowWinControls">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlAtPosFlag.capfOnlyClientAreas">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlAtPosFlag.capfRecursive">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlAtPosFlag.capfHasScrollOffset">
        <short/>
      </element>
      <!-- set type Visibility: default -->
      <element name="TControlAtPosFlags">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="DockSplitterClass">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="MainAlignAnchor">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="OppositeAnchor">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="ClockwiseAnchor">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="AnchorNames">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- function Visibility: default -->
      <element name="DbgS">
        <short>Converts items of several data types into strings, for debug output.</short>
        <descr/>
        <errors>[The parameters should have unique names, for every type]</errors>
        <seealso/>
      </element>
      <element name="DbgS.Result">
        <short>The string representing the given parameter(s).</short>
      </element>
      <element name="DbgS.a">
        <short/>
      </element>
      <element name="DbgS.Anchors">
        <short/>
      </element>
      <element name="DbgS.Side">
        <short/>
      </element>
      <element name="DbgS.p">
        <short></short>
      </element>
      <element name="DbgS.Phases">
        <short>All elements in this set will be shown as a comma-separated list.</short>
      </element>
      <element name="TControl.AnchAnchor">
        <short>Anchor to the bottom</short>
      </element>
      <!-- function Visibility: default -->
      <element name="operator :=(Variant): TCaption">
        <short></short>
        <descr>
        </descr>
        <errors>
        </errors>
        <seealso>
        </seealso>
      </element>
      <element name="operator :=(Variant): TCaption.Result">
        <short></short>
      </element>
      <element name="operator :=(Variant): TCaption.AVariant">
        <short></short>
      </element>
      <topic name="AutoSize">
        <short>
          <var>AutoSize</var> - boolean property that permits the size of a control to be adjusted automatically</short>
        <descr>
          <p>
            <var>AutoSize</var> is a boolean property found in many classes; it permits the size of a control to be adjusted automatically to accommodate differences in the text or graphic contained therein, and allows most efficient use of available space</p>
          <p>Many controls call  <link id="#lcl.Controls.TControl.DoAutoSize">TControl.DoAutoSize</link> to perform the actual auto-sizing. </p>
          <p>IMPORTANT: Many Delphi controls override this method and many call this method directly after setting some properties.</p>
          <p>During handle creation not all interfaces can create complete Device Contexts which are needed to calculate things like text size.</p>
          <p>That's why you should always call <link id="#lcl.Controls.TControl.AdjustSize">AdjustSize</link> instead of <var>DoAutoSize</var>.</p>
          <p>
            <var>TControl.AdjustSize</var> calls 
            <var>DoAutoSize</var> in a smart fashion.</p>
          <p>During loading and handle creation the calls are delayed.</p>
          <p>This method initially does the same as <link id="#lcl.Controls.TWinControl.DoAutoSize">TWinControl.DoAutoSize</link>.  But since <var>DoAutoSize</var> is commonly overriden by descendant components,  it is not useful to perform all tests, which can result in too much overhead. To reduce this the LCL calls <var>AdjustSize</var> instead.</p>
          <p>When setting <var>AutoSize</var> = true the LCL autosizes the control in width and height. This is one of the most complex parts of the LCL, because the result depends on nearly a hundred properties. Let's start simple:</p>
          <p>The LCL will only autosize the Width or Height if it is free to resize. In other words - the width is not autosized if:</p>
          <ul>
            <li>the left and right side is anchored. You can anchor the sides with the <var>Anchors</var> property or by setting the <var>Align</var> property to <var>alTop</var>, <var>alBottom</var> or <var>alClient</var>
            </li>
            <li>the Width and Height are bound by the <var>Constraints</var> properties. The Contraints can also be overriden by the widgetset. For example the winapi does not allow resizing the height of a combobox. And the gtk widgetset does not allow resizing the width of a vertical scrollbar</li>
          </ul>
          <p>The new size is calculated by the protected method <link id="#lcl.Controls.TControl.CalculatePreferredSize">TControl.CalculatePreferredSize</link>.
			      This method asks the widgetset for an appropriate Width and Height. For example a <var>TButton</var> has preferred Width and Height. A <var>TComboBox</var> has only a preferred Height. The preferred Width is returned as 0 and so the LCL does not autosize the Width - it keeps the width unaltered. Finally a <var>TMemo</var> has no preferred Width or Height. Therefore AutoSize has no effect on a TMemo.</p>
          <p>Some controls override this method. For example the <var>TGraphicControl</var> descendants like <var>TLabel</var> have no window handle and so cannot query the widgetset. They must calculate their preferred Width and Height themselves.</p>
          <p>The widgetsets must override the <var>GetPreferredSize</var> method for each widget class that has a preferred size (Width or Height or both).</p>
          <p>
            <b>Parent.AutoSize</b>
          </p>
          <p>The above described the simple explanation. The real algorithm provides far more possibilities and is therefore far more complex.</p>
          <p>
            <b>Properties / Methods</b>
          </p>
          <ul>
            <li>Left</li>
            <li>Top</li>
          </ul>
          <p>If <var>Parent</var> is not nil then <var>Left, Top</var> are the pixel distance to the top, left pixel of the parent's client area (not scrolled). Remember the client area is always without the frame and scrollbars of the parent. For Delphi users: Some VCL controls like TGroupbox define the client area as the whole control including the frame and some not - the LCL is more consistent, and therefore Delphi incompatible. Left and Top can be negative or bigger than the client area. Some widgetsets define a minimum/maximum somewhere around 10.000 or more.</p>
          <p>When the client area is scrolled the Left and Top are kept unchanged. </p>
          <p>During resizing/moving Left and Top are not always in sync with the coordinates of the Handle object.</p>
          <p>If Parent=nil then Left, Top depend on the widgetset and the window manager. Till Lazarus 0.9.25 this is typically the screen coordinate of the left,top of the client area of the form. This is Delphi incompatible. It is planned to change this to the Left, Top of the window.</p>
          <p>Hint:</p>
          <p>Each time you change Left and Top the LCL moves instantly. If you want to change both Left and Top use instead:</p>
          <code>with Button1 do
	      SetBounds(NewLeft,NewTop,Width,Height);</code>
          <ul>
            <li>Width</li>
            <li>Height</li>
          </ul>
          <p>The Size in pixels must not be negative, and most widgetsets do not allow Width=0 and/or Height=0. Some controls on some platforms define a bigger minimum constraint. Instead of sizing a control to Width=0 and/or Height=0, set Visible=false. During resizing/moving Width and Height are not always in sync with the size of the Handle object.</p>
          <ul>
            <li>BoundsRect</li>
          </ul>
          <p>Same as Bounds(Left,Top,Width,Height).</p>
          <p>Common newbie mistake:</p>
          <code>BoundsRect.Left:=3; // WRONG: common newbie mistake
</code>
          <p>This has no effect, because reading BoundsRect is a function. It creates a temporary TRect on the stack.</p>
          <ul>
            <li>ClientRect</li>
          </ul>
          <p>Left and Top are always 0,0. Width and Height are the visible size in pixels of the client area. Remember the client area is without the frame and without scrollbars. In a scrollable client area the logical client area can be bigger than the visible.</p>
          <ul>
            <li>ClientOrigin</li>
          </ul>
          <p>Returns the screen coordinate of the top left coordinate 0,0 of the client area. Note that this value is the position as stored in the interface and is not always in sync with the LCL. When a control is moved, the LCL sets the bounds to the desired position and sends a move message to the interface. It is up to the interface to handle moves instantly or queued.</p>
          <ul>
            <li>LCLIntf.GetClientBounds</li>
          </ul>
          <p>Returns the client bounds of a control. Like ClientRect, but Left and Top are the pixel distances to the control's left, top. For example on a TGroupBox the Left, Top are the width and height of the left and top frame border. Scrolling has no effect on GetClientBounds.</p>
          <ul>
            <li>LCLIntf.GetWindowRect</li>
          </ul>
          <p>After the call, ARect will be the control area in screen coordinates. That means, Left and Top will be the screen coordinate of the TopLeft pixel of the Handle object and Right and Bottom will be the screen coordinate of the BottomRight pixel.</p>
          <ul>
            <li>FBaseBoundsLock: integer</li>
          </ul>
          <p>Increased/Decreased by LockBaseBounds/UnlockBaseBounds.
		      Used to keep FBaseBounds during SetBounds calls.</p>
          <ul>
            <li>FBaseParentClientSize: TPoint</li>
          </ul>
          <p>The Parent.ClientRect size valid for the FBaseBounds.
		      FBaseBounds and FBaseParentClientSize are used to calculate the distance for
		      akRight (akBottom).
		      When the parent is resized, the LCL knows what distance to keep.</p>
          <ul>
            <li>FBoundsRectForNewParent: TRect</li>
          </ul>
          <p>When changing the Parent of a control the Handle is recreated and many
		      things can happen. Especially for docking forms the process is too
		      unreliable. Therefore the BoundsRect is saved. The VCL uses a similar
		      mechanism.</p>
          <ul>
            <li>FLastDoChangeBounds: TRect</li>
          </ul>
          <p>Used to avoid calling OnChangeBounds with the same coordinates. This reduces
				      user defined autosizing.</p>
          <ul>
            <li>FLastResizeClientHeight: integer</li>
            <li>FLastResizeClientWidth: integer</li>
            <li>FLastResizeHeight: integer</li>
            <li>FLastResizeWidth: integer</li>
          </ul>
          <p>Used to avoid calling OnResize with the same coordinates. This reduces user
				      defined autosizing.</p>
          <ul>
            <li>FLoadedClientSize: TPoint</li>
          </ul>
          <p>During loading many things are delayed and many things are set and worse: in
				      the wrong order. That's why SetClientWidth/SetClientHeight calls are stored
				      and set at end of loading again.
				      This way the LCL can restore the distances (e.g. akRight) used during
				      designing.</p>
          <ul>
            <li>FReadBounds: TRect</li>
          </ul>
          <p>Same as FLoadedClientSize, but for SetLeft, SetTop, SetWidth, SetHeight.</p>
          <ul>
            <li>procedure SetBoundsRectForNewParent(const AValue: TRect);</li>
          </ul>
          <p>Used to set FBoundsRectForNewParent. See above.</p>
          <ul>
            <li>procedure SetInitialBounds(aLeft, aTop, aWidth, aHeight: integer); virtual;</li>
          </ul>
          <p>A smart version of SetBounds, reducing overhead during creation and loading.</p>
          <ul>
            <li>procedure UpdateBaseBounds(StoreBounds, StoreParentClientSize, UseLoadedValues: boolean); virtual;</li>
          </ul>
          <p>Commit current bounds to base bounds.</p>
          <ul>
            <li>procedure SetClientHeight(Value: Integer);</li>
            <li>procedure SetClientSize(Value: TPoint);</li>
            <li>procedure SetClientWidth(Value: Integer);  </li>
          </ul>
          <p>Exists for Delphi compatibility too. Resizes the control, to get the wanted ClientRect size.</p>
          <ul>
            <li>procedure ChangeBounds(ALeft, ATop, AWidth, AHeight: integer); virtual;</li>
          </ul>
          <p>This is the internal SetBounds.
						      Applies constraints, updates base bounds, calls OnChangeBound, OnResize,
						      locks bounds.</p>
          <ul>
            <li>procedure DoSetBounds(ALeft, ATop, AWidth, AHeight: integer); virtual;</li>
          </ul>
          <p>This really sets the FLeft, FTop, FWidth, FHeight private variables.</p>
          <ul>
            <li>procedure SetBounds(aLeft, aTop, aWidth, aHeight: integer); virtual;</li>
          </ul>
          <p>This is the standard procedure overriden by many Delphi controls. TWinControl overrides it too. </p>
          <p>Ignores calls when bounds are locked; lock the FBoundsRealized to avoid overhead to the interface during auto sizing.</p>
          <p>ChangeBounds is not locked this way.</p>
          <ul>
            <li>Function GetClientOrigin: TPoint; virtual;</li>
          </ul>
          <p>Screen coordinate of Left, Top of client area.</p>
          <ul>
            <li>Function GetClientRect: TRect; virtual;</li>
          </ul>
          <p>Size of client area. (always Left=0, Top=0)</p>
          <ul>
            <li>Function GetScrolledClientRect: TRect; virtual;</li>
          </ul>
          <p>Visible client area in ClientRect.</p>
          <ul>
            <li>function GetChildsRect(Scrolled: boolean): TRect; virtual;</li>
          </ul>
          <p>Returns the Client rectangle relative to the control's Left, Top.
						      If Scrolled is true, the rectangle is moved by the current scrolling values
						      (for an example see TScrollingWincontrol).</p>
          <ul>
            <li>function GetClientScrollOffset: TPoint; virtual;</li>
          </ul>
          <p>Returns the scrolling offset of the client area.</p>
          <ul>
            <li>function GetControlOrigin: TPoint; virtual;</li>
          </ul>
          <p>Returns the screen coordinate of the topleft coordinate 0,0 of the control area. (The topleft pixel of the control on the screen)
						      Note that this value is the position as stored in the interface and is not always in sync with the LCL. When a control is moved, the LCL sets the
bounds to the wanted position and sends a move message to the interface. It is up to the interface to handle moves instantly or queued.</p>
        </descr>
      </topic>
      <topic name="Control coordinates">
        <short>The coordinates of a control can be specified or retrieved in various ways.</short>
        <descr>
          <p>The following description applies to members of TControl and TWinControl.</p>
          <p>Every control has an origin (Top, Left) and extent (Width, Height). The origin is relative to its Parent control (client coordinates) or,
            for floating controls (forms) with Parent=Nil, relative to the screen.</p>
          <p>The BoundsRect describes the TopLeft and BottomRight coordinates of the control, relative to its Parent.</p>
          <p>The BoundsRectForNewParent holds the new coordinates, to be used when the Parent of the control is changed later.</p>
          <p>The ClientRect describes the internal (client) area of a container control (TWinControl), excluding borders. Its Top and Left are always zero.
            In a TScrollingWinControl...[?]</p>
          <p>BaseBounds holds the designed Bounds, to be used e.g. when a scale factor is set later. [right?]</p>
          <p>GetControlOrigin returns the origin in screen coordinates. These values are not always in sync with the true screen position, managed by the widgetset.</p>
          <p>ScreenToClient returns the client coordinates of an point given in the screen coordinates, i.e. the coordinates relative to the control's client origin.</p>
          <p>ClientToScreen returns the screen coordinats for an point in client coordinates.</p>
        </descr>
      </topic>
    </module>
    <!-- Controls -->
  </package>
</fpdoc-descriptions>
